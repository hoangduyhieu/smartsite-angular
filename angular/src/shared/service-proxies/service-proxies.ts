/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.4.2.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getAllAuditLogs(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined, isView: boolean | undefined): Observable<AuditLogListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAllAuditLogs?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<AuditLogListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuditLogListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAuditLogs(response: HttpResponseBase): Observable<AuditLogListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuditLogListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuditLogListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(body: GetAuditLogsInput | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllServiceName(): Observable<StringLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAllServiceName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllServiceName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllServiceName(<any>response_);
                } catch (e) {
                    return <Observable<StringLookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringLookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllServiceName(response: HttpResponseBase): Observable<StringLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(StringLookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringLookupTableDto[]>(<any>null);
    }
}

@Injectable()
export class BaoCaoCanhBaoCacTramServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tramId (optional) 
     * @param tuNgay (optional) 
     * @param denNgay (optional) 
     * @param loaiCanhBao (optional) 
     * @return Success
     */
    getAllCanhBao(tramId: number | undefined, tuNgay: moment.Moment | null | undefined, denNgay: moment.Moment | null | undefined, loaiCanhBao: string | null | undefined): Observable<CanhBaoCacTramOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoCanhBaoCacTram/GetAllCanhBao?";
        if (tramId === null)
            throw new Error("The parameter 'tramId' cannot be null.");
        else if (tramId !== undefined)
            url_ += "TramId=" + encodeURIComponent("" + tramId) + "&";
        if (tuNgay !== undefined)
            url_ += "TuNgay=" + encodeURIComponent(tuNgay ? "" + tuNgay.toJSON() : "") + "&";
        if (denNgay !== undefined)
            url_ += "DenNgay=" + encodeURIComponent(denNgay ? "" + denNgay.toJSON() : "") + "&";
        if (loaiCanhBao !== undefined)
            url_ += "LoaiCanhBao=" + encodeURIComponent("" + loaiCanhBao) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<CanhBaoCacTramOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CanhBaoCacTramOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCanhBao(response: HttpResponseBase): Observable<CanhBaoCacTramOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CanhBaoCacTramOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CanhBaoCacTramOutput[]>(<any>null);
    }

    /**
     * @param tramId (optional) 
     * @param tuNgay (optional) 
     * @param denNgay (optional) 
     * @param loaiCanhBao (optional) 
     * @return Success
     */
    getAllCanhBaoList(tramId: number | undefined, tuNgay: moment.Moment | null | undefined, denNgay: moment.Moment | null | undefined, loaiCanhBao: string | null | undefined): Observable<CanhBaoCacTramOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoCanhBaoCacTram/GetAllCanhBaoList?";
        if (tramId === null)
            throw new Error("The parameter 'tramId' cannot be null.");
        else if (tramId !== undefined)
            url_ += "TramId=" + encodeURIComponent("" + tramId) + "&";
        if (tuNgay !== undefined)
            url_ += "TuNgay=" + encodeURIComponent(tuNgay ? "" + tuNgay.toJSON() : "") + "&";
        if (denNgay !== undefined)
            url_ += "DenNgay=" + encodeURIComponent(denNgay ? "" + denNgay.toJSON() : "") + "&";
        if (loaiCanhBao !== undefined)
            url_ += "LoaiCanhBao=" + encodeURIComponent("" + loaiCanhBao) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCanhBaoList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCanhBaoList(<any>response_);
                } catch (e) {
                    return <Observable<CanhBaoCacTramOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CanhBaoCacTramOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCanhBaoList(response: HttpResponseBase): Observable<CanhBaoCacTramOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CanhBaoCacTramOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CanhBaoCacTramOutput[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcelDanhSachCanhBao(body: KetQuaGuiTinNhanInput | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoCanhBaoCacTram/ExportToExcelDanhSachCanhBao";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcelDanhSachCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcelDanhSachCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcelDanhSachCanhBao(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class BaoCaoChiTietCanhBaoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tenTram (optional) 
     * @param loaiCanhBao (optional) 
     * @param tenMucDo (optional) 
     * @param tuNgay (optional) 
     * @param denNgay (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllDanhSachCanhBao(tenTram: string | null | undefined, loaiCanhBao: string | null | undefined, tenMucDo: string | null | undefined, tuNgay: moment.Moment | undefined, denNgay: moment.Moment | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<BaoCaoChiTietCanhBaoDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoChiTietCanhBao/GetAllDanhSachCanhBao?";
        if (tenTram !== undefined)
            url_ += "TenTram=" + encodeURIComponent("" + tenTram) + "&";
        if (loaiCanhBao !== undefined)
            url_ += "LoaiCanhBao=" + encodeURIComponent("" + loaiCanhBao) + "&";
        if (tenMucDo !== undefined)
            url_ += "TenMucDo=" + encodeURIComponent("" + tenMucDo) + "&";
        if (tuNgay === null)
            throw new Error("The parameter 'tuNgay' cannot be null.");
        else if (tuNgay !== undefined)
            url_ += "TuNgay=" + encodeURIComponent(tuNgay ? "" + tuNgay.toJSON() : "") + "&";
        if (denNgay === null)
            throw new Error("The parameter 'denNgay' cannot be null.");
        else if (denNgay !== undefined)
            url_ += "DenNgay=" + encodeURIComponent(denNgay ? "" + denNgay.toJSON() : "") + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDanhSachCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDanhSachCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<BaoCaoChiTietCanhBaoDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BaoCaoChiTietCanhBaoDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDanhSachCanhBao(response: HttpResponseBase): Observable<BaoCaoChiTietCanhBaoDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaoCaoChiTietCanhBaoDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BaoCaoChiTietCanhBaoDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(body: BaoCaoChiTietCanhBaoInput | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoChiTietCanhBao/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param key (optional) 
     * @return Success
     */
    getKeyCamBien(key: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoChiTietCanhBao/GetKeyCamBien?";
        if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKeyCamBien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKeyCamBien(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetKeyCamBien(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class BaoCaoDanhSachVaMaCacTramServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param phanVungId (optional) 
     * @param tuNgay (optional) 
     * @param denNgay (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBaoCaoDanhSachVaMaCacTram(phanVungId: number | null | undefined, tuNgay: moment.Moment | null | undefined, denNgay: moment.Moment | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<BaoCaoTramDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoDanhSachVaMaCacTram/GetAllBaoCaoDanhSachVaMaCacTram?";
        if (phanVungId !== undefined)
            url_ += "PhanVungId=" + encodeURIComponent("" + phanVungId) + "&";
        if (tuNgay !== undefined)
            url_ += "TuNgay=" + encodeURIComponent(tuNgay ? "" + tuNgay.toJSON() : "") + "&";
        if (denNgay !== undefined)
            url_ += "DenNgay=" + encodeURIComponent(denNgay ? "" + denNgay.toJSON() : "") + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBaoCaoDanhSachVaMaCacTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBaoCaoDanhSachVaMaCacTram(<any>response_);
                } catch (e) {
                    return <Observable<BaoCaoTramDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BaoCaoTramDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBaoCaoDanhSachVaMaCacTram(response: HttpResponseBase): Observable<BaoCaoTramDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaoCaoTramDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BaoCaoTramDtoPagedResultDto>(<any>null);
    }

    /**
     * @param pvId (optional) 
     * @param phanVungFilter (optional) 
     * @return Success
     */
    checkPhanVungTram(pvId: number | undefined, phanVungFilter: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoDanhSachVaMaCacTram/CheckPhanVungTram?";
        if (pvId === null)
            throw new Error("The parameter 'pvId' cannot be null.");
        else if (pvId !== undefined)
            url_ += "pvId=" + encodeURIComponent("" + pvId) + "&";
        if (phanVungFilter === null)
            throw new Error("The parameter 'phanVungFilter' cannot be null.");
        else if (phanVungFilter !== undefined)
            url_ += "phanVungFilter=" + encodeURIComponent("" + phanVungFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckPhanVungTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckPhanVungTram(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckPhanVungTram(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param pvId (optional) 
     * @param series (optional) 
     * @return Success
     */
    getLevelPhanVung(pvId: number | undefined, series: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoDanhSachVaMaCacTram/GetLevelPhanVung?";
        if (pvId === null)
            throw new Error("The parameter 'pvId' cannot be null.");
        else if (pvId !== undefined)
            url_ += "pvId=" + encodeURIComponent("" + pvId) + "&";
        if (series !== undefined)
            url_ += "series=" + encodeURIComponent("" + series) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLevelPhanVung(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLevelPhanVung(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetLevelPhanVung(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(body: BaoCaoDanhSachTramInput | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoDanhSachVaMaCacTram/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class BaoCaoKetQuaGuiNhanTinCanhBaoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tramId (optional) 
     * @param tuNgay (optional) 
     * @param denNgay (optional) 
     * @param loaiCanhBao (optional) 
     * @return Success
     */
    getAllCanhBao(tramId: number | undefined, tuNgay: moment.Moment | null | undefined, denNgay: moment.Moment | null | undefined, loaiCanhBao: string | null | undefined): Observable<KetQuaGuiTinNhanOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoKetQuaGuiNhanTinCanhBao/GetAllCanhBao?";
        if (tramId === null)
            throw new Error("The parameter 'tramId' cannot be null.");
        else if (tramId !== undefined)
            url_ += "TramId=" + encodeURIComponent("" + tramId) + "&";
        if (tuNgay !== undefined)
            url_ += "TuNgay=" + encodeURIComponent(tuNgay ? "" + tuNgay.toJSON() : "") + "&";
        if (denNgay !== undefined)
            url_ += "DenNgay=" + encodeURIComponent(denNgay ? "" + denNgay.toJSON() : "") + "&";
        if (loaiCanhBao !== undefined)
            url_ += "LoaiCanhBao=" + encodeURIComponent("" + loaiCanhBao) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<KetQuaGuiTinNhanOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<KetQuaGuiTinNhanOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCanhBao(response: HttpResponseBase): Observable<KetQuaGuiTinNhanOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(KetQuaGuiTinNhanOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KetQuaGuiTinNhanOutput[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcelDanhSachCanhBao(body: KetQuaGuiTinNhanInput | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoKetQuaGuiNhanTinCanhBao/ExportToExcelDanhSachCanhBao";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcelDanhSachCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcelDanhSachCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcelDanhSachCanhBao(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class BaoCaoLogHeThongServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTenNguoiDung(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoLogHeThong/GetTenNguoiDung";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenNguoiDung(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenNguoiDung(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenNguoiDung(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @param nguoiDung (optional) 
     * @param tuNgay (optional) 
     * @param denNgay (optional) 
     * @return Success
     */
    getAllCBaoCao(nguoiDung: number | undefined, tuNgay: moment.Moment | undefined, denNgay: moment.Moment | undefined): Observable<BaoCaoLogHeThongChartDto> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoLogHeThong/GetAllCBaoCao?";
        if (nguoiDung === null)
            throw new Error("The parameter 'nguoiDung' cannot be null.");
        else if (nguoiDung !== undefined)
            url_ += "NguoiDung=" + encodeURIComponent("" + nguoiDung) + "&";
        if (tuNgay === null)
            throw new Error("The parameter 'tuNgay' cannot be null.");
        else if (tuNgay !== undefined)
            url_ += "TuNgay=" + encodeURIComponent(tuNgay ? "" + tuNgay.toJSON() : "") + "&";
        if (denNgay === null)
            throw new Error("The parameter 'denNgay' cannot be null.");
        else if (denNgay !== undefined)
            url_ += "DenNgay=" + encodeURIComponent(denNgay ? "" + denNgay.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCBaoCao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCBaoCao(<any>response_);
                } catch (e) {
                    return <Observable<BaoCaoLogHeThongChartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BaoCaoLogHeThongChartDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCBaoCao(response: HttpResponseBase): Observable<BaoCaoLogHeThongChartDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaoCaoLogHeThongChartDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BaoCaoLogHeThongChartDto>(<any>null);
    }

    /**
     * @param nguoiDung (optional) 
     * @param tuNgay (optional) 
     * @param denNgay (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTableCBaoCao(nguoiDung: number | undefined, tuNgay: moment.Moment | undefined, denNgay: moment.Moment | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<BaoCaoLogHeThongTableDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoLogHeThong/GetAllTableCBaoCao?";
        if (nguoiDung === null)
            throw new Error("The parameter 'nguoiDung' cannot be null.");
        else if (nguoiDung !== undefined)
            url_ += "NguoiDung=" + encodeURIComponent("" + nguoiDung) + "&";
        if (tuNgay === null)
            throw new Error("The parameter 'tuNgay' cannot be null.");
        else if (tuNgay !== undefined)
            url_ += "TuNgay=" + encodeURIComponent(tuNgay ? "" + tuNgay.toJSON() : "") + "&";
        if (denNgay === null)
            throw new Error("The parameter 'denNgay' cannot be null.");
        else if (denNgay !== undefined)
            url_ += "DenNgay=" + encodeURIComponent(denNgay ? "" + denNgay.toJSON() : "") + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTableCBaoCao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTableCBaoCao(<any>response_);
                } catch (e) {
                    return <Observable<BaoCaoLogHeThongTableDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BaoCaoLogHeThongTableDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTableCBaoCao(response: HttpResponseBase): Observable<BaoCaoLogHeThongTableDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaoCaoLogHeThongTableDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BaoCaoLogHeThongTableDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(body: BaoCaoLogHeThongInput | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoLogHeThong/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class BaoCaoNhienLieuMayNoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getListTram(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoNhienLieuMayNo/GetListTram";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListTram(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListTram(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @param tramId (optional) 
     * @param tuNgay (optional) 
     * @param denNgay (optional) 
     * @return Success
     */
    getAllCBaoCao(tramId: number | undefined, tuNgay: moment.Moment | undefined, denNgay: moment.Moment | undefined): Observable<BaoCaoNhienLieuMayNoChartDto> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoNhienLieuMayNo/GetAllCBaoCao?";
        if (tramId === null)
            throw new Error("The parameter 'tramId' cannot be null.");
        else if (tramId !== undefined)
            url_ += "TramId=" + encodeURIComponent("" + tramId) + "&";
        if (tuNgay === null)
            throw new Error("The parameter 'tuNgay' cannot be null.");
        else if (tuNgay !== undefined)
            url_ += "TuNgay=" + encodeURIComponent(tuNgay ? "" + tuNgay.toJSON() : "") + "&";
        if (denNgay === null)
            throw new Error("The parameter 'denNgay' cannot be null.");
        else if (denNgay !== undefined)
            url_ += "DenNgay=" + encodeURIComponent(denNgay ? "" + denNgay.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCBaoCao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCBaoCao(<any>response_);
                } catch (e) {
                    return <Observable<BaoCaoNhienLieuMayNoChartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BaoCaoNhienLieuMayNoChartDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCBaoCao(response: HttpResponseBase): Observable<BaoCaoNhienLieuMayNoChartDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaoCaoNhienLieuMayNoChartDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BaoCaoNhienLieuMayNoChartDto>(<any>null);
    }

    /**
     * @param tramId (optional) 
     * @param tuNgay (optional) 
     * @param denNgay (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTableCBaoCao(tramId: number | undefined, tuNgay: moment.Moment | undefined, denNgay: moment.Moment | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<BaoCaoNhienLieuMayNoTableDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoNhienLieuMayNo/GetAllTableCBaoCao?";
        if (tramId === null)
            throw new Error("The parameter 'tramId' cannot be null.");
        else if (tramId !== undefined)
            url_ += "TramId=" + encodeURIComponent("" + tramId) + "&";
        if (tuNgay === null)
            throw new Error("The parameter 'tuNgay' cannot be null.");
        else if (tuNgay !== undefined)
            url_ += "TuNgay=" + encodeURIComponent(tuNgay ? "" + tuNgay.toJSON() : "") + "&";
        if (denNgay === null)
            throw new Error("The parameter 'denNgay' cannot be null.");
        else if (denNgay !== undefined)
            url_ += "DenNgay=" + encodeURIComponent(denNgay ? "" + denNgay.toJSON() : "") + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTableCBaoCao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTableCBaoCao(<any>response_);
                } catch (e) {
                    return <Observable<BaoCaoNhienLieuMayNoTableDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BaoCaoNhienLieuMayNoTableDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTableCBaoCao(response: HttpResponseBase): Observable<BaoCaoNhienLieuMayNoTableDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaoCaoNhienLieuMayNoTableDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BaoCaoNhienLieuMayNoTableDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(body: BaoCaoNhienLieuMayNoTableInput | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoNhienLieuMayNo/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class BaoCaoThongTinTramServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tramId (optional) 
     * @param tuNgay (optional) 
     * @param denNgay (optional) 
     * @return Success
     */
    getAllBaoCaoThongTinTram(tramId: number | undefined, tuNgay: moment.Moment | undefined, denNgay: moment.Moment | undefined): Observable<BaoCaoTTTramOutput> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoThongTinTram/GetAllBaoCaoThongTinTram?";
        if (tramId === null)
            throw new Error("The parameter 'tramId' cannot be null.");
        else if (tramId !== undefined)
            url_ += "TramId=" + encodeURIComponent("" + tramId) + "&";
        if (tuNgay === null)
            throw new Error("The parameter 'tuNgay' cannot be null.");
        else if (tuNgay !== undefined)
            url_ += "TuNgay=" + encodeURIComponent(tuNgay ? "" + tuNgay.toJSON() : "") + "&";
        if (denNgay === null)
            throw new Error("The parameter 'denNgay' cannot be null.");
        else if (denNgay !== undefined)
            url_ += "DenNgay=" + encodeURIComponent(denNgay ? "" + denNgay.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBaoCaoThongTinTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBaoCaoThongTinTram(<any>response_);
                } catch (e) {
                    return <Observable<BaoCaoTTTramOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<BaoCaoTTTramOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBaoCaoThongTinTram(response: HttpResponseBase): Observable<BaoCaoTTTramOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaoCaoTTTramOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BaoCaoTTTramOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getListTram(): Observable<ListTram[]> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoThongTinTram/GetListTram";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListTram(<any>response_);
                } catch (e) {
                    return <Observable<ListTram[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListTram[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListTram(response: HttpResponseBase): Observable<ListTram[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ListTram.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListTram[]>(<any>null);
    }

    /**
     * @param deviceId (optional) 
     * @return Success
     */
    getListKeysTelemetry(deviceId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoThongTinTram/GetListKeysTelemetry?";
        if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListKeysTelemetry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListKeysTelemetry(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetListKeysTelemetry(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(body: GetAllBaoCaoThongTinTramInput | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoThongTinTram/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class BaoCaoTrangThaiKetNoiTramServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tramId (optional) 
     * @param tuNgay (optional) 
     * @param denNgay (optional) 
     * @return Success
     */
    getAllBaoCaoTrangThaiKetNoi(tramId: number | null | undefined, tuNgay: moment.Moment | undefined, denNgay: moment.Moment | undefined): Observable<BaoCaoTrangThaiKetNoiOutput> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoTrangThaiKetNoiTram/GetAllBaoCaoTrangThaiKetNoi?";
        if (tramId !== undefined)
            url_ += "TramId=" + encodeURIComponent("" + tramId) + "&";
        if (tuNgay === null)
            throw new Error("The parameter 'tuNgay' cannot be null.");
        else if (tuNgay !== undefined)
            url_ += "TuNgay=" + encodeURIComponent(tuNgay ? "" + tuNgay.toJSON() : "") + "&";
        if (denNgay === null)
            throw new Error("The parameter 'denNgay' cannot be null.");
        else if (denNgay !== undefined)
            url_ += "DenNgay=" + encodeURIComponent(denNgay ? "" + denNgay.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBaoCaoTrangThaiKetNoi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBaoCaoTrangThaiKetNoi(<any>response_);
                } catch (e) {
                    return <Observable<BaoCaoTrangThaiKetNoiOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<BaoCaoTrangThaiKetNoiOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBaoCaoTrangThaiKetNoi(response: HttpResponseBase): Observable<BaoCaoTrangThaiKetNoiOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaoCaoTrangThaiKetNoiOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BaoCaoTrangThaiKetNoiOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(body: BaoCaoTrangThaiKetNoiInput | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoTrangThaiKetNoiTram/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class CauHinhChungServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    test(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/CauHinhChung/Test";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processTest(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CauHinhChungDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/CauHinhChung/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<CauHinhChungDto> {
        let url_ = this.baseUrl + "/api/services/app/CauHinhChung/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CauHinhChungDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CauHinhChungDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<CauHinhChungDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CauHinhChungDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CauHinhChungDto>(<any>null);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ChartServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(): Observable<void> {
        let url_ = this.baseUrl + "/api/Chart/Get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param mucdo (optional) 
     * @return Success
     */
    getAllInDashboard(mucdo: string | null | undefined): Observable<CanhBaoDashboadOutput> {
        let url_ = this.baseUrl + "/api/services/app/Dashboard/GetAllInDashboard?";
        if (mucdo !== undefined)
            url_ += "mucdo=" + encodeURIComponent("" + mucdo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInDashboard(<any>response_);
                } catch (e) {
                    return <Observable<CanhBaoDashboadOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CanhBaoDashboadOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllInDashboard(response: HttpResponseBase): Observable<CanhBaoDashboadOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CanhBaoDashboadOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CanhBaoDashboadOutput>(<any>null);
    }

    /**
     * @param mucdo (optional) 
     * @return Success
     */
    getAllPieChartTabView(mucdo: string | null | undefined): Observable<CanhBaoPieChartTabView> {
        let url_ = this.baseUrl + "/api/services/app/Dashboard/GetAllPieChartTabView?";
        if (mucdo !== undefined)
            url_ += "mucdo=" + encodeURIComponent("" + mucdo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPieChartTabView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPieChartTabView(<any>response_);
                } catch (e) {
                    return <Observable<CanhBaoPieChartTabView>><any>_observableThrow(e);
                }
            } else
                return <Observable<CanhBaoPieChartTabView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPieChartTabView(response: HttpResponseBase): Observable<CanhBaoPieChartTabView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CanhBaoPieChartTabView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CanhBaoPieChartTabView>(<any>null);
    }

    /**
     * @param mucdo (optional) 
     * @return Success
     */
    getListCanhBao(mucdo: string | null | undefined): Observable<TabViewCanhBao[]> {
        let url_ = this.baseUrl + "/api/services/app/Dashboard/GetListCanhBao?";
        if (mucdo !== undefined)
            url_ += "mucdo=" + encodeURIComponent("" + mucdo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<TabViewCanhBao[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TabViewCanhBao[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListCanhBao(response: HttpResponseBase): Observable<TabViewCanhBao[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TabViewCanhBao.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TabViewCanhBao[]>(<any>null);
    }
}

@Injectable()
export class DataManagerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getData(): Observable<DMCanhBaoOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/DataManager/GetData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetData(<any>response_);
                } catch (e) {
                    return <Observable<DMCanhBaoOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DMCanhBaoOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetData(response: HttpResponseBase): Observable<DMCanhBaoOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DMCanhBaoOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DMCanhBaoOutput[]>(<any>null);
    }
}

@Injectable()
export class DemoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<DemoForViewPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Demo/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<DemoForViewPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DemoForViewPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DemoForViewPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DemoForViewPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DemoForViewPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: DemoCreateInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Demo/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<DemoCreateInput> {
        let url_ = this.baseUrl + "/api/services/app/Demo/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<DemoCreateInput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DemoCreateInput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<DemoCreateInput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DemoCreateInput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DemoCreateInput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Demo/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(body: DemoGetAllInputDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Demo/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filePath (optional) 
     * @return Success
     */
    importFileExcel(filePath: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Demo/ImportFileExcel?";
        if (filePath !== undefined)
            url_ += "FilePath=" + encodeURIComponent("" + filePath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportFileExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportFileExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processImportFileExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    downloadFileMau(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Demo/DownloadFileMau";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileMau(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileMau(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileMau(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param linkFile (optional) 
     * @return Success
     */
    downloadFileUpload(linkFile: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Demo/DownloadFileUpload?";
        if (linkFile !== undefined)
            url_ += "linkFile=" + encodeURIComponent("" + linkFile) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileUpload(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileUpload(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class DMBoCanhBaoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<BoCanhBaoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DMBoCanhBao/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<BoCanhBaoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BoCanhBaoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<BoCanhBaoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BoCanhBaoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BoCanhBaoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: BoCanhBaoCreateInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DMBoCanhBao/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined, isView: boolean | undefined): Observable<BoCanhBao> {
        let url_ = this.baseUrl + "/api/services/app/DMBoCanhBao/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<BoCanhBao>><any>_observableThrow(e);
                }
            } else
                return <Observable<BoCanhBao>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<BoCanhBao> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BoCanhBao.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BoCanhBao>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DMBoCanhBao/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DMCanhBaoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param boCanhBaoId (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined, boCanhBaoId: number | undefined): Observable<CanhBaoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DMCanhBao/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (boCanhBaoId === null)
            throw new Error("The parameter 'boCanhBaoId' cannot be null.");
        else if (boCanhBaoId !== undefined)
            url_ += "boCanhBaoId=" + encodeURIComponent("" + boCanhBaoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<CanhBaoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CanhBaoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CanhBaoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CanhBaoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CanhBaoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CanhBaoCreateInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DMCanhBao/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param idCanhBao (optional) 
     * @return Success
     */
    createOrUpdateThinkboard(idCanhBao: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DMCanhBao/CreateOrUpdateThinkboard?";
        if (idCanhBao === null)
            throw new Error("The parameter 'idCanhBao' cannot be null.");
        else if (idCanhBao !== undefined)
            url_ += "idCanhBao=" + encodeURIComponent("" + idCanhBao) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateThinkboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateThinkboard(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateThinkboard(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<CanhBao> {
        let url_ = this.baseUrl + "/api/services/app/DMCanhBao/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CanhBao>><any>_observableThrow(e);
                }
            } else
                return <Observable<CanhBao>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<CanhBao> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CanhBao.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CanhBao>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DMCanhBao/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteList(input: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DMCanhBao/DeleteList?";
        if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteList(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param idCanhBao (optional) 
     * @return Success
     */
    deleteThinkboard(idCanhBao: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DMCanhBao/DeleteThinkboard?";
        if (idCanhBao === null)
            throw new Error("The parameter 'idCanhBao' cannot be null.");
        else if (idCanhBao !== undefined)
            url_ += "idCanhBao=" + encodeURIComponent("" + idCanhBao) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteThinkboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteThinkboard(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteThinkboard(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteByIdBoCanhBao(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DMCanhBao/DeleteByIdBoCanhBao?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteByIdBoCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteByIdBoCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteByIdBoCanhBao(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DMMauCanhBaoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllLookupTableMauCanhBao(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DMMauCanhBao/GetAllLookupTableMauCanhBao";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLookupTableMauCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLookupTableMauCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLookupTableMauCanhBao(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @param ten (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(ten: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<MauCanhBaoDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DMMauCanhBao/GetAll?";
        if (ten !== undefined)
            url_ += "Ten=" + encodeURIComponent("" + ten) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<MauCanhBaoDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MauCanhBaoDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MauCanhBaoDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MauCanhBaoDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MauCanhBaoDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditMauCanhBao | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMMauCanhBao/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined, isView: boolean | undefined): Observable<CreateOrEditMauCanhBao> {
        let url_ = this.baseUrl + "/api/services/app/DMMauCanhBao/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditMauCanhBao>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditMauCanhBao>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<CreateOrEditMauCanhBao> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditMauCanhBao.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditMauCanhBao>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DMMauCanhBao/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param mauDieuKhienid (optional) 
     * @return Success
     */
    exportToExcel(mauDieuKhienid: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/DMMauCanhBao/ExportToExcel?";
        if (mauDieuKhienid === null)
            throw new Error("The parameter 'mauDieuKhienid' cannot be null.");
        else if (mauDieuKhienid !== undefined)
            url_ += "mauDieuKhienid=" + encodeURIComponent("" + mauDieuKhienid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    downloadFileMau(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/DMMauCanhBao/DownloadFileMau";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileMau(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileMau(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileMau(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filePath (optional) 
     * @return Success
     */
    importFileExcel(filePath: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DMMauCanhBao/ImportFileExcel?";
        if (filePath !== undefined)
            url_ += "FilePath=" + encodeURIComponent("" + filePath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportFileExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportFileExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processImportFileExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class DMMauDieuKhienServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllLookupTableMauDieuKhien(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DMMauDieuKhien/GetAllLookupTableMauDieuKhien";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLookupTableMauDieuKhien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLookupTableMauDieuKhien(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLookupTableMauDieuKhien(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @param ten (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(ten: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<MauDieuKhienDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DMMauDieuKhien/GetAll?";
        if (ten !== undefined)
            url_ += "Ten=" + encodeURIComponent("" + ten) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<MauDieuKhienDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MauDieuKhienDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MauDieuKhienDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MauDieuKhienDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MauDieuKhienDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditMauDieuKhien | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMMauDieuKhien/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined, isView: boolean | undefined): Observable<CreateOrEditMauDieuKhien> {
        let url_ = this.baseUrl + "/api/services/app/DMMauDieuKhien/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditMauDieuKhien>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditMauDieuKhien>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<CreateOrEditMauDieuKhien> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditMauDieuKhien.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditMauDieuKhien>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DMMauDieuKhien/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filePath (optional) 
     * @return Success
     */
    importFileExcel(filePath: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DMMauDieuKhien/ImportFileExcel?";
        if (filePath !== undefined)
            url_ += "FilePath=" + encodeURIComponent("" + filePath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportFileExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportFileExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processImportFileExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param mauDieuKhienid (optional) 
     * @return Success
     */
    exportToExcel(mauDieuKhienid: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/DMMauDieuKhien/ExportToExcel?";
        if (mauDieuKhienid === null)
            throw new Error("The parameter 'mauDieuKhienid' cannot be null.");
        else if (mauDieuKhienid !== undefined)
            url_ += "mauDieuKhienid=" + encodeURIComponent("" + mauDieuKhienid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    downloadFileMau(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/DMMauDieuKhien/DownloadFileMau";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileMau(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileMau(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileMau(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class DMMauDuLieuCamBienServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyWord (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyWord: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<MauDuLieuCamBienDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DMMauDuLieuCamBien/GetAll?";
        if (keyWord !== undefined)
            url_ += "KeyWord=" + encodeURIComponent("" + keyWord) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<MauDuLieuCamBienDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MauDuLieuCamBienDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MauDuLieuCamBienDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MauDuLieuCamBienDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MauDuLieuCamBienDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditMauDuLieuCamBienDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DMMauDuLieuCamBien/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined, isView: boolean | undefined): Observable<CreateOrEditMauDuLieuCamBienDto> {
        let url_ = this.baseUrl + "/api/services/app/DMMauDuLieuCamBien/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditMauDuLieuCamBienDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditMauDuLieuCamBienDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<CreateOrEditMauDuLieuCamBienDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditMauDuLieuCamBienDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditMauDuLieuCamBienDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DMMauDuLieuCamBien/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllValue(): Observable<MauDuLieuCamBienDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DMMauDuLieuCamBien/GetAllValue";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllValue(<any>response_);
                } catch (e) {
                    return <Observable<MauDuLieuCamBienDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MauDuLieuCamBienDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllValue(response: HttpResponseBase): Observable<MauDuLieuCamBienDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MauDuLieuCamBienDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MauDuLieuCamBienDto[]>(<any>null);
    }
}

@Injectable()
export class DMMauThuocTinhServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllLookupTableThuocTinh(): Observable<KieuDuLieuLookupTable[]> {
        let url_ = this.baseUrl + "/api/services/app/DMMauThuocTinh/GetAllLookupTableThuocTinh";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLookupTableThuocTinh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLookupTableThuocTinh(<any>response_);
                } catch (e) {
                    return <Observable<KieuDuLieuLookupTable[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<KieuDuLieuLookupTable[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLookupTableThuocTinh(response: HttpResponseBase): Observable<KieuDuLieuLookupTable[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(KieuDuLieuLookupTable.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KieuDuLieuLookupTable[]>(<any>null);
    }

    /**
     * @param keyWord (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyWord: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<MauThuocTinhDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DMMauThuocTinh/GetAll?";
        if (keyWord !== undefined)
            url_ += "KeyWord=" + encodeURIComponent("" + keyWord) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<MauThuocTinhDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MauThuocTinhDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MauThuocTinhDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MauThuocTinhDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MauThuocTinhDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDanhSach(): Observable<MauThuocTinhDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DMMauThuocTinh/GetDanhSach";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDanhSach(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDanhSach(<any>response_);
                } catch (e) {
                    return <Observable<MauThuocTinhDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MauThuocTinhDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDanhSach(response: HttpResponseBase): Observable<MauThuocTinhDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MauThuocTinhDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MauThuocTinhDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditMauThuocTinhDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DMMauThuocTinh/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined, isView: boolean | undefined): Observable<CreateOrEditMauThuocTinhDto> {
        let url_ = this.baseUrl + "/api/services/app/DMMauThuocTinh/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditMauThuocTinhDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditMauThuocTinhDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<CreateOrEditMauThuocTinhDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditMauThuocTinhDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditMauThuocTinhDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DMMauThuocTinh/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DMNguoiNhanCanhBaoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<NguoiNhanCanhBaoDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DMNguoiNhanCanhBao/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<NguoiNhanCanhBaoDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NguoiNhanCanhBaoDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<NguoiNhanCanhBaoDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NguoiNhanCanhBaoDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NguoiNhanCanhBaoDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<NguoiNhanCanhBaoDto> {
        let url_ = this.baseUrl + "/api/services/app/DMNguoiNhanCanhBao/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<NguoiNhanCanhBaoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NguoiNhanCanhBaoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<NguoiNhanCanhBaoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NguoiNhanCanhBaoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NguoiNhanCanhBaoDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: NguoiNhanCanhBaoCreateInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DMNguoiNhanCanhBao/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DMNguoiNhanCanhBao/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendMail(body: EmailToSendInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DMNguoiNhanCanhBao/SendMail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendMail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DMNhanVienRaVaoTramServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<NhanVienRaVaoTramDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DMNhanVienRaVaoTram/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<NhanVienRaVaoTramDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NhanVienRaVaoTramDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<NhanVienRaVaoTramDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhanVienRaVaoTramDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhanVienRaVaoTramDtoPagedResultDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param tramId (optional) 
     * @param chucVu (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getListNvByTramId(keyword: string | null | undefined, tramId: number | undefined, chucVu: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<NhanVienRaVaoTramGetByTramIdOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DMNhanVienRaVaoTram/GetListNvByTramId?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (tramId === null)
            throw new Error("The parameter 'tramId' cannot be null.");
        else if (tramId !== undefined)
            url_ += "TramId=" + encodeURIComponent("" + tramId) + "&";
        if (chucVu !== undefined)
            url_ += "ChucVu=" + encodeURIComponent("" + chucVu) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListNvByTramId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListNvByTramId(<any>response_);
                } catch (e) {
                    return <Observable<NhanVienRaVaoTramGetByTramIdOutputDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NhanVienRaVaoTramGetByTramIdOutputDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetListNvByTramId(response: HttpResponseBase): Observable<NhanVienRaVaoTramGetByTramIdOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhanVienRaVaoTramGetByTramIdOutputDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhanVienRaVaoTramGetByTramIdOutputDtoPagedResultDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    delete(input: number[] | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DMNhanVienRaVaoTram/Delete?";
        if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param maNhanVien (optional) 
     * @param emailAddress (optional) 
     * @param maThe (optional) 
     * @param sdt (optional) 
     * @param id (optional) 
     * @return Success
     */
    checkExist(maNhanVien: string | null | undefined, emailAddress: string | null | undefined, maThe: string | null | undefined, sdt: string | null | undefined, id: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DMNhanVienRaVaoTram/CheckExist?";
        if (maNhanVien !== undefined)
            url_ += "maNhanVien=" + encodeURIComponent("" + maNhanVien) + "&";
        if (emailAddress !== undefined)
            url_ += "emailAddress=" + encodeURIComponent("" + emailAddress) + "&";
        if (maThe !== undefined)
            url_ += "maThe=" + encodeURIComponent("" + maThe) + "&";
        if (sdt !== undefined)
            url_ += "sdt=" + encodeURIComponent("" + sdt) + "&";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckExist(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCheckExist(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: NhanVienRaVaoTramDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DMNhanVienRaVaoTram/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined, isView: boolean | undefined): Observable<NhanVienRaVaoTramDto> {
        let url_ = this.baseUrl + "/api/services/app/DMNhanVienRaVaoTram/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<NhanVienRaVaoTramDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NhanVienRaVaoTramDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<NhanVienRaVaoTramDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhanVienRaVaoTramDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhanVienRaVaoTramDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: NhanVienRaVaoTramDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DMNhanVienRaVaoTram/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getListTramByNhanVien(input: number | undefined): Observable<TramNhanVienDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DMNhanVienRaVaoTram/GetListTramByNhanVien?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListTramByNhanVien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListTramByNhanVien(<any>response_);
                } catch (e) {
                    return <Observable<TramNhanVienDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TramNhanVienDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListTramByNhanVien(response: HttpResponseBase): Observable<TramNhanVienDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TramNhanVienDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TramNhanVienDto[]>(<any>null);
    }

    /**
     * @param tramNVs (optional) 
     * @param nhanViens (optional) 
     * @param tbEntityId (optional) 
     * @return Success
     */
    deleteNVKhoiTram(tramNVs: TramNhanVien[] | null | undefined, nhanViens: NhanVienRaVaoTramGetByTramIdOutputDto[] | null | undefined, tbEntityId: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DMNhanVienRaVaoTram/DeleteNVKhoiTram?";
        if (tramNVs !== undefined)
            tramNVs && tramNVs.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "TramNVs[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (nhanViens !== undefined)
            nhanViens && nhanViens.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "NhanViens[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tbEntityId !== undefined)
            url_ += "TbEntityId=" + encodeURIComponent("" + tbEntityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNVKhoiTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNVKhoiTram(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNVKhoiTram(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setQuanLyTram(body: SetQuanLyTramInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DMNhanVienRaVaoTram/SetQuanLyTram";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetQuanLyTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetQuanLyTram(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processSetQuanLyTram(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    ganNhanVienVaoTram(body: GanNhanViensVaoTramInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DMNhanVienRaVaoTram/GanNhanVienVaoTram";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGanNhanVienVaoTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGanNhanVienVaoTram(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGanNhanVienVaoTram(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param tbEntityId (optional) 
     * @param tramId (optional) 
     * @return Success
     */
    getNvsRavaoTramFromThingBoard(tbEntityId: string | null | undefined, tramId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DMNhanVienRaVaoTram/GetNvsRavaoTramFromThingBoard?";
        if (tbEntityId !== undefined)
            url_ += "TbEntityId=" + encodeURIComponent("" + tbEntityId) + "&";
        if (tramId === null)
            throw new Error("The parameter 'tramId' cannot be null.");
        else if (tramId !== undefined)
            url_ += "TramId=" + encodeURIComponent("" + tramId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNvsRavaoTramFromThingBoard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNvsRavaoTramFromThingBoard(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetNvsRavaoTramFromThingBoard(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getNhanVienRaVaoTram(input: string | null | undefined): Observable<NhanVienRaVaoTramDto> {
        let url_ = this.baseUrl + "/api/services/app/DMNhanVienRaVaoTram/GetNhanVienRaVaoTram?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNhanVienRaVaoTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNhanVienRaVaoTram(<any>response_);
                } catch (e) {
                    return <Observable<NhanVienRaVaoTramDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NhanVienRaVaoTramDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetNhanVienRaVaoTram(response: HttpResponseBase): Observable<NhanVienRaVaoTramDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhanVienRaVaoTramDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhanVienRaVaoTramDto>(<any>null);
    }
}

@Injectable()
export class DMPhanVungServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param isSearch (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isSearch: boolean | null | undefined): Observable<PhanVungForView[]> {
        let url_ = this.baseUrl + "/api/services/app/DMPhanVung/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PhanVungForView[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PhanVungForView[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PhanVungForView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PhanVungForView.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PhanVungForView[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DMPhanVung/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined, isView: boolean | undefined): Observable<PhanVungCreateInputDto> {
        let url_ = this.baseUrl + "/api/services/app/DMPhanVung/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<PhanVungCreateInputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PhanVungCreateInputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<PhanVungCreateInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PhanVungCreateInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PhanVungCreateInputDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getNguoiDung(id: number[] | null | undefined): Observable<PhanVungNguoiDungDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DMPhanVung/GetNguoiDung?";
        if (id !== undefined)
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNguoiDung(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNguoiDung(<any>response_);
                } catch (e) {
                    return <Observable<PhanVungNguoiDungDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PhanVungNguoiDungDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetNguoiDung(response: HttpResponseBase): Observable<PhanVungNguoiDungDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PhanVungNguoiDungDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PhanVungNguoiDungDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getLuatCanhBao(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DMPhanVung/GetLuatCanhBao";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLuatCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLuatCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLuatCanhBao(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getNguoiNhanCanhBao(): Observable<NguoiNhanCanhBaoLookupTable[]> {
        let url_ = this.baseUrl + "/api/services/app/DMPhanVung/GetNguoiNhanCanhBao";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNguoiNhanCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNguoiNhanCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<NguoiNhanCanhBaoLookupTable[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NguoiNhanCanhBaoLookupTable[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetNguoiNhanCanhBao(response: HttpResponseBase): Observable<NguoiNhanCanhBaoLookupTable[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(NguoiNhanCanhBaoLookupTable.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NguoiNhanCanhBaoLookupTable[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: PhanVungCreateInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DMPhanVung/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: PhanVungCreateInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DMPhanVung/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createAccountShinobi(body: PhanVung | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMPhanVung/CreateAccountShinobi";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAccountShinobi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAccountShinobi(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAccountShinobi(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param phanVungId (optional) 
     * @param phanVungChaId (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeCameraToAccountShinobi(phanVungId: number | undefined, phanVungChaId: number | null | undefined, body: number[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMPhanVung/ChangeCameraToAccountShinobi?";
        if (phanVungId === null)
            throw new Error("The parameter 'phanVungId' cannot be null.");
        else if (phanVungId !== undefined)
            url_ += "phanVungId=" + encodeURIComponent("" + phanVungId) + "&";
        if (phanVungChaId !== undefined)
            url_ += "phanVungChaId=" + encodeURIComponent("" + phanVungChaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeCameraToAccountShinobi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeCameraToAccountShinobi(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangeCameraToAccountShinobi(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param listRemove (optional) 
     * @param phanVungId (optional) 
     * @param phanVungChaId (optional) 
     * @return Success
     */
    removeCameraToAccountShinobi(listRemove: number[] | null | undefined, phanVungId: number | undefined, phanVungChaId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMPhanVung/RemoveCameraToAccountShinobi?";
        if (listRemove !== undefined)
            listRemove && listRemove.forEach(item => { url_ += "listRemove=" + encodeURIComponent("" + item) + "&"; });
        if (phanVungId === null)
            throw new Error("The parameter 'phanVungId' cannot be null.");
        else if (phanVungId !== undefined)
            url_ += "phanVungId=" + encodeURIComponent("" + phanVungId) + "&";
        if (phanVungChaId !== undefined)
            url_ += "phanVungChaId=" + encodeURIComponent("" + phanVungChaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveCameraToAccountShinobi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveCameraToAccountShinobi(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveCameraToAccountShinobi(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param list (optional) 
     * @param id (optional) 
     * @param listReturn (optional) 
     * @return Success
     */
    getPhanVungChildrenSeperated(list: PhanVung[] | null | undefined, id: number | undefined, listReturn: number[] | null | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/app/DMPhanVung/GetPhanVungChildrenSeperated?";
        if (list !== undefined)
            list && list.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "list[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (listReturn !== undefined)
            listReturn && listReturn.forEach(item => { url_ += "listReturn=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPhanVungChildrenSeperated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPhanVungChildrenSeperated(<any>response_);
                } catch (e) {
                    return <Observable<number[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<number[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPhanVungChildrenSeperated(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(<any>null);
    }

    /**
     * @param list (optional) 
     * @param idCha (optional) 
     * @param listReturn (optional) 
     * @return Success
     */
    getPhanVungFatherSeperated(list: PhanVung[] | null | undefined, idCha: number | undefined, listReturn: number[] | null | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/app/DMPhanVung/GetPhanVungFatherSeperated?";
        if (list !== undefined)
            list && list.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "list[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (idCha === null)
            throw new Error("The parameter 'idCha' cannot be null.");
        else if (idCha !== undefined)
            url_ += "idCha=" + encodeURIComponent("" + idCha) + "&";
        if (listReturn !== undefined)
            listReturn && listReturn.forEach(item => { url_ += "listReturn=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPhanVungFatherSeperated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPhanVungFatherSeperated(<any>response_);
                } catch (e) {
                    return <Observable<number[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<number[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPhanVungFatherSeperated(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(<any>null);
    }
}

@Injectable()
export class DMQuanLyCanhBaoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyWord (optional) 
     * @param trangThai (optional) 
     * @param tramId (optional) 
     * @param tuNgay (optional) 
     * @param denNgay (optional) 
     * @return Success
     */
    getAllDanhSachCanhBao(keyWord: string | null | undefined, trangThai: number | null | undefined, tramId: number | null | undefined, tuNgay: moment.Moment | null | undefined, denNgay: moment.Moment | null | undefined): Observable<DMCanhBaoOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/DMQuanLyCanhBao/GetAllDanhSachCanhBao?";
        if (keyWord !== undefined)
            url_ += "KeyWord=" + encodeURIComponent("" + keyWord) + "&";
        if (trangThai !== undefined)
            url_ += "TrangThai=" + encodeURIComponent("" + trangThai) + "&";
        if (tramId !== undefined)
            url_ += "TramId=" + encodeURIComponent("" + tramId) + "&";
        if (tuNgay !== undefined)
            url_ += "TuNgay=" + encodeURIComponent(tuNgay ? "" + tuNgay.toJSON() : "") + "&";
        if (denNgay !== undefined)
            url_ += "DenNgay=" + encodeURIComponent(denNgay ? "" + denNgay.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDanhSachCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDanhSachCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<DMCanhBaoOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DMCanhBaoOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDanhSachCanhBao(response: HttpResponseBase): Observable<DMCanhBaoOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DMCanhBaoOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DMCanhBaoOutput[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcelDanhSachCanhBao(body: DMCanhBaoInput | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/DMQuanLyCanhBao/ExportToExcelDanhSachCanhBao";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcelDanhSachCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcelDanhSachCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcelDanhSachCanhBao(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    xacNhanCanhBao(id: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMQuanLyCanhBao/XacNhanCanhBao?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXacNhanCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXacNhanCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processXacNhanCanhBao(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    clearCanhBao(id: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMQuanLyCanhBao/ClearCanhBao?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processClearCanhBao(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    guiMailSMSCanhBao(body: AlarmInfo | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DMQuanLyCanhBao/GuiMailSMSCanhBao";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGuiMailSMSCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGuiMailSMSCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGuiMailSMSCanhBao(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendMail(body: EmailToSendInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DMQuanLyCanhBao/SendMail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendMail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param idThietBi (optional) 
     * @param loaiCanhBao (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getLuatCanhBao(idThietBi: string | null | undefined, loaiCanhBao: string | null | undefined, isView: boolean | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DMQuanLyCanhBao/GetLuatCanhBao?";
        if (idThietBi !== undefined)
            url_ += "IdThietBi=" + encodeURIComponent("" + idThietBi) + "&";
        if (loaiCanhBao !== undefined)
            url_ += "LoaiCanhBao=" + encodeURIComponent("" + loaiCanhBao) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLuatCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLuatCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetLuatCanhBao(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeCanhBao(body: AlarmInfo | undefined): Observable<DMCanhBaoOutput> {
        let url_ = this.baseUrl + "/api/services/app/DMQuanLyCanhBao/ChangeCanhBao";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<DMCanhBaoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DMCanhBaoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processChangeCanhBao(response: HttpResponseBase): Observable<DMCanhBaoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DMCanhBaoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DMCanhBaoOutput>(<any>null);
    }

    /**
     * @return Success
     */
    downloadFileAndroid(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/DMQuanLyCanhBao/DownloadFileAndroid";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileAndroid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileAndroid(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileAndroid(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    postUpdateCanhBao(body: AlarmInfo | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DMQuanLyCanhBao/PostUpdateCanhBao";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostUpdateCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostUpdateCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPostUpdateCanhBao(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class DMThietBiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tbEntityTramId (optional) 
     * @param tramIdSS (optional) 
     * @return Success
     */
    getListFromThingsboard(tbEntityTramId: string | null | undefined, tramIdSS: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DMThietBi/GetListFromThingsboard?";
        if (tbEntityTramId !== undefined)
            url_ += "tbEntityTramId=" + encodeURIComponent("" + tbEntityTramId) + "&";
        if (tramIdSS === null)
            throw new Error("The parameter 'tramIdSS' cannot be null.");
        else if (tramIdSS !== undefined)
            url_ += "tramIdSS=" + encodeURIComponent("" + tramIdSS) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListFromThingsboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListFromThingsboard(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetListFromThingsboard(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tramIdSS (optional) 
     * @param body (optional) 
     * @return Success
     */
    createDeviceGetFromThingsboard(tramIdSS: number | undefined, body: DeviceSync | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DMThietBi/CreateDeviceGetFromThingsboard?";
        if (tramIdSS === null)
            throw new Error("The parameter 'tramIdSS' cannot be null.");
        else if (tramIdSS !== undefined)
            url_ += "tramIdSS=" + encodeURIComponent("" + tramIdSS) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDeviceGetFromThingsboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDeviceGetFromThingsboard(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDeviceGetFromThingsboard(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tramId (optional) 
     * @return Success
     */
    getCameraToList(tramId: number | undefined): Observable<GetListCamera[]> {
        let url_ = this.baseUrl + "/api/services/app/DMThietBi/GetCameraToList?";
        if (tramId === null)
            throw new Error("The parameter 'tramId' cannot be null.");
        else if (tramId !== undefined)
            url_ += "tramId=" + encodeURIComponent("" + tramId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCameraToList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCameraToList(<any>response_);
                } catch (e) {
                    return <Observable<GetListCamera[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetListCamera[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCameraToList(response: HttpResponseBase): Observable<GetListCamera[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(GetListCamera.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetListCamera[]>(<any>null);
    }

    /**
     * @return Success
     */
    getLuatCanhBao(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DMThietBi/GetLuatCanhBao";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLuatCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLuatCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLuatCanhBao(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllLoaiThietBi(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DMThietBi/GetAllLoaiThietBi";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLoaiThietBi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLoaiThietBi(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLoaiThietBi(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param loaiThietBiId (optional) 
     * @param tramId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, loaiThietBiId: number | null | undefined, tramId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ThietBiDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DMThietBi/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (loaiThietBiId !== undefined)
            url_ += "LoaiThietBiId=" + encodeURIComponent("" + loaiThietBiId) + "&";
        if (tramId !== undefined)
            url_ += "TramId=" + encodeURIComponent("" + tramId) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ThietBiDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ThietBiDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ThietBiDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThietBiDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThietBiDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: ThietBiDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DMThietBi/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DMThietBi/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined, isView: boolean | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DMThietBi/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class DMTramServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createAccountTramShinobi(body: Tram | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/CreateAccountTramShinobi";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAccountTramShinobi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAccountTramShinobi(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAccountTramShinobi(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param tramId (optional) 
     * @return Success
     */
    syncShinobi(tramId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/SyncShinobi?";
        if (tramId === null)
            throw new Error("The parameter 'tramId' cannot be null.");
        else if (tramId !== undefined)
            url_ += "tramId=" + encodeURIComponent("" + tramId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncShinobi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncShinobi(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSyncShinobi(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeValueTemplate(body: ChangValueTemplateDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/ChangeValueTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeValueTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeValueTemplate(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processChangeValueTemplate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getListMauThuocTinh(): Observable<MauThuocTinh[]> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/GetListMauThuocTinh";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListMauThuocTinh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListMauThuocTinh(<any>response_);
                } catch (e) {
                    return <Observable<MauThuocTinh[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MauThuocTinh[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListMauThuocTinh(response: HttpResponseBase): Observable<MauThuocTinh[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MauThuocTinh.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MauThuocTinh[]>(<any>null);
    }

    /**
     * @param tbEntityId (optional) 
     * @return Success
     */
    getTrangThaiTuThingsBoard(tbEntityId: string | null | undefined): Observable<TrangThaiTram> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/GetTrangThaiTuThingsBoard?";
        if (tbEntityId !== undefined)
            url_ += "tbEntityId=" + encodeURIComponent("" + tbEntityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrangThaiTuThingsBoard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrangThaiTuThingsBoard(<any>response_);
                } catch (e) {
                    return <Observable<TrangThaiTram>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrangThaiTram>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrangThaiTuThingsBoard(response: HttpResponseBase): Observable<TrangThaiTram> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrangThaiTram.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrangThaiTram>(<any>null);
    }

    /**
     * @param gatewayId (optional) 
     * @return Success
     */
    getTrangThaiTuKetNoi(gatewayId: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/GetTrangThaiTuKetNoi?";
        if (gatewayId !== undefined)
            url_ += "gatewayId=" + encodeURIComponent("" + gatewayId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrangThaiTuKetNoi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrangThaiTuKetNoi(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrangThaiTuKetNoi(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param keyWord (optional) 
     * @param phanVungId (optional) 
     * @param trangThaiKetNoiId (optional) 
     * @param trangThaiCanhBaoId (optional) 
     * @return Success
     */
    getAll(keyWord: string | null | undefined, phanVungId: number | null | undefined, trangThaiKetNoiId: number | null | undefined, trangThaiCanhBaoId: number | null | undefined): Observable<DanhSachTramView[]> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/GetAll?";
        if (keyWord !== undefined)
            url_ += "KeyWord=" + encodeURIComponent("" + keyWord) + "&";
        if (phanVungId !== undefined)
            url_ += "PhanVungId=" + encodeURIComponent("" + phanVungId) + "&";
        if (trangThaiKetNoiId !== undefined)
            url_ += "TrangThaiKetNoiId=" + encodeURIComponent("" + trangThaiKetNoiId) + "&";
        if (trangThaiCanhBaoId !== undefined)
            url_ += "TrangThaiCanhBaoId=" + encodeURIComponent("" + trangThaiCanhBaoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<DanhSachTramView[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DanhSachTramView[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DanhSachTramView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DanhSachTramView.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DanhSachTramView[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getForViewTram(id: number | undefined, isView: boolean | undefined): Observable<TramViewDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/GetForViewTram?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForViewTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForViewTram(<any>response_);
                } catch (e) {
                    return <Observable<TramViewDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TramViewDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForViewTram(response: HttpResponseBase): Observable<TramViewDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TramViewDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TramViewDetailDto>(<any>null);
    }

    /**
     * @param sitenumber (optional) 
     * @param xmax (optional) 
     * @param ymax (optional) 
     * @param xmin (optional) 
     * @param ymin (optional) 
     * @param userId (optional) 
     * @return Success
     */
    getAllDanhSachTram(sitenumber: number | null | undefined, xmax: number | null | undefined, ymax: number | null | undefined, xmin: number | null | undefined, ymin: number | null | undefined, userId: number | null | undefined): Observable<TramJsonDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/GetAllDanhSachTram?";
        if (sitenumber !== undefined)
            url_ += "Sitenumber=" + encodeURIComponent("" + sitenumber) + "&";
        if (xmax !== undefined)
            url_ += "Xmax=" + encodeURIComponent("" + xmax) + "&";
        if (ymax !== undefined)
            url_ += "Ymax=" + encodeURIComponent("" + ymax) + "&";
        if (xmin !== undefined)
            url_ += "Xmin=" + encodeURIComponent("" + xmin) + "&";
        if (ymin !== undefined)
            url_ += "Ymin=" + encodeURIComponent("" + ymin) + "&";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDanhSachTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDanhSachTram(<any>response_);
                } catch (e) {
                    return <Observable<TramJsonDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TramJsonDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDanhSachTram(response: HttpResponseBase): Observable<TramJsonDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TramJsonDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TramJsonDto[]>(<any>null);
    }

    /**
     * @param ten (optional) 
     * @param limit (optional) 
     * @param lat (optional) 
     * @param lon (optional) 
     * @param userId (optional) 
     * @return Success
     */
    getAllSuggestion(ten: string | null | undefined, limit: number | undefined, lat: number | null | undefined, lon: number | null | undefined, userId: number | null | undefined): Observable<SuggestionDto> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/GetAllSuggestion?";
        if (ten !== undefined)
            url_ += "Ten=" + encodeURIComponent("" + ten) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (lat !== undefined)
            url_ += "Lat=" + encodeURIComponent("" + lat) + "&";
        if (lon !== undefined)
            url_ += "Lon=" + encodeURIComponent("" + lon) + "&";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSuggestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSuggestion(<any>response_);
                } catch (e) {
                    return <Observable<SuggestionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SuggestionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSuggestion(response: HttpResponseBase): Observable<SuggestionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SuggestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SuggestionDto>(<any>null);
    }

    /**
     * @param ten (optional) 
     * @param limit (optional) 
     * @param lat (optional) 
     * @param lon (optional) 
     * @param userId (optional) 
     * @return Success
     */
    getAllSuggestionSearch(ten: string | null | undefined, limit: number | undefined, lat: number | null | undefined, lon: number | null | undefined, userId: number | null | undefined): Observable<SuggestionDto> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/GetAllSuggestionSearch?";
        if (ten !== undefined)
            url_ += "Ten=" + encodeURIComponent("" + ten) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (lat !== undefined)
            url_ += "Lat=" + encodeURIComponent("" + lat) + "&";
        if (lon !== undefined)
            url_ += "Lon=" + encodeURIComponent("" + lon) + "&";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSuggestionSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSuggestionSearch(<any>response_);
                } catch (e) {
                    return <Observable<SuggestionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SuggestionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSuggestionSearch(response: HttpResponseBase): Observable<SuggestionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SuggestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SuggestionDto>(<any>null);
    }

    /**
     * @param ten (optional) 
     * @param limit (optional) 
     * @param lat (optional) 
     * @param lon (optional) 
     * @param userId (optional) 
     * @return Success
     */
    getAllSuggestionLocation(ten: string | null | undefined, limit: number | undefined, lat: number | null | undefined, lon: number | null | undefined, userId: number | null | undefined): Observable<SuggestionDto> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/GetAllSuggestionLocation?";
        if (ten !== undefined)
            url_ += "Ten=" + encodeURIComponent("" + ten) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (lat !== undefined)
            url_ += "Lat=" + encodeURIComponent("" + lat) + "&";
        if (lon !== undefined)
            url_ += "Lon=" + encodeURIComponent("" + lon) + "&";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSuggestionLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSuggestionLocation(<any>response_);
                } catch (e) {
                    return <Observable<SuggestionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SuggestionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSuggestionLocation(response: HttpResponseBase): Observable<SuggestionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SuggestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SuggestionDto>(<any>null);
    }

    /**
     * @param ten (optional) 
     * @param limit (optional) 
     * @param lat (optional) 
     * @param lon (optional) 
     * @param userId (optional) 
     * @return Success
     */
    getAllSuggestionSearchLocation(ten: string | null | undefined, limit: number | undefined, lat: number | null | undefined, lon: number | null | undefined, userId: number | null | undefined): Observable<SuggestionDto> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/GetAllSuggestionSearchLocation?";
        if (ten !== undefined)
            url_ += "Ten=" + encodeURIComponent("" + ten) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (lat !== undefined)
            url_ += "Lat=" + encodeURIComponent("" + lat) + "&";
        if (lon !== undefined)
            url_ += "Lon=" + encodeURIComponent("" + lon) + "&";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSuggestionSearchLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSuggestionSearchLocation(<any>response_);
                } catch (e) {
                    return <Observable<SuggestionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SuggestionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSuggestionSearchLocation(response: HttpResponseBase): Observable<SuggestionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SuggestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SuggestionDto>(<any>null);
    }

    /**
     * @param tramId (optional) 
     * @return Success
     */
    getViewDanhSachTram(tramId: number | null | undefined): Observable<TramJsonDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/GetViewDanhSachTram?";
        if (tramId !== undefined)
            url_ += "tramId=" + encodeURIComponent("" + tramId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetViewDanhSachTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetViewDanhSachTram(<any>response_);
                } catch (e) {
                    return <Observable<TramJsonDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TramJsonDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetViewDanhSachTram(response: HttpResponseBase): Observable<TramJsonDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TramJsonDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TramJsonDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllPhanVungTree(id: number | null | undefined): Observable<TreeviewItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/GetAllPhanVungTree?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPhanVungTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPhanVungTree(<any>response_);
                } catch (e) {
                    return <Observable<TreeviewItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeviewItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPhanVungTree(response: HttpResponseBase): Observable<TreeviewItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TreeviewItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeviewItemDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditDanhMucTramDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined, isView: boolean | undefined): Observable<CreateOrEditDanhMucTramDto> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditDanhMucTramDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditDanhMucTramDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<CreateOrEditDanhMucTramDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditDanhMucTramDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditDanhMucTramDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    xoaListTram(body: DanhSachTramView[] | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/XoaListTram";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXoaListTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXoaListTram(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processXoaListTram(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param tramId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllThuocTinhDieuKhien(tramId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TramDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/GetAllThuocTinhDieuKhien?";
        if (tramId === null)
            throw new Error("The parameter 'tramId' cannot be null.");
        else if (tramId !== undefined)
            url_ += "TramId=" + encodeURIComponent("" + tramId) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllThuocTinhDieuKhien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllThuocTinhDieuKhien(<any>response_);
                } catch (e) {
                    return <Observable<TramDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TramDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllThuocTinhDieuKhien(response: HttpResponseBase): Observable<TramDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TramDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TramDtoPagedResultDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllThuocTinhDieuKhienNhieuTram(input: ThuocTinhDieuKhienTramInput[] | null | undefined): Observable<TramDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/GetAllThuocTinhDieuKhienNhieuTram?";
        if (input !== undefined)
            input && input.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "input[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllThuocTinhDieuKhienNhieuTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllThuocTinhDieuKhienNhieuTram(<any>response_);
                } catch (e) {
                    return <Observable<TramDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TramDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllThuocTinhDieuKhienNhieuTram(response: HttpResponseBase): Observable<TramDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TramDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TramDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcelTramDieuKhienThuocTinh(body: ThuocTinhDieuKhienTramInput | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/ExportToExcelTramDieuKhienThuocTinh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcelTramDieuKhienThuocTinh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcelTramDieuKhienThuocTinh(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcelTramDieuKhienThuocTinh(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMauDieuKhienCanhBaoIdTram(body: CreateOrEditDanhMucTramDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/CreateMauDieuKhienCanhBaoIdTram";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMauDieuKhienCanhBaoIdTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMauDieuKhienCanhBaoIdTram(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMauDieuKhienCanhBaoIdTram(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMauDieuKhienTram(body: CreateOrEditDanhMucTramDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/CreateMauDieuKhienTram";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMauDieuKhienTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMauDieuKhienTram(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMauDieuKhienTram(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMauDieuKhienTram1(body: CreateOrEditDanhMucTramDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/CreateMauDieuKhienTram1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMauDieuKhienTram1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMauDieuKhienTram1(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMauDieuKhienTram1(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param idRecord (optional) 
     * @param sorted (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateMauDieuKhienTram(idRecord: number | undefined, sorted: string | null | undefined, body: CreateOrEditDanhMucTramDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/UpdateMauDieuKhienTram?";
        if (idRecord === null)
            throw new Error("The parameter 'idRecord' cannot be null.");
        else if (idRecord !== undefined)
            url_ += "idRecord=" + encodeURIComponent("" + idRecord) + "&";
        if (sorted !== undefined)
            url_ += "sorted=" + encodeURIComponent("" + sorted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMauDieuKhienTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMauDieuKhienTram(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMauDieuKhienTram(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    xoaMauDieuKhienTram(body: TramDieuKhienThuocTinh | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/XoaMauDieuKhienTram";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXoaMauDieuKhienTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXoaMauDieuKhienTram(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processXoaMauDieuKhienTram(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    xoaListMauDieuKhienTram(body: TramDieuKhienThuocTinh[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/XoaListMauDieuKhienTram";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXoaListMauDieuKhienTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXoaListMauDieuKhienTram(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processXoaListMauDieuKhienTram(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param tramId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllThuocTinhDieuKhienFake(tramId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ThuocTinhDieuKhienTramPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/GetAllThuocTinhDieuKhienFake?";
        if (tramId === null)
            throw new Error("The parameter 'tramId' cannot be null.");
        else if (tramId !== undefined)
            url_ += "TramId=" + encodeURIComponent("" + tramId) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllThuocTinhDieuKhienFake(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllThuocTinhDieuKhienFake(<any>response_);
                } catch (e) {
                    return <Observable<ThuocTinhDieuKhienTramPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ThuocTinhDieuKhienTramPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllThuocTinhDieuKhienFake(response: HttpResponseBase): Observable<ThuocTinhDieuKhienTramPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThuocTinhDieuKhienTramPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThuocTinhDieuKhienTramPagedResultDto>(<any>null);
    }

    /**
     * @param tramId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllThuocTinhCanhBaoFake(tramId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ThuocTinhCanhBaoTramPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/GetAllThuocTinhCanhBaoFake?";
        if (tramId === null)
            throw new Error("The parameter 'tramId' cannot be null.");
        else if (tramId !== undefined)
            url_ += "TramId=" + encodeURIComponent("" + tramId) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllThuocTinhCanhBaoFake(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllThuocTinhCanhBaoFake(<any>response_);
                } catch (e) {
                    return <Observable<ThuocTinhCanhBaoTramPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ThuocTinhCanhBaoTramPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllThuocTinhCanhBaoFake(response: HttpResponseBase): Observable<ThuocTinhCanhBaoTramPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThuocTinhCanhBaoTramPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThuocTinhCanhBaoTramPagedResultDto>(<any>null);
    }

    /**
     * @param tramId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllThuocTinhCanhBao(tramId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TramDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/GetAllThuocTinhCanhBao?";
        if (tramId === null)
            throw new Error("The parameter 'tramId' cannot be null.");
        else if (tramId !== undefined)
            url_ += "TramId=" + encodeURIComponent("" + tramId) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllThuocTinhCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllThuocTinhCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<TramDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TramDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllThuocTinhCanhBao(response: HttpResponseBase): Observable<TramDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TramDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TramDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMauCanhBaoTram(body: CreateOrEditDanhMucTramDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/CreateMauCanhBaoTram";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMauCanhBaoTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMauCanhBaoTram(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMauCanhBaoTram(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param idRecord (optional) 
     * @param sorted (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateMauCanhBaoTram(idRecord: number | undefined, sorted: string | null | undefined, body: CreateOrEditDanhMucTramDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/UpdateMauCanhBaoTram?";
        if (idRecord === null)
            throw new Error("The parameter 'idRecord' cannot be null.");
        else if (idRecord !== undefined)
            url_ += "idRecord=" + encodeURIComponent("" + idRecord) + "&";
        if (sorted !== undefined)
            url_ += "sorted=" + encodeURIComponent("" + sorted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMauCanhBaoTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMauCanhBaoTram(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMauCanhBaoTram(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    xoaMauCanhBaoTram(body: TramCanhBaoThuocTinh | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/XoaMauCanhBaoTram";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXoaMauCanhBaoTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXoaMauCanhBaoTram(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processXoaMauCanhBaoTram(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    xoaListMauCanhBaoTram(body: TramCanhBaoThuocTinh[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/XoaListMauCanhBaoTram";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXoaListMauCanhBaoTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXoaListMauCanhBaoTram(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processXoaListMauCanhBaoTram(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveListCauHinhTram(body: CreateOrEditDanhMucTramDto[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/SaveListCauHinhTram";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveListCauHinhTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveListCauHinhTram(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSaveListCauHinhTram(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param keyWord (optional) 
     * @param trangThai (optional) 
     * @param tramId (optional) 
     * @param tuNgay (optional) 
     * @param denNgay (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllDanhSachCanhBao(keyWord: string | null | undefined, trangThai: number | null | undefined, tramId: number | undefined, tuNgay: moment.Moment | null | undefined, denNgay: moment.Moment | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<DanhSachCanhBaoOutputPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/GetAllDanhSachCanhBao?";
        if (keyWord !== undefined)
            url_ += "KeyWord=" + encodeURIComponent("" + keyWord) + "&";
        if (trangThai !== undefined)
            url_ += "TrangThai=" + encodeURIComponent("" + trangThai) + "&";
        if (tramId === null)
            throw new Error("The parameter 'tramId' cannot be null.");
        else if (tramId !== undefined)
            url_ += "TramId=" + encodeURIComponent("" + tramId) + "&";
        if (tuNgay !== undefined)
            url_ += "TuNgay=" + encodeURIComponent(tuNgay ? "" + tuNgay.toJSON() : "") + "&";
        if (denNgay !== undefined)
            url_ += "DenNgay=" + encodeURIComponent(denNgay ? "" + denNgay.toJSON() : "") + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDanhSachCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDanhSachCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<DanhSachCanhBaoOutputPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DanhSachCanhBaoOutputPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDanhSachCanhBao(response: HttpResponseBase): Observable<DanhSachCanhBaoOutputPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DanhSachCanhBaoOutputPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DanhSachCanhBaoOutputPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    xacNhanCanhBao(id: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/XacNhanCanhBao?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXacNhanCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXacNhanCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processXacNhanCanhBao(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    clearCanhBao(id: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/ClearCanhBao?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processClearCanhBao(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param tuNgay (optional) 
     * @param denNgay (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllQuetThe(keyword: string | null | undefined, tuNgay: moment.Moment | null | undefined, denNgay: moment.Moment | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<QuetTheOutputPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/GetAllQuetThe?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (tuNgay !== undefined)
            url_ += "TuNgay=" + encodeURIComponent(tuNgay ? "" + tuNgay.toJSON() : "") + "&";
        if (denNgay !== undefined)
            url_ += "DenNgay=" + encodeURIComponent(denNgay ? "" + denNgay.toJSON() : "") + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllQuetThe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllQuetThe(<any>response_);
                } catch (e) {
                    return <Observable<QuetTheOutputPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuetTheOutputPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllQuetThe(response: HttpResponseBase): Observable<QuetTheOutputPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuetTheOutputPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuetTheOutputPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    logQuetThe(body: QuetTheDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/LogQuetThe";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogQuetThe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogQuetThe(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLogQuetThe(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filePath (optional) 
     * @return Success
     */
    importFileExcel(filePath: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/ImportFileExcel?";
        if (filePath !== undefined)
            url_ += "FilePath=" + encodeURIComponent("" + filePath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportFileExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportFileExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processImportFileExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    downloadFileMau(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/DMTram/DownloadFileMau";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileMau(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileMau(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileMau(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class DuLieuCamBienServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    syncDuLieuCamBien(body: SyncDuLieuCamBienInputDto | undefined): Observable<SyncDuLieuCamBienOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/DuLieuCamBien/SyncDuLieuCamBien";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncDuLieuCamBien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncDuLieuCamBien(<any>response_);
                } catch (e) {
                    return <Observable<SyncDuLieuCamBienOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SyncDuLieuCamBienOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processSyncDuLieuCamBien(response: HttpResponseBase): Observable<SyncDuLieuCamBienOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SyncDuLieuCamBienOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SyncDuLieuCamBienOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    syncDuLieuCamBienViewCanhBao(body: SyncDuLieuCamBienInputDto | undefined): Observable<DuLieuCamBienOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DuLieuCamBien/SyncDuLieuCamBienViewCanhBao";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncDuLieuCamBienViewCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncDuLieuCamBienViewCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<DuLieuCamBienOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DuLieuCamBienOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processSyncDuLieuCamBienViewCanhBao(response: HttpResponseBase): Observable<DuLieuCamBienOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DuLieuCamBienOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DuLieuCamBienOutputDto[]>(<any>null);
    }

    /**
     * @param deviceId (optional) 
     * @return Success
     */
    getListKeysTelemetry(deviceId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DuLieuCamBien/GetListKeysTelemetry?";
        if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListKeysTelemetry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListKeysTelemetry(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetListKeysTelemetry(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param key (optional) 
     * @return Success
     */
    getKeyCamBien(key: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DuLieuCamBien/GetKeyCamBien?";
        if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKeyCamBien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKeyCamBien(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetKeyCamBien(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param tramId (optional) 
     * @return Success
     */
    getListDuLieuCBForSelectBox(tramId: number | undefined): Observable<LookupTableDLCBDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DuLieuCamBien/GetListDuLieuCBForSelectBox?";
        if (tramId === null)
            throw new Error("The parameter 'tramId' cannot be null.");
        else if (tramId !== undefined)
            url_ += "tramId=" + encodeURIComponent("" + tramId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListDuLieuCBForSelectBox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListDuLieuCBForSelectBox(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDLCBDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDLCBDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListDuLieuCBForSelectBox(response: HttpResponseBase): Observable<LookupTableDLCBDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDLCBDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDLCBDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(body: SyncDuLieuCamBienInputDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/DuLieuCamBien/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class GiamSatCamBienServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDanhSachCamBienTheoTram(id: number | undefined): Observable<DanhSachCamBienOutput> {
        let url_ = this.baseUrl + "/api/services/app/GiamSatCamBien/GetDanhSachCamBienTheoTram?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDanhSachCamBienTheoTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDanhSachCamBienTheoTram(<any>response_);
                } catch (e) {
                    return <Observable<DanhSachCamBienOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DanhSachCamBienOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDanhSachCamBienTheoTram(response: HttpResponseBase): Observable<DanhSachCamBienOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DanhSachCamBienOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DanhSachCamBienOutput>(<any>null);
    }

    /**
     * @param hhhh (optional) 
     * @param key (optional) 
     * @return Success
     */
    testGetTelemetry(hhhh: string | null | undefined, key: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/GiamSatCamBien/TestGetTelemetry?";
        if (hhhh !== undefined)
            url_ += "hhhh=" + encodeURIComponent("" + hhhh) + "&";
        if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestGetTelemetry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestGetTelemetry(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processTestGetTelemetry(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class ImportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    congViec(): Observable<string> {
        let url_ = this.baseUrl + "/api/Import/CongViec";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCongViec(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCongViec(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCongViec(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class LocationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    post(body: AlarmInfo | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Location/Post";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    get(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Location/Get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class LookupTableServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllStringLookupTable(): Observable<StringLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllStringLookupTable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStringLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStringLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<StringLookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringLookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllStringLookupTable(response: HttpResponseBase): Observable<StringLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(StringLookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringLookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllLongLookupTable(): Observable<Int64LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllLongLookupTable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLongLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLongLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<Int64LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLongLookupTable(response: HttpResponseBase): Observable<Int64LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Int64LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTrangThaiHieuLuc(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllTrangThaiHieuLuc";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTrangThaiHieuLuc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTrangThaiHieuLuc(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTrangThaiHieuLuc(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTrangThaiDuyet(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllTrangThaiDuyet";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTrangThaiDuyet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTrangThaiDuyet(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTrangThaiDuyet(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllKieuDuLieu(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllKieuDuLieu";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKieuDuLieu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKieuDuLieu(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllKieuDuLieu(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllDemo(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllDemo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDemo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDemo(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDemo(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllPhanVungTree(id: number | null | undefined): Observable<TreeviewItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllPhanVungTree?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPhanVungTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPhanVungTree(<any>response_);
                } catch (e) {
                    return <Observable<TreeviewItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeviewItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPhanVungTree(response: HttpResponseBase): Observable<TreeviewItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TreeviewItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeviewItemDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPhanVungCheckBox(): Observable<FlatTreeSelectDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllPhanVungCheckBox";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPhanVungCheckBox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPhanVungCheckBox(<any>response_);
                } catch (e) {
                    return <Observable<FlatTreeSelectDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FlatTreeSelectDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPhanVungCheckBox(response: HttpResponseBase): Observable<FlatTreeSelectDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FlatTreeSelectDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlatTreeSelectDto[]>(<any>null);
    }

    /**
     * @param phanVungChaId (optional) 
     * @param body (optional) 
     * @return Success
     */
    findRootAsset(phanVungChaId: number | undefined, body: PhanVung[] | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/FindRootAsset?";
        if (phanVungChaId === null)
            throw new Error("The parameter 'phanVungChaId' cannot be null.");
        else if (phanVungChaId !== undefined)
            url_ += "phanVungChaId=" + encodeURIComponent("" + phanVungChaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindRootAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindRootAsset(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processFindRootAsset(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTramForLookupTable(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllTramForLookupTable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTramForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTramForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTramForLookupTable(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllLoaiCanhBao(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllLoaiCanhBao";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLoaiCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLoaiCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLoaiCanhBao(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllMucDoCanhBao(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllMucDoCanhBao";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMucDoCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMucDoCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMucDoCanhBao(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTrangThaiCanhBao(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllTrangThaiCanhBao";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTrangThaiCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTrangThaiCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTrangThaiCanhBao(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCurrentCpuUsage(): Observable<ShowRamCpu> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetCurrentCpuUsage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentCpuUsage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentCpuUsage(<any>response_);
                } catch (e) {
                    return <Observable<ShowRamCpu>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShowRamCpu>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentCpuUsage(response: HttpResponseBase): Observable<ShowRamCpu> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShowRamCpu.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShowRamCpu>(<any>null);
    }
}

@Injectable()
export class MobileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tramId (optional) 
     * @return Success
     */
    giamSatTram(tramId: number | undefined): Observable<GiamSatTramMobileDto> {
        let url_ = this.baseUrl + "/api/services/app/Mobile/GiamSatTram?";
        if (tramId === null)
            throw new Error("The parameter 'tramId' cannot be null.");
        else if (tramId !== undefined)
            url_ += "tramId=" + encodeURIComponent("" + tramId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGiamSatTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGiamSatTram(<any>response_);
                } catch (e) {
                    return <Observable<GiamSatTramMobileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GiamSatTramMobileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGiamSatTram(response: HttpResponseBase): Observable<GiamSatTramMobileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GiamSatTramMobileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GiamSatTramMobileDto>(<any>null);
    }
}

@Injectable()
export class NhatKyLamViecServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    loginNhatKy(body: NhanVienRaVaoLogin | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/NhatKyLamViec/LoginNhatKy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginNhatKy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginNhatKy(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processLoginNhatKy(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassWord(body: ChangePassDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/NhatKyLamViec/ChangePassWord";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassWord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassWord(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassWord(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPassworDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/NhatKyLamViec/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getNhanVienTramById(id: number | undefined): Observable<NhanVienRaVaoTram> {
        let url_ = this.baseUrl + "/api/services/app/NhatKyLamViec/GetNhanVienTramById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNhanVienTramById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNhanVienTramById(<any>response_);
                } catch (e) {
                    return <Observable<NhanVienRaVaoTram>><any>_observableThrow(e);
                }
            } else
                return <Observable<NhanVienRaVaoTram>><any>_observableThrow(response_);
        }));
    }

    protected processGetNhanVienTramById(response: HttpResponseBase): Observable<NhanVienRaVaoTram> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhanVienRaVaoTram.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhanVienRaVaoTram>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateNV(body: NhanVienRaVaoTramDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/NhatKyLamViec/UpdateNV";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNV(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNV(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNV(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param nhatKyId (optional) 
     * @return Success
     */
    getAllGhiChu(nhatKyId: number | undefined): Observable<NhatKyGhiChu[]> {
        let url_ = this.baseUrl + "/api/services/app/NhatKyLamViec/GetAllGhiChu?";
        if (nhatKyId === null)
            throw new Error("The parameter 'nhatKyId' cannot be null.");
        else if (nhatKyId !== undefined)
            url_ += "NhatKyId=" + encodeURIComponent("" + nhatKyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGhiChu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGhiChu(<any>response_);
                } catch (e) {
                    return <Observable<NhatKyGhiChu[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NhatKyGhiChu[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllGhiChu(response: HttpResponseBase): Observable<NhatKyGhiChu[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(NhatKyGhiChu.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhatKyGhiChu[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getGhiChuById(id: number | undefined): Observable<NhatKyGhiChu> {
        let url_ = this.baseUrl + "/api/services/app/NhatKyLamViec/GetGhiChuById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGhiChuById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGhiChuById(<any>response_);
                } catch (e) {
                    return <Observable<NhatKyGhiChu>><any>_observableThrow(e);
                }
            } else
                return <Observable<NhatKyGhiChu>><any>_observableThrow(response_);
        }));
    }

    protected processGetGhiChuById(response: HttpResponseBase): Observable<NhatKyGhiChu> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhatKyGhiChu.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhatKyGhiChu>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditGhiChu(body: NhatKyGhiChuCreateDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/NhatKyLamViec/CreateOrEditGhiChu";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditGhiChu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditGhiChu(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEditGhiChu(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteGhiChu(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/NhatKyLamViec/DeleteGhiChu?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGhiChu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGhiChu(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteGhiChu(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param loaiCongViec (optional) 
     * @param donVi (optional) 
     * @param tramId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, loaiCongViec: string | null | undefined, donVi: string | null | undefined, tramId: number | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<NhatKyLamViecPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/NhatKyLamViec/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (loaiCongViec !== undefined)
            url_ += "LoaiCongViec=" + encodeURIComponent("" + loaiCongViec) + "&";
        if (donVi !== undefined)
            url_ += "DonVi=" + encodeURIComponent("" + donVi) + "&";
        if (tramId === null)
            throw new Error("The parameter 'tramId' cannot be null.");
        else if (tramId !== undefined)
            url_ += "TramId=" + encodeURIComponent("" + tramId) + "&";
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<NhatKyLamViecPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NhatKyLamViecPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<NhatKyLamViecPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhatKyLamViecPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhatKyLamViecPagedResultDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param nhanVienId (optional) 
     * @param tramId (optional) 
     * @param phanVungId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @return Success
     */
    getAllTram(keyword: string | null | undefined, nhanVienId: number | undefined, tramId: number | null | undefined, phanVungId: number | null | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined): Observable<NhatKyLamViec[]> {
        let url_ = this.baseUrl + "/api/services/app/NhatKyLamViec/GetAllTram?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (nhanVienId === null)
            throw new Error("The parameter 'nhanVienId' cannot be null.");
        else if (nhanVienId !== undefined)
            url_ += "NhanVienId=" + encodeURIComponent("" + nhanVienId) + "&";
        if (tramId !== undefined)
            url_ += "TramId=" + encodeURIComponent("" + tramId) + "&";
        if (phanVungId !== undefined)
            url_ += "PhanVungId=" + encodeURIComponent("" + phanVungId) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTram(<any>response_);
                } catch (e) {
                    return <Observable<NhatKyLamViec[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NhatKyLamViec[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTram(response: HttpResponseBase): Observable<NhatKyLamViec[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(NhatKyLamViec.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhatKyLamViec[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: NhatKyLamViecCreateInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/NhatKyLamViec/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/NhatKyLamViec/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<NhatKyLamViec> {
        let url_ = this.baseUrl + "/api/services/app/NhatKyLamViec/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<NhatKyLamViec>><any>_observableThrow(e);
                }
            } else
                return <Observable<NhatKyLamViec>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<NhatKyLamViec> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhatKyLamViec.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhatKyLamViec>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param linkAnh (optional) 
     * @return Success
     */
    doiAnhDaiDien(id: number | undefined, linkAnh: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/NhatKyLamViec/DoiAnhDaiDien?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (linkAnh !== undefined)
            url_ += "linkAnh=" + encodeURIComponent("" + linkAnh) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDoiAnhDaiDien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDoiAnhDaiDien(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDoiAnhDaiDien(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<FlatPermissionWithLevelDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<FlatPermissionWithLevelDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FlatPermissionWithLevelDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<FlatPermissionWithLevelDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FlatPermissionWithLevelDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlatPermissionWithLevelDtoListResultDto>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRoles(permission: string | null | undefined): Observable<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleListDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleListDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleListDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleListDtoListResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param roleName (optional) 
     * @param displayRoleName (optional) 
     * @param id (optional) 
     * @return Success
     */
    checkExist(roleName: string | null | undefined, displayRoleName: string | null | undefined, id: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Role/CheckExist?";
        if (roleName !== undefined)
            url_ += "roleName=" + encodeURIComponent("" + roleName) + "&";
        if (displayRoleName !== undefined)
            url_ += "displayRoleName=" + encodeURIComponent("" + displayRoleName) + "&";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckExist(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCheckExist(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<FlatPermissionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<FlatPermissionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FlatPermissionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<FlatPermissionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FlatPermissionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlatPermissionDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdits(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdits?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdits(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdits(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @return Success
     */
    checkRoles(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Role/CheckRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckRoles(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processCheckRoles(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param roles (optional) 
     * @return Success
     */
    selectRoles(roles: number | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/app/Role/SelectRoles?";
        if (roles === null)
            throw new Error("The parameter 'roles' cannot be null.");
        else if (roles !== undefined)
            url_ += "roles=" + encodeURIComponent("" + roles) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectRoles(<any>response_);
                } catch (e) {
                    return <Observable<number[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<number[]>><any>_observableThrow(response_);
        }));
    }

    protected processSelectRoles(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<TenantDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TenantDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }

    /**
     * @param getwayId (optional) 
     * @return Success
     */
    getIpMCC(getwayId: string | null | undefined): Observable<GetwayIPDto> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetIpMCC?";
        if (getwayId !== undefined)
            url_ += "getwayId=" + encodeURIComponent("" + getwayId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIpMCC(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIpMCC(<any>response_);
                } catch (e) {
                    return <Observable<GetwayIPDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetwayIPDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetIpMCC(response: HttpResponseBase): Observable<GetwayIPDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetwayIPDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetwayIPDto>(<any>null);
    }
}

@Injectable()
export class TramDieuKhienServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param idTram (optional) 
     * @return Success
     */
    getDanhSachDieuKhienTheoTram(idTram: number | undefined): Observable<DanhSachThietBiDieuKhienTheoNhom> {
        let url_ = this.baseUrl + "/api/services/app/TramDieuKhien/GetDanhSachDieuKhienTheoTram?";
        if (idTram === null)
            throw new Error("The parameter 'idTram' cannot be null.");
        else if (idTram !== undefined)
            url_ += "idTram=" + encodeURIComponent("" + idTram) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDanhSachDieuKhienTheoTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDanhSachDieuKhienTheoTram(<any>response_);
                } catch (e) {
                    return <Observable<DanhSachThietBiDieuKhienTheoNhom>><any>_observableThrow(e);
                }
            } else
                return <Observable<DanhSachThietBiDieuKhienTheoNhom>><any>_observableThrow(response_);
        }));
    }

    protected processGetDanhSachDieuKhienTheoTram(response: HttpResponseBase): Observable<DanhSachThietBiDieuKhienTheoNhom> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DanhSachThietBiDieuKhienTheoNhom.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DanhSachThietBiDieuKhienTheoNhom>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    batTatThietBi(body: InputDieuKhienThietBi | undefined): Observable<ListNhomThietBi[]> {
        let url_ = this.baseUrl + "/api/services/app/TramDieuKhien/BatTatThietBi";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatTatThietBi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatTatThietBi(<any>response_);
                } catch (e) {
                    return <Observable<ListNhomThietBi[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListNhomThietBi[]>><any>_observableThrow(response_);
        }));
    }

    protected processBatTatThietBi(response: HttpResponseBase): Observable<ListNhomThietBi[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ListNhomThietBi.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListNhomThietBi[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    dieuKhienQuatHoacDieuHoa(body: ThietBiDieuKhienDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/TramDieuKhien/DieuKhienQuatHoacDieuHoa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDieuKhienQuatHoacDieuHoa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDieuKhienQuatHoacDieuHoa(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processDieuKhienQuatHoacDieuHoa(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    dieuKhienCheDoDieuHoa(body: ThietBiDieuKhienDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/TramDieuKhien/DieuKhienCheDoDieuHoa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDieuKhienCheDoDieuHoa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDieuKhienCheDoDieuHoa(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processDieuKhienCheDoDieuHoa(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    chonCheDo(body: ThietBiDieuKhienDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/TramDieuKhien/ChonCheDo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChonCheDo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChonCheDo(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processChonCheDo(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class UploadServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    demoUpload(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Upload/DemoUpload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDemoUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDemoUpload(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processDemoUpload(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    avatarUpload(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Upload/AvatarUpload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAvatarUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAvatarUpload(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processAvatarUpload(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    logMccUpload(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Upload/LogMccUpload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogMccUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogMccUpload(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processLogMccUpload(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param userName (optional) 
     * @param emailAddress (optional) 
     * @param id (optional) 
     * @return Success
     */
    checkExist(userName: string | null | undefined, emailAddress: string | null | undefined, id: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/User/CheckExist?";
        if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (emailAddress !== undefined)
            url_ += "emailAddress=" + encodeURIComponent("" + emailAddress) + "&";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckExist(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCheckExist(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<UserDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<RoleDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoListResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param token (optional) 
     * @param passwword (optional) 
     * @return Success
     */
    sendPasswordResetCode(token: string | null | undefined, passwword: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/SendPasswordResetCode?";
        if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        if (passwword !== undefined)
            url_ += "passwword=" + encodeURIComponent("" + passwword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param token (optional) 
     * @return Success
     */
    checkToken(token: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/CheckToken?";
        if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckToken(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckToken(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param emailAddress (optional) 
     * @return Success
     */
    checkEmailAndCreateToken(emailAddress: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/User/CheckEmailAndCreateToken?";
        if (emailAddress !== undefined)
            url_ += "emailAddress=" + encodeURIComponent("" + emailAddress) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckEmailAndCreateToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckEmailAndCreateToken(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCheckEmailAndCreateToken(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined, isView: boolean | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @return Success
     */
    getFlatTree(): Observable<FlatTreeSelectDto[]> {
        let url_ = this.baseUrl + "/api/services/app/User/getFlatTree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFlatTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFlatTree(<any>response_);
                } catch (e) {
                    return <Observable<FlatTreeSelectDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FlatTreeSelectDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFlatTree(response: HttpResponseBase): Observable<FlatTreeSelectDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FlatTreeSelectDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlatTreeSelectDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    checkUser(): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/app/User/CheckUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckUser(<any>response_);
                } catch (e) {
                    return <Observable<number[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<number[]>><any>_observableThrow(response_);
        }));
    }

    protected processCheckUser(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(<any>null);
    }

    /**
     * @param roles (optional) 
     * @return Success
     */
    selectRoles(roles: number | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/app/User/SelectRoles?";
        if (roles === null)
            throw new Error("The parameter 'roles' cannot be null.");
        else if (roles !== undefined)
            url_ += "roles=" + encodeURIComponent("" + roles) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectRoles(<any>response_);
                } catch (e) {
                    return <Observable<number[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<number[]>><any>_observableThrow(response_);
        }));
    }

    protected processSelectRoles(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    postLogOut(body: LogOutInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/User/PostLogOut";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostLogOut(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPostLogOut(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export enum TenantAvailabilityState {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class AuditLogListDto implements IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    serviceNameForView: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment;
    executionDuration: number;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.impersonatorTenantId = _data["impersonatorTenantId"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.serviceName = _data["serviceName"];
            this.serviceNameForView = _data["serviceNameForView"];
            this.methodName = _data["methodName"];
            this.parameters = _data["parameters"];
            this.executionTime = _data["executionTime"] ? moment(_data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = _data["executionDuration"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.exception = _data["exception"];
            this.customData = _data["customData"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["serviceNameForView"] = this.serviceNameForView;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data; 
    }

    clone(): AuditLogListDto {
        const json = this.toJSON();
        let result = new AuditLogListDto();
        result.init(json);
        return result;
    }
}

export interface IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    serviceNameForView: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment;
    executionDuration: number;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number;
}

export class AuditLogListDtoPagedResultDto implements IAuditLogListDtoPagedResultDto {
    totalCount: number;
    items: AuditLogListDto[] | undefined;

    constructor(data?: IAuditLogListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuditLogListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AuditLogListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AuditLogListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAuditLogListDtoPagedResultDto {
    totalCount: number;
    items: AuditLogListDto[] | undefined;
}

export class GetAuditLogsInput implements IGetAuditLogsInput {
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    userName: string | undefined;
    serviceName: string | undefined;
    isSearch: boolean | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IGetAuditLogsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.userName = _data["userName"];
            this.serviceName = _data["serviceName"];
            this.isSearch = _data["isSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): GetAuditLogsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAuditLogsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["userName"] = this.userName;
        data["serviceName"] = this.serviceName;
        data["isSearch"] = this.isSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): GetAuditLogsInput {
        const json = this.toJSON();
        let result = new GetAuditLogsInput();
        result.init(json);
        return result;
    }
}

export interface IGetAuditLogsInput {
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    userName: string | undefined;
    serviceName: string | undefined;
    isSearch: boolean | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class FileDto implements IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fileToken = _data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }

    clone(): FileDto {
        const json = this.toJSON();
        let result = new FileDto();
        result.init(json);
        return result;
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;
}

export class StringLookupTableDto implements IStringLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;

    constructor(data?: IStringLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StringLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StringLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): StringLookupTableDto {
        const json = this.toJSON();
        let result = new StringLookupTableDto();
        result.init(json);
        return result;
    }
}

export interface IStringLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class CanhBaoList implements ICanhBaoList {
    loaiCanhBao: string | undefined;
    soLuong: number;
    thoiGianTB: number;

    constructor(data?: ICanhBaoList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loaiCanhBao = _data["loaiCanhBao"];
            this.soLuong = _data["soLuong"];
            this.thoiGianTB = _data["thoiGianTB"];
        }
    }

    static fromJS(data: any): CanhBaoList {
        data = typeof data === 'object' ? data : {};
        let result = new CanhBaoList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loaiCanhBao"] = this.loaiCanhBao;
        data["soLuong"] = this.soLuong;
        data["thoiGianTB"] = this.thoiGianTB;
        return data; 
    }

    clone(): CanhBaoList {
        const json = this.toJSON();
        let result = new CanhBaoList();
        result.init(json);
        return result;
    }
}

export interface ICanhBaoList {
    loaiCanhBao: string | undefined;
    soLuong: number;
    thoiGianTB: number;
}

export class GiaTriDto implements IGiaTriDto {
    activeUn: number;
    activeAck: number;
    clearUn: number;
    clearAck: number;
    tong: number;

    constructor(data?: IGiaTriDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activeUn = _data["activeUn"];
            this.activeAck = _data["activeAck"];
            this.clearUn = _data["clearUn"];
            this.clearAck = _data["clearAck"];
            this.tong = _data["tong"];
        }
    }

    static fromJS(data: any): GiaTriDto {
        data = typeof data === 'object' ? data : {};
        let result = new GiaTriDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activeUn"] = this.activeUn;
        data["activeAck"] = this.activeAck;
        data["clearUn"] = this.clearUn;
        data["clearAck"] = this.clearAck;
        data["tong"] = this.tong;
        return data; 
    }

    clone(): GiaTriDto {
        const json = this.toJSON();
        let result = new GiaTriDto();
        result.init(json);
        return result;
    }
}

export interface IGiaTriDto {
    activeUn: number;
    activeAck: number;
    clearUn: number;
    clearAck: number;
    tong: number;
}

export class BieuDoCanhBao implements IBieuDoCanhBao {
    name: string | undefined;
    value: number;

    constructor(data?: IBieuDoCanhBao) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): BieuDoCanhBao {
        data = typeof data === 'object' ? data : {};
        let result = new BieuDoCanhBao();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }

    clone(): BieuDoCanhBao {
        const json = this.toJSON();
        let result = new BieuDoCanhBao();
        result.init(json);
        return result;
    }
}

export interface IBieuDoCanhBao {
    name: string | undefined;
    value: number;
}

export class CanhBaoCacTramOutput implements ICanhBaoCacTramOutput {
    ten: string | undefined;
    idThietBi: string | undefined;
    canhBaoList: CanhBaoList[] | undefined;
    data: GiaTriDto;
    bieuDo: BieuDoCanhBao[] | undefined;

    constructor(data?: ICanhBaoCacTramOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.idThietBi = _data["idThietBi"];
            if (Array.isArray(_data["canhBaoList"])) {
                this.canhBaoList = [] as any;
                for (let item of _data["canhBaoList"])
                    this.canhBaoList.push(CanhBaoList.fromJS(item));
            }
            this.data = _data["data"] ? GiaTriDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["bieuDo"])) {
                this.bieuDo = [] as any;
                for (let item of _data["bieuDo"])
                    this.bieuDo.push(BieuDoCanhBao.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CanhBaoCacTramOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CanhBaoCacTramOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["idThietBi"] = this.idThietBi;
        if (Array.isArray(this.canhBaoList)) {
            data["canhBaoList"] = [];
            for (let item of this.canhBaoList)
                data["canhBaoList"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.bieuDo)) {
            data["bieuDo"] = [];
            for (let item of this.bieuDo)
                data["bieuDo"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CanhBaoCacTramOutput {
        const json = this.toJSON();
        let result = new CanhBaoCacTramOutput();
        result.init(json);
        return result;
    }
}

export interface ICanhBaoCacTramOutput {
    ten: string | undefined;
    idThietBi: string | undefined;
    canhBaoList: CanhBaoList[] | undefined;
    data: GiaTriDto;
    bieuDo: BieuDoCanhBao[] | undefined;
}

export class KetQuaGuiTinNhanInput implements IKetQuaGuiTinNhanInput {
    tramId: number;
    tuNgay: moment.Moment | undefined;
    denNgay: moment.Moment | undefined;
    loaiCanhBao: string | undefined;

    constructor(data?: IKetQuaGuiTinNhanInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tramId = _data["tramId"];
            this.tuNgay = _data["tuNgay"] ? moment(_data["tuNgay"].toString()) : <any>undefined;
            this.denNgay = _data["denNgay"] ? moment(_data["denNgay"].toString()) : <any>undefined;
            this.loaiCanhBao = _data["loaiCanhBao"];
        }
    }

    static fromJS(data: any): KetQuaGuiTinNhanInput {
        data = typeof data === 'object' ? data : {};
        let result = new KetQuaGuiTinNhanInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tramId"] = this.tramId;
        data["tuNgay"] = this.tuNgay ? this.tuNgay.toISOString() : <any>undefined;
        data["denNgay"] = this.denNgay ? this.denNgay.toISOString() : <any>undefined;
        data["loaiCanhBao"] = this.loaiCanhBao;
        return data; 
    }

    clone(): KetQuaGuiTinNhanInput {
        const json = this.toJSON();
        let result = new KetQuaGuiTinNhanInput();
        result.init(json);
        return result;
    }
}

export interface IKetQuaGuiTinNhanInput {
    tramId: number;
    tuNgay: moment.Moment | undefined;
    denNgay: moment.Moment | undefined;
    loaiCanhBao: string | undefined;
}

export class CamBienVaGiaTriDto implements ICamBienVaGiaTriDto {
    tenDuLieu: string | undefined;
    giaTri: string | undefined;

    constructor(data?: ICamBienVaGiaTriDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenDuLieu = _data["tenDuLieu"];
            this.giaTri = _data["giaTri"];
        }
    }

    static fromJS(data: any): CamBienVaGiaTriDto {
        data = typeof data === 'object' ? data : {};
        let result = new CamBienVaGiaTriDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenDuLieu"] = this.tenDuLieu;
        data["giaTri"] = this.giaTri;
        return data; 
    }

    clone(): CamBienVaGiaTriDto {
        const json = this.toJSON();
        let result = new CamBienVaGiaTriDto();
        result.init(json);
        return result;
    }
}

export interface ICamBienVaGiaTriDto {
    tenDuLieu: string | undefined;
    giaTri: string | undefined;
}

export class BaoCaoChiTietCanhBaoDto implements IBaoCaoChiTietCanhBaoDto {
    thoiGian: string | undefined;
    tenCanhBao: string | undefined;
    trangThaiCanhBao: string | undefined;
    trangThaiGui: string | undefined;
    tenCot: string[] | undefined;
    duLieu: CamBienVaGiaTriDto[] | undefined;

    constructor(data?: IBaoCaoChiTietCanhBaoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thoiGian = _data["thoiGian"];
            this.tenCanhBao = _data["tenCanhBao"];
            this.trangThaiCanhBao = _data["trangThaiCanhBao"];
            this.trangThaiGui = _data["trangThaiGui"];
            if (Array.isArray(_data["tenCot"])) {
                this.tenCot = [] as any;
                for (let item of _data["tenCot"])
                    this.tenCot.push(item);
            }
            if (Array.isArray(_data["duLieu"])) {
                this.duLieu = [] as any;
                for (let item of _data["duLieu"])
                    this.duLieu.push(CamBienVaGiaTriDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BaoCaoChiTietCanhBaoDto {
        data = typeof data === 'object' ? data : {};
        let result = new BaoCaoChiTietCanhBaoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thoiGian"] = this.thoiGian;
        data["tenCanhBao"] = this.tenCanhBao;
        data["trangThaiCanhBao"] = this.trangThaiCanhBao;
        data["trangThaiGui"] = this.trangThaiGui;
        if (Array.isArray(this.tenCot)) {
            data["tenCot"] = [];
            for (let item of this.tenCot)
                data["tenCot"].push(item);
        }
        if (Array.isArray(this.duLieu)) {
            data["duLieu"] = [];
            for (let item of this.duLieu)
                data["duLieu"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BaoCaoChiTietCanhBaoDto {
        const json = this.toJSON();
        let result = new BaoCaoChiTietCanhBaoDto();
        result.init(json);
        return result;
    }
}

export interface IBaoCaoChiTietCanhBaoDto {
    thoiGian: string | undefined;
    tenCanhBao: string | undefined;
    trangThaiCanhBao: string | undefined;
    trangThaiGui: string | undefined;
    tenCot: string[] | undefined;
    duLieu: CamBienVaGiaTriDto[] | undefined;
}

export class BaoCaoChiTietCanhBaoDtoPagedResultDto implements IBaoCaoChiTietCanhBaoDtoPagedResultDto {
    totalCount: number;
    items: BaoCaoChiTietCanhBaoDto[] | undefined;

    constructor(data?: IBaoCaoChiTietCanhBaoDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(BaoCaoChiTietCanhBaoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BaoCaoChiTietCanhBaoDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BaoCaoChiTietCanhBaoDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BaoCaoChiTietCanhBaoDtoPagedResultDto {
        const json = this.toJSON();
        let result = new BaoCaoChiTietCanhBaoDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBaoCaoChiTietCanhBaoDtoPagedResultDto {
    totalCount: number;
    items: BaoCaoChiTietCanhBaoDto[] | undefined;
}

export class BaoCaoChiTietCanhBaoInput implements IBaoCaoChiTietCanhBaoInput {
    tenTram: string | undefined;
    loaiCanhBao: string | undefined;
    tenMucDo: string | undefined;
    tuNgay: moment.Moment;
    denNgay: moment.Moment;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IBaoCaoChiTietCanhBaoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenTram = _data["tenTram"];
            this.loaiCanhBao = _data["loaiCanhBao"];
            this.tenMucDo = _data["tenMucDo"];
            this.tuNgay = _data["tuNgay"] ? moment(_data["tuNgay"].toString()) : <any>undefined;
            this.denNgay = _data["denNgay"] ? moment(_data["denNgay"].toString()) : <any>undefined;
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): BaoCaoChiTietCanhBaoInput {
        data = typeof data === 'object' ? data : {};
        let result = new BaoCaoChiTietCanhBaoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenTram"] = this.tenTram;
        data["loaiCanhBao"] = this.loaiCanhBao;
        data["tenMucDo"] = this.tenMucDo;
        data["tuNgay"] = this.tuNgay ? this.tuNgay.toISOString() : <any>undefined;
        data["denNgay"] = this.denNgay ? this.denNgay.toISOString() : <any>undefined;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): BaoCaoChiTietCanhBaoInput {
        const json = this.toJSON();
        let result = new BaoCaoChiTietCanhBaoInput();
        result.init(json);
        return result;
    }
}

export interface IBaoCaoChiTietCanhBaoInput {
    tenTram: string | undefined;
    loaiCanhBao: string | undefined;
    tenMucDo: string | undefined;
    tuNgay: moment.Moment;
    denNgay: moment.Moment;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class BaoCaoTramDto implements IBaoCaoTramDto {
    maTram: string | undefined;
    tenTram: string | undefined;
    phanVung: string | undefined;
    diaChi: string | undefined;
    ngayTao: string | undefined;

    constructor(data?: IBaoCaoTramDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maTram = _data["maTram"];
            this.tenTram = _data["tenTram"];
            this.phanVung = _data["phanVung"];
            this.diaChi = _data["diaChi"];
            this.ngayTao = _data["ngayTao"];
        }
    }

    static fromJS(data: any): BaoCaoTramDto {
        data = typeof data === 'object' ? data : {};
        let result = new BaoCaoTramDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maTram"] = this.maTram;
        data["tenTram"] = this.tenTram;
        data["phanVung"] = this.phanVung;
        data["diaChi"] = this.diaChi;
        data["ngayTao"] = this.ngayTao;
        return data; 
    }

    clone(): BaoCaoTramDto {
        const json = this.toJSON();
        let result = new BaoCaoTramDto();
        result.init(json);
        return result;
    }
}

export interface IBaoCaoTramDto {
    maTram: string | undefined;
    tenTram: string | undefined;
    phanVung: string | undefined;
    diaChi: string | undefined;
    ngayTao: string | undefined;
}

export class BaoCaoTramDtoPagedResultDto implements IBaoCaoTramDtoPagedResultDto {
    totalCount: number;
    items: BaoCaoTramDto[] | undefined;

    constructor(data?: IBaoCaoTramDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(BaoCaoTramDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BaoCaoTramDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BaoCaoTramDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BaoCaoTramDtoPagedResultDto {
        const json = this.toJSON();
        let result = new BaoCaoTramDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBaoCaoTramDtoPagedResultDto {
    totalCount: number;
    items: BaoCaoTramDto[] | undefined;
}

export class BaoCaoDanhSachTramInput implements IBaoCaoDanhSachTramInput {
    phanVungId: number | undefined;
    tuNgay: moment.Moment | undefined;
    denNgay: moment.Moment | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IBaoCaoDanhSachTramInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phanVungId = _data["phanVungId"];
            this.tuNgay = _data["tuNgay"] ? moment(_data["tuNgay"].toString()) : <any>undefined;
            this.denNgay = _data["denNgay"] ? moment(_data["denNgay"].toString()) : <any>undefined;
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): BaoCaoDanhSachTramInput {
        data = typeof data === 'object' ? data : {};
        let result = new BaoCaoDanhSachTramInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phanVungId"] = this.phanVungId;
        data["tuNgay"] = this.tuNgay ? this.tuNgay.toISOString() : <any>undefined;
        data["denNgay"] = this.denNgay ? this.denNgay.toISOString() : <any>undefined;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): BaoCaoDanhSachTramInput {
        const json = this.toJSON();
        let result = new BaoCaoDanhSachTramInput();
        result.init(json);
        return result;
    }
}

export interface IBaoCaoDanhSachTramInput {
    phanVungId: number | undefined;
    tuNgay: moment.Moment | undefined;
    denNgay: moment.Moment | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class BieuDoSMS implements IBieuDoSMS {
    name: string | undefined;
    value: number;

    constructor(data?: IBieuDoSMS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): BieuDoSMS {
        data = typeof data === 'object' ? data : {};
        let result = new BieuDoSMS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }

    clone(): BieuDoSMS {
        const json = this.toJSON();
        let result = new BieuDoSMS();
        result.init(json);
        return result;
    }
}

export interface IBieuDoSMS {
    name: string | undefined;
    value: number;
}

export class DemDto implements IDemDto {
    ngay: moment.Moment;
    thanhCong: number;

    constructor(data?: IDemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ngay = _data["ngay"] ? moment(_data["ngay"].toString()) : <any>undefined;
            this.thanhCong = _data["thanhCong"];
        }
    }

    static fromJS(data: any): DemDto {
        data = typeof data === 'object' ? data : {};
        let result = new DemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ngay"] = this.ngay ? this.ngay.toISOString() : <any>undefined;
        data["thanhCong"] = this.thanhCong;
        return data; 
    }

    clone(): DemDto {
        const json = this.toJSON();
        let result = new DemDto();
        result.init(json);
        return result;
    }
}

export interface IDemDto {
    ngay: moment.Moment;
    thanhCong: number;
}

export class KetQuaGuiTinNhanOutput implements IKetQuaGuiTinNhanOutput {
    ngay: string[] | undefined;
    ten: string | undefined;
    bieuDo: BieuDoSMS[] | undefined;
    data: DemDto[] | undefined;

    constructor(data?: IKetQuaGuiTinNhanOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ngay"])) {
                this.ngay = [] as any;
                for (let item of _data["ngay"])
                    this.ngay.push(item);
            }
            this.ten = _data["ten"];
            if (Array.isArray(_data["bieuDo"])) {
                this.bieuDo = [] as any;
                for (let item of _data["bieuDo"])
                    this.bieuDo.push(BieuDoSMS.fromJS(item));
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(DemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): KetQuaGuiTinNhanOutput {
        data = typeof data === 'object' ? data : {};
        let result = new KetQuaGuiTinNhanOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ngay)) {
            data["ngay"] = [];
            for (let item of this.ngay)
                data["ngay"].push(item);
        }
        data["ten"] = this.ten;
        if (Array.isArray(this.bieuDo)) {
            data["bieuDo"] = [];
            for (let item of this.bieuDo)
                data["bieuDo"].push(item.toJSON());
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }

    clone(): KetQuaGuiTinNhanOutput {
        const json = this.toJSON();
        let result = new KetQuaGuiTinNhanOutput();
        result.init(json);
        return result;
    }
}

export interface IKetQuaGuiTinNhanOutput {
    ngay: string[] | undefined;
    ten: string | undefined;
    bieuDo: BieuDoSMS[] | undefined;
    data: DemDto[] | undefined;
}

export class LookupTableDto implements ILookupTableDto {
    id: number;
    displayName: string | undefined;

    constructor(data?: ILookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): LookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): LookupTableDto {
        const json = this.toJSON();
        let result = new LookupTableDto();
        result.init(json);
        return result;
    }
}

export interface ILookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class DataChartDto implements IDataChartDto {
    label: string | undefined;
    data: number[] | undefined;
    fill: boolean;
    backgroundColor: string | undefined;

    constructor(data?: IDataChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(item);
            }
            this.fill = _data["fill"];
            this.backgroundColor = _data["backgroundColor"];
        }
    }

    static fromJS(data: any): DataChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        data["fill"] = this.fill;
        data["backgroundColor"] = this.backgroundColor;
        return data; 
    }

    clone(): DataChartDto {
        const json = this.toJSON();
        let result = new DataChartDto();
        result.init(json);
        return result;
    }
}

export interface IDataChartDto {
    label: string | undefined;
    data: number[] | undefined;
    fill: boolean;
    backgroundColor: string | undefined;
}

export class BaoCaoLogHeThongChartDto implements IBaoCaoLogHeThongChartDto {
    labels: string[] | undefined;
    datasets: DataChartDto[] | undefined;

    constructor(data?: IBaoCaoLogHeThongChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels.push(item);
            }
            if (Array.isArray(_data["datasets"])) {
                this.datasets = [] as any;
                for (let item of _data["datasets"])
                    this.datasets.push(DataChartDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BaoCaoLogHeThongChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new BaoCaoLogHeThongChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        if (Array.isArray(this.datasets)) {
            data["datasets"] = [];
            for (let item of this.datasets)
                data["datasets"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BaoCaoLogHeThongChartDto {
        const json = this.toJSON();
        let result = new BaoCaoLogHeThongChartDto();
        result.init(json);
        return result;
    }
}

export interface IBaoCaoLogHeThongChartDto {
    labels: string[] | undefined;
    datasets: DataChartDto[] | undefined;
}

export class BaoCaoLogHeThongTableDto implements IBaoCaoLogHeThongTableDto {
    thoiGian: string | undefined;
    tenNguoiDung: string | undefined;
    chucNang: string | undefined;
    thaoTac: string | undefined;
    trinhDuyet: string | undefined;
    parameters: string | undefined;
    thoiGianSapXep: moment.Moment;

    constructor(data?: IBaoCaoLogHeThongTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thoiGian = _data["thoiGian"];
            this.tenNguoiDung = _data["tenNguoiDung"];
            this.chucNang = _data["chucNang"];
            this.thaoTac = _data["thaoTac"];
            this.trinhDuyet = _data["trinhDuyet"];
            this.parameters = _data["parameters"];
            this.thoiGianSapXep = _data["thoiGianSapXep"] ? moment(_data["thoiGianSapXep"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BaoCaoLogHeThongTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BaoCaoLogHeThongTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thoiGian"] = this.thoiGian;
        data["tenNguoiDung"] = this.tenNguoiDung;
        data["chucNang"] = this.chucNang;
        data["thaoTac"] = this.thaoTac;
        data["trinhDuyet"] = this.trinhDuyet;
        data["parameters"] = this.parameters;
        data["thoiGianSapXep"] = this.thoiGianSapXep ? this.thoiGianSapXep.toISOString() : <any>undefined;
        return data; 
    }

    clone(): BaoCaoLogHeThongTableDto {
        const json = this.toJSON();
        let result = new BaoCaoLogHeThongTableDto();
        result.init(json);
        return result;
    }
}

export interface IBaoCaoLogHeThongTableDto {
    thoiGian: string | undefined;
    tenNguoiDung: string | undefined;
    chucNang: string | undefined;
    thaoTac: string | undefined;
    trinhDuyet: string | undefined;
    parameters: string | undefined;
    thoiGianSapXep: moment.Moment;
}

export class BaoCaoLogHeThongTableDtoPagedResultDto implements IBaoCaoLogHeThongTableDtoPagedResultDto {
    totalCount: number;
    items: BaoCaoLogHeThongTableDto[] | undefined;

    constructor(data?: IBaoCaoLogHeThongTableDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(BaoCaoLogHeThongTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BaoCaoLogHeThongTableDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BaoCaoLogHeThongTableDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BaoCaoLogHeThongTableDtoPagedResultDto {
        const json = this.toJSON();
        let result = new BaoCaoLogHeThongTableDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBaoCaoLogHeThongTableDtoPagedResultDto {
    totalCount: number;
    items: BaoCaoLogHeThongTableDto[] | undefined;
}

export class BaoCaoLogHeThongInput implements IBaoCaoLogHeThongInput {
    nguoiDung: number;
    tuNgay: moment.Moment;
    denNgay: moment.Moment;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IBaoCaoLogHeThongInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nguoiDung = _data["nguoiDung"];
            this.tuNgay = _data["tuNgay"] ? moment(_data["tuNgay"].toString()) : <any>undefined;
            this.denNgay = _data["denNgay"] ? moment(_data["denNgay"].toString()) : <any>undefined;
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): BaoCaoLogHeThongInput {
        data = typeof data === 'object' ? data : {};
        let result = new BaoCaoLogHeThongInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nguoiDung"] = this.nguoiDung;
        data["tuNgay"] = this.tuNgay ? this.tuNgay.toISOString() : <any>undefined;
        data["denNgay"] = this.denNgay ? this.denNgay.toISOString() : <any>undefined;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): BaoCaoLogHeThongInput {
        const json = this.toJSON();
        let result = new BaoCaoLogHeThongInput();
        result.init(json);
        return result;
    }
}

export interface IBaoCaoLogHeThongInput {
    nguoiDung: number;
    tuNgay: moment.Moment;
    denNgay: moment.Moment;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class DataNhienLieuMayNoChartDto implements IDataNhienLieuMayNoChartDto {
    label: string | undefined;
    data: number[] | undefined;
    fill: boolean;
    backgroundColor: string | undefined;

    constructor(data?: IDataNhienLieuMayNoChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(item);
            }
            this.fill = _data["fill"];
            this.backgroundColor = _data["backgroundColor"];
        }
    }

    static fromJS(data: any): DataNhienLieuMayNoChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataNhienLieuMayNoChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        data["fill"] = this.fill;
        data["backgroundColor"] = this.backgroundColor;
        return data; 
    }

    clone(): DataNhienLieuMayNoChartDto {
        const json = this.toJSON();
        let result = new DataNhienLieuMayNoChartDto();
        result.init(json);
        return result;
    }
}

export interface IDataNhienLieuMayNoChartDto {
    label: string | undefined;
    data: number[] | undefined;
    fill: boolean;
    backgroundColor: string | undefined;
}

export class BaoCaoNhienLieuMayNoChartDto implements IBaoCaoNhienLieuMayNoChartDto {
    labels: string[] | undefined;
    datasets: DataNhienLieuMayNoChartDto[] | undefined;

    constructor(data?: IBaoCaoNhienLieuMayNoChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels.push(item);
            }
            if (Array.isArray(_data["datasets"])) {
                this.datasets = [] as any;
                for (let item of _data["datasets"])
                    this.datasets.push(DataNhienLieuMayNoChartDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BaoCaoNhienLieuMayNoChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new BaoCaoNhienLieuMayNoChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        if (Array.isArray(this.datasets)) {
            data["datasets"] = [];
            for (let item of this.datasets)
                data["datasets"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BaoCaoNhienLieuMayNoChartDto {
        const json = this.toJSON();
        let result = new BaoCaoNhienLieuMayNoChartDto();
        result.init(json);
        return result;
    }
}

export interface IBaoCaoNhienLieuMayNoChartDto {
    labels: string[] | undefined;
    datasets: DataNhienLieuMayNoChartDto[] | undefined;
}

export class BaoCaoNhienLieuMayNoTableDto implements IBaoCaoNhienLieuMayNoTableDto {
    tenMayNo: string | undefined;
    nhienLieu: number[] | undefined;

    constructor(data?: IBaoCaoNhienLieuMayNoTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenMayNo = _data["tenMayNo"];
            if (Array.isArray(_data["nhienLieu"])) {
                this.nhienLieu = [] as any;
                for (let item of _data["nhienLieu"])
                    this.nhienLieu.push(item);
            }
        }
    }

    static fromJS(data: any): BaoCaoNhienLieuMayNoTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BaoCaoNhienLieuMayNoTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenMayNo"] = this.tenMayNo;
        if (Array.isArray(this.nhienLieu)) {
            data["nhienLieu"] = [];
            for (let item of this.nhienLieu)
                data["nhienLieu"].push(item);
        }
        return data; 
    }

    clone(): BaoCaoNhienLieuMayNoTableDto {
        const json = this.toJSON();
        let result = new BaoCaoNhienLieuMayNoTableDto();
        result.init(json);
        return result;
    }
}

export interface IBaoCaoNhienLieuMayNoTableDto {
    tenMayNo: string | undefined;
    nhienLieu: number[] | undefined;
}

export class BaoCaoNhienLieuMayNoTableDtoPagedResultDto implements IBaoCaoNhienLieuMayNoTableDtoPagedResultDto {
    totalCount: number;
    items: BaoCaoNhienLieuMayNoTableDto[] | undefined;

    constructor(data?: IBaoCaoNhienLieuMayNoTableDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(BaoCaoNhienLieuMayNoTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BaoCaoNhienLieuMayNoTableDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BaoCaoNhienLieuMayNoTableDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BaoCaoNhienLieuMayNoTableDtoPagedResultDto {
        const json = this.toJSON();
        let result = new BaoCaoNhienLieuMayNoTableDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBaoCaoNhienLieuMayNoTableDtoPagedResultDto {
    totalCount: number;
    items: BaoCaoNhienLieuMayNoTableDto[] | undefined;
}

export class BaoCaoNhienLieuMayNoTableInput implements IBaoCaoNhienLieuMayNoTableInput {
    tramId: number;
    tuNgay: moment.Moment;
    denNgay: moment.Moment;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IBaoCaoNhienLieuMayNoTableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tramId = _data["tramId"];
            this.tuNgay = _data["tuNgay"] ? moment(_data["tuNgay"].toString()) : <any>undefined;
            this.denNgay = _data["denNgay"] ? moment(_data["denNgay"].toString()) : <any>undefined;
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): BaoCaoNhienLieuMayNoTableInput {
        data = typeof data === 'object' ? data : {};
        let result = new BaoCaoNhienLieuMayNoTableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tramId"] = this.tramId;
        data["tuNgay"] = this.tuNgay ? this.tuNgay.toISOString() : <any>undefined;
        data["denNgay"] = this.denNgay ? this.denNgay.toISOString() : <any>undefined;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): BaoCaoNhienLieuMayNoTableInput {
        const json = this.toJSON();
        let result = new BaoCaoNhienLieuMayNoTableInput();
        result.init(json);
        return result;
    }
}

export interface IBaoCaoNhienLieuMayNoTableInput {
    tramId: number;
    tuNgay: moment.Moment;
    denNgay: moment.Moment;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class DataInDay implements IDataInDay {
    listValue: number[] | undefined;
    date: string | undefined;

    constructor(data?: IDataInDay) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listValue"])) {
                this.listValue = [] as any;
                for (let item of _data["listValue"])
                    this.listValue.push(item);
            }
            this.date = _data["date"];
        }
    }

    static fromJS(data: any): DataInDay {
        data = typeof data === 'object' ? data : {};
        let result = new DataInDay();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listValue)) {
            data["listValue"] = [];
            for (let item of this.listValue)
                data["listValue"].push(item);
        }
        data["date"] = this.date;
        return data; 
    }

    clone(): DataInDay {
        const json = this.toJSON();
        let result = new DataInDay();
        result.init(json);
        return result;
    }
}

export interface IDataInDay {
    listValue: number[] | undefined;
    date: string | undefined;
}

export class BaoCaoTTTramOutput implements IBaoCaoTTTramOutput {
    listDay: string[] | undefined;
    listValueNhietDoPhongThietBi: number[] | undefined;
    listValueNhietDoNgoaiTram: number[] | undefined;
    listValueNhietDoBinhAccu: number[] | undefined;
    listValueDoAm: number[] | undefined;
    listValueMucNuoc: number[] | undefined;
    listValueDiaChan: number[] | undefined;
    listValueMoMit: number[] | undefined;
    listValueDienAp1: number[] | undefined;
    listValueDienAp2: number[] | undefined;
    listValueDienAp3: number[] | undefined;
    listDataTable: DataInDay[] | undefined;

    constructor(data?: IBaoCaoTTTramOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listDay"])) {
                this.listDay = [] as any;
                for (let item of _data["listDay"])
                    this.listDay.push(item);
            }
            if (Array.isArray(_data["listValueNhietDoPhongThietBi"])) {
                this.listValueNhietDoPhongThietBi = [] as any;
                for (let item of _data["listValueNhietDoPhongThietBi"])
                    this.listValueNhietDoPhongThietBi.push(item);
            }
            if (Array.isArray(_data["listValueNhietDoNgoaiTram"])) {
                this.listValueNhietDoNgoaiTram = [] as any;
                for (let item of _data["listValueNhietDoNgoaiTram"])
                    this.listValueNhietDoNgoaiTram.push(item);
            }
            if (Array.isArray(_data["listValueNhietDoBinhAccu"])) {
                this.listValueNhietDoBinhAccu = [] as any;
                for (let item of _data["listValueNhietDoBinhAccu"])
                    this.listValueNhietDoBinhAccu.push(item);
            }
            if (Array.isArray(_data["listValueDoAm"])) {
                this.listValueDoAm = [] as any;
                for (let item of _data["listValueDoAm"])
                    this.listValueDoAm.push(item);
            }
            if (Array.isArray(_data["listValueMucNuoc"])) {
                this.listValueMucNuoc = [] as any;
                for (let item of _data["listValueMucNuoc"])
                    this.listValueMucNuoc.push(item);
            }
            if (Array.isArray(_data["listValueDiaChan"])) {
                this.listValueDiaChan = [] as any;
                for (let item of _data["listValueDiaChan"])
                    this.listValueDiaChan.push(item);
            }
            if (Array.isArray(_data["listValueMoMit"])) {
                this.listValueMoMit = [] as any;
                for (let item of _data["listValueMoMit"])
                    this.listValueMoMit.push(item);
            }
            if (Array.isArray(_data["listValueDienAp1"])) {
                this.listValueDienAp1 = [] as any;
                for (let item of _data["listValueDienAp1"])
                    this.listValueDienAp1.push(item);
            }
            if (Array.isArray(_data["listValueDienAp2"])) {
                this.listValueDienAp2 = [] as any;
                for (let item of _data["listValueDienAp2"])
                    this.listValueDienAp2.push(item);
            }
            if (Array.isArray(_data["listValueDienAp3"])) {
                this.listValueDienAp3 = [] as any;
                for (let item of _data["listValueDienAp3"])
                    this.listValueDienAp3.push(item);
            }
            if (Array.isArray(_data["listDataTable"])) {
                this.listDataTable = [] as any;
                for (let item of _data["listDataTable"])
                    this.listDataTable.push(DataInDay.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BaoCaoTTTramOutput {
        data = typeof data === 'object' ? data : {};
        let result = new BaoCaoTTTramOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listDay)) {
            data["listDay"] = [];
            for (let item of this.listDay)
                data["listDay"].push(item);
        }
        if (Array.isArray(this.listValueNhietDoPhongThietBi)) {
            data["listValueNhietDoPhongThietBi"] = [];
            for (let item of this.listValueNhietDoPhongThietBi)
                data["listValueNhietDoPhongThietBi"].push(item);
        }
        if (Array.isArray(this.listValueNhietDoNgoaiTram)) {
            data["listValueNhietDoNgoaiTram"] = [];
            for (let item of this.listValueNhietDoNgoaiTram)
                data["listValueNhietDoNgoaiTram"].push(item);
        }
        if (Array.isArray(this.listValueNhietDoBinhAccu)) {
            data["listValueNhietDoBinhAccu"] = [];
            for (let item of this.listValueNhietDoBinhAccu)
                data["listValueNhietDoBinhAccu"].push(item);
        }
        if (Array.isArray(this.listValueDoAm)) {
            data["listValueDoAm"] = [];
            for (let item of this.listValueDoAm)
                data["listValueDoAm"].push(item);
        }
        if (Array.isArray(this.listValueMucNuoc)) {
            data["listValueMucNuoc"] = [];
            for (let item of this.listValueMucNuoc)
                data["listValueMucNuoc"].push(item);
        }
        if (Array.isArray(this.listValueDiaChan)) {
            data["listValueDiaChan"] = [];
            for (let item of this.listValueDiaChan)
                data["listValueDiaChan"].push(item);
        }
        if (Array.isArray(this.listValueMoMit)) {
            data["listValueMoMit"] = [];
            for (let item of this.listValueMoMit)
                data["listValueMoMit"].push(item);
        }
        if (Array.isArray(this.listValueDienAp1)) {
            data["listValueDienAp1"] = [];
            for (let item of this.listValueDienAp1)
                data["listValueDienAp1"].push(item);
        }
        if (Array.isArray(this.listValueDienAp2)) {
            data["listValueDienAp2"] = [];
            for (let item of this.listValueDienAp2)
                data["listValueDienAp2"].push(item);
        }
        if (Array.isArray(this.listValueDienAp3)) {
            data["listValueDienAp3"] = [];
            for (let item of this.listValueDienAp3)
                data["listValueDienAp3"].push(item);
        }
        if (Array.isArray(this.listDataTable)) {
            data["listDataTable"] = [];
            for (let item of this.listDataTable)
                data["listDataTable"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BaoCaoTTTramOutput {
        const json = this.toJSON();
        let result = new BaoCaoTTTramOutput();
        result.init(json);
        return result;
    }
}

export interface IBaoCaoTTTramOutput {
    listDay: string[] | undefined;
    listValueNhietDoPhongThietBi: number[] | undefined;
    listValueNhietDoNgoaiTram: number[] | undefined;
    listValueNhietDoBinhAccu: number[] | undefined;
    listValueDoAm: number[] | undefined;
    listValueMucNuoc: number[] | undefined;
    listValueDiaChan: number[] | undefined;
    listValueMoMit: number[] | undefined;
    listValueDienAp1: number[] | undefined;
    listValueDienAp2: number[] | undefined;
    listValueDienAp3: number[] | undefined;
    listDataTable: DataInDay[] | undefined;
}

export class ListTram implements IListTram {
    tenTram: string | undefined;
    tramId: number;

    constructor(data?: IListTram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenTram = _data["tenTram"];
            this.tramId = _data["tramId"];
        }
    }

    static fromJS(data: any): ListTram {
        data = typeof data === 'object' ? data : {};
        let result = new ListTram();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenTram"] = this.tenTram;
        data["tramId"] = this.tramId;
        return data; 
    }

    clone(): ListTram {
        const json = this.toJSON();
        let result = new ListTram();
        result.init(json);
        return result;
    }
}

export interface IListTram {
    tenTram: string | undefined;
    tramId: number;
}

export class GetAllBaoCaoThongTinTramInput implements IGetAllBaoCaoThongTinTramInput {
    tramId: number;
    tuNgay: moment.Moment;
    denNgay: moment.Moment;

    constructor(data?: IGetAllBaoCaoThongTinTramInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tramId = _data["tramId"];
            this.tuNgay = _data["tuNgay"] ? moment(_data["tuNgay"].toString()) : <any>undefined;
            this.denNgay = _data["denNgay"] ? moment(_data["denNgay"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllBaoCaoThongTinTramInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllBaoCaoThongTinTramInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tramId"] = this.tramId;
        data["tuNgay"] = this.tuNgay ? this.tuNgay.toISOString() : <any>undefined;
        data["denNgay"] = this.denNgay ? this.denNgay.toISOString() : <any>undefined;
        return data; 
    }

    clone(): GetAllBaoCaoThongTinTramInput {
        const json = this.toJSON();
        let result = new GetAllBaoCaoThongTinTramInput();
        result.init(json);
        return result;
    }
}

export interface IGetAllBaoCaoThongTinTramInput {
    tramId: number;
    tuNgay: moment.Moment;
    denNgay: moment.Moment;
}

export class DataTableTrangThaiKetNoiInDay implements IDataTableTrangThaiKetNoiInDay {
    tenTram: string | undefined;
    tramId: number;
    dataInDay: string[] | undefined;

    constructor(data?: IDataTableTrangThaiKetNoiInDay) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenTram = _data["tenTram"];
            this.tramId = _data["tramId"];
            if (Array.isArray(_data["dataInDay"])) {
                this.dataInDay = [] as any;
                for (let item of _data["dataInDay"])
                    this.dataInDay.push(item);
            }
        }
    }

    static fromJS(data: any): DataTableTrangThaiKetNoiInDay {
        data = typeof data === 'object' ? data : {};
        let result = new DataTableTrangThaiKetNoiInDay();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenTram"] = this.tenTram;
        data["tramId"] = this.tramId;
        if (Array.isArray(this.dataInDay)) {
            data["dataInDay"] = [];
            for (let item of this.dataInDay)
                data["dataInDay"].push(item);
        }
        return data; 
    }

    clone(): DataTableTrangThaiKetNoiInDay {
        const json = this.toJSON();
        let result = new DataTableTrangThaiKetNoiInDay();
        result.init(json);
        return result;
    }
}

export interface IDataTableTrangThaiKetNoiInDay {
    tenTram: string | undefined;
    tramId: number;
    dataInDay: string[] | undefined;
}

export class BaoCaoTrangThaiKetNoiOutput implements IBaoCaoTrangThaiKetNoiOutput {
    listDay: string[] | undefined;
    listNormal: number[] | undefined;
    listAlert: number[] | undefined;
    listDisconnect: number[] | undefined;
    listData: DataTableTrangThaiKetNoiInDay[] | undefined;

    constructor(data?: IBaoCaoTrangThaiKetNoiOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listDay"])) {
                this.listDay = [] as any;
                for (let item of _data["listDay"])
                    this.listDay.push(item);
            }
            if (Array.isArray(_data["listNormal"])) {
                this.listNormal = [] as any;
                for (let item of _data["listNormal"])
                    this.listNormal.push(item);
            }
            if (Array.isArray(_data["listAlert"])) {
                this.listAlert = [] as any;
                for (let item of _data["listAlert"])
                    this.listAlert.push(item);
            }
            if (Array.isArray(_data["listDisconnect"])) {
                this.listDisconnect = [] as any;
                for (let item of _data["listDisconnect"])
                    this.listDisconnect.push(item);
            }
            if (Array.isArray(_data["listData"])) {
                this.listData = [] as any;
                for (let item of _data["listData"])
                    this.listData.push(DataTableTrangThaiKetNoiInDay.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BaoCaoTrangThaiKetNoiOutput {
        data = typeof data === 'object' ? data : {};
        let result = new BaoCaoTrangThaiKetNoiOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listDay)) {
            data["listDay"] = [];
            for (let item of this.listDay)
                data["listDay"].push(item);
        }
        if (Array.isArray(this.listNormal)) {
            data["listNormal"] = [];
            for (let item of this.listNormal)
                data["listNormal"].push(item);
        }
        if (Array.isArray(this.listAlert)) {
            data["listAlert"] = [];
            for (let item of this.listAlert)
                data["listAlert"].push(item);
        }
        if (Array.isArray(this.listDisconnect)) {
            data["listDisconnect"] = [];
            for (let item of this.listDisconnect)
                data["listDisconnect"].push(item);
        }
        if (Array.isArray(this.listData)) {
            data["listData"] = [];
            for (let item of this.listData)
                data["listData"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BaoCaoTrangThaiKetNoiOutput {
        const json = this.toJSON();
        let result = new BaoCaoTrangThaiKetNoiOutput();
        result.init(json);
        return result;
    }
}

export interface IBaoCaoTrangThaiKetNoiOutput {
    listDay: string[] | undefined;
    listNormal: number[] | undefined;
    listAlert: number[] | undefined;
    listDisconnect: number[] | undefined;
    listData: DataTableTrangThaiKetNoiInDay[] | undefined;
}

export class BaoCaoTrangThaiKetNoiInput implements IBaoCaoTrangThaiKetNoiInput {
    tramId: number | undefined;
    tuNgay: moment.Moment;
    denNgay: moment.Moment;

    constructor(data?: IBaoCaoTrangThaiKetNoiInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tramId = _data["tramId"];
            this.tuNgay = _data["tuNgay"] ? moment(_data["tuNgay"].toString()) : <any>undefined;
            this.denNgay = _data["denNgay"] ? moment(_data["denNgay"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BaoCaoTrangThaiKetNoiInput {
        data = typeof data === 'object' ? data : {};
        let result = new BaoCaoTrangThaiKetNoiInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tramId"] = this.tramId;
        data["tuNgay"] = this.tuNgay ? this.tuNgay.toISOString() : <any>undefined;
        data["denNgay"] = this.denNgay ? this.denNgay.toISOString() : <any>undefined;
        return data; 
    }

    clone(): BaoCaoTrangThaiKetNoiInput {
        const json = this.toJSON();
        let result = new BaoCaoTrangThaiKetNoiInput();
        result.init(json);
        return result;
    }
}

export interface IBaoCaoTrangThaiKetNoiInput {
    tramId: number | undefined;
    tuNgay: moment.Moment;
    denNgay: moment.Moment;
}

export class CauHinhChungDto implements ICauHinhChungDto {
    tenHeThong: string | undefined;
    publicIp: string | undefined;
    privateIp: string | undefined;
    port: number | undefined;
    thoiGianMoCoi: number | undefined;
    thoiGianMoLoa: number | undefined;
    kinhDo: number | undefined;
    viDo: number | undefined;
    ketNoiServerIp: string | undefined;
    ketNoiServerPort: number | undefined;
    ketNoiClientIp: string | undefined;
    ketNoiClientPort: number | undefined;
    thuatToanOTP: string | undefined;
    thoiHanOTP: number | undefined;
    smsUsername: string | undefined;
    smsPassword: string | undefined;
    smsIp: string | undefined;
    smsPort: number | undefined;
    smsDauSo: string | undefined;
    id: number | undefined;

    constructor(data?: ICauHinhChungDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenHeThong = _data["tenHeThong"];
            this.publicIp = _data["publicIp"];
            this.privateIp = _data["privateIp"];
            this.port = _data["port"];
            this.thoiGianMoCoi = _data["thoiGianMoCoi"];
            this.thoiGianMoLoa = _data["thoiGianMoLoa"];
            this.kinhDo = _data["kinhDo"];
            this.viDo = _data["viDo"];
            this.ketNoiServerIp = _data["ketNoiServerIp"];
            this.ketNoiServerPort = _data["ketNoiServerPort"];
            this.ketNoiClientIp = _data["ketNoiClientIp"];
            this.ketNoiClientPort = _data["ketNoiClientPort"];
            this.thuatToanOTP = _data["thuatToanOTP"];
            this.thoiHanOTP = _data["thoiHanOTP"];
            this.smsUsername = _data["smsUsername"];
            this.smsPassword = _data["smsPassword"];
            this.smsIp = _data["smsIp"];
            this.smsPort = _data["smsPort"];
            this.smsDauSo = _data["smsDauSo"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CauHinhChungDto {
        data = typeof data === 'object' ? data : {};
        let result = new CauHinhChungDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenHeThong"] = this.tenHeThong;
        data["publicIp"] = this.publicIp;
        data["privateIp"] = this.privateIp;
        data["port"] = this.port;
        data["thoiGianMoCoi"] = this.thoiGianMoCoi;
        data["thoiGianMoLoa"] = this.thoiGianMoLoa;
        data["kinhDo"] = this.kinhDo;
        data["viDo"] = this.viDo;
        data["ketNoiServerIp"] = this.ketNoiServerIp;
        data["ketNoiServerPort"] = this.ketNoiServerPort;
        data["ketNoiClientIp"] = this.ketNoiClientIp;
        data["ketNoiClientPort"] = this.ketNoiClientPort;
        data["thuatToanOTP"] = this.thuatToanOTP;
        data["thoiHanOTP"] = this.thoiHanOTP;
        data["smsUsername"] = this.smsUsername;
        data["smsPassword"] = this.smsPassword;
        data["smsIp"] = this.smsIp;
        data["smsPort"] = this.smsPort;
        data["smsDauSo"] = this.smsDauSo;
        data["id"] = this.id;
        return data; 
    }

    clone(): CauHinhChungDto {
        const json = this.toJSON();
        let result = new CauHinhChungDto();
        result.init(json);
        return result;
    }
}

export interface ICauHinhChungDto {
    tenHeThong: string | undefined;
    publicIp: string | undefined;
    privateIp: string | undefined;
    port: number | undefined;
    thoiGianMoCoi: number | undefined;
    thoiGianMoLoa: number | undefined;
    kinhDo: number | undefined;
    viDo: number | undefined;
    ketNoiServerIp: string | undefined;
    ketNoiServerPort: number | undefined;
    ketNoiClientIp: string | undefined;
    ketNoiClientPort: number | undefined;
    thuatToanOTP: string | undefined;
    thoiHanOTP: number | undefined;
    smsUsername: string | undefined;
    smsPassword: string | undefined;
    smsIp: string | undefined;
    smsPort: number | undefined;
    smsDauSo: string | undefined;
    id: number | undefined;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data; 
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class CountCanhBaoNow implements ICountCanhBaoNow {
    total: number | undefined;
    critical: number | undefined;
    major: number | undefined;
    minor: number | undefined;
    warning: number | undefined;
    indeterminate: number | undefined;

    constructor(data?: ICountCanhBaoNow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            this.critical = _data["critical"];
            this.major = _data["major"];
            this.minor = _data["minor"];
            this.warning = _data["warning"];
            this.indeterminate = _data["indeterminate"];
        }
    }

    static fromJS(data: any): CountCanhBaoNow {
        data = typeof data === 'object' ? data : {};
        let result = new CountCanhBaoNow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        data["critical"] = this.critical;
        data["major"] = this.major;
        data["minor"] = this.minor;
        data["warning"] = this.warning;
        data["indeterminate"] = this.indeterminate;
        return data; 
    }

    clone(): CountCanhBaoNow {
        const json = this.toJSON();
        let result = new CountCanhBaoNow();
        result.init(json);
        return result;
    }
}

export interface ICountCanhBaoNow {
    total: number | undefined;
    critical: number | undefined;
    major: number | undefined;
    minor: number | undefined;
    warning: number | undefined;
    indeterminate: number | undefined;
}

export class CanhBaoDashboadOutput implements ICanhBaoDashboadOutput {
    sumCanhBao: CountCanhBaoNow;
    listHour: string[] | undefined;
    critialInHour: number[] | undefined;
    majorInHour: number[] | undefined;
    minorInHour: number[] | undefined;
    warningInHour: number[] | undefined;
    indeterminateInHour: number[] | undefined;

    constructor(data?: ICanhBaoDashboadOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sumCanhBao = _data["sumCanhBao"] ? CountCanhBaoNow.fromJS(_data["sumCanhBao"]) : <any>undefined;
            if (Array.isArray(_data["listHour"])) {
                this.listHour = [] as any;
                for (let item of _data["listHour"])
                    this.listHour.push(item);
            }
            if (Array.isArray(_data["critialInHour"])) {
                this.critialInHour = [] as any;
                for (let item of _data["critialInHour"])
                    this.critialInHour.push(item);
            }
            if (Array.isArray(_data["majorInHour"])) {
                this.majorInHour = [] as any;
                for (let item of _data["majorInHour"])
                    this.majorInHour.push(item);
            }
            if (Array.isArray(_data["minorInHour"])) {
                this.minorInHour = [] as any;
                for (let item of _data["minorInHour"])
                    this.minorInHour.push(item);
            }
            if (Array.isArray(_data["warningInHour"])) {
                this.warningInHour = [] as any;
                for (let item of _data["warningInHour"])
                    this.warningInHour.push(item);
            }
            if (Array.isArray(_data["indeterminateInHour"])) {
                this.indeterminateInHour = [] as any;
                for (let item of _data["indeterminateInHour"])
                    this.indeterminateInHour.push(item);
            }
        }
    }

    static fromJS(data: any): CanhBaoDashboadOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CanhBaoDashboadOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sumCanhBao"] = this.sumCanhBao ? this.sumCanhBao.toJSON() : <any>undefined;
        if (Array.isArray(this.listHour)) {
            data["listHour"] = [];
            for (let item of this.listHour)
                data["listHour"].push(item);
        }
        if (Array.isArray(this.critialInHour)) {
            data["critialInHour"] = [];
            for (let item of this.critialInHour)
                data["critialInHour"].push(item);
        }
        if (Array.isArray(this.majorInHour)) {
            data["majorInHour"] = [];
            for (let item of this.majorInHour)
                data["majorInHour"].push(item);
        }
        if (Array.isArray(this.minorInHour)) {
            data["minorInHour"] = [];
            for (let item of this.minorInHour)
                data["minorInHour"].push(item);
        }
        if (Array.isArray(this.warningInHour)) {
            data["warningInHour"] = [];
            for (let item of this.warningInHour)
                data["warningInHour"].push(item);
        }
        if (Array.isArray(this.indeterminateInHour)) {
            data["indeterminateInHour"] = [];
            for (let item of this.indeterminateInHour)
                data["indeterminateInHour"].push(item);
        }
        return data; 
    }

    clone(): CanhBaoDashboadOutput {
        const json = this.toJSON();
        let result = new CanhBaoDashboadOutput();
        result.init(json);
        return result;
    }
}

export interface ICanhBaoDashboadOutput {
    sumCanhBao: CountCanhBaoNow;
    listHour: string[] | undefined;
    critialInHour: number[] | undefined;
    majorInHour: number[] | undefined;
    minorInHour: number[] | undefined;
    warningInHour: number[] | undefined;
    indeterminateInHour: number[] | undefined;
}

export class TabViewCanhBao implements ITabViewCanhBao {
    idCanhBao: string | undefined;
    idThietBi: string | undefined;
    idTram: number;
    tenTram: string | undefined;
    thoiGianCanhBao: string | undefined;
    thoiGianCanhBaoLong: number;
    loaiCanhBao: string | undefined;
    loaiCanhBaoShow: string | undefined;
    mucDo: string | undefined;
    trangThai: string | undefined;
    giaTri: string | undefined;
    thietBiTBEntity: string | undefined;
    tramTBEntity: string | undefined;
    loaiThietBi: number | undefined;
    mienId: number;

    constructor(data?: ITabViewCanhBao) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idCanhBao = _data["idCanhBao"];
            this.idThietBi = _data["idThietBi"];
            this.idTram = _data["idTram"];
            this.tenTram = _data["tenTram"];
            this.thoiGianCanhBao = _data["thoiGianCanhBao"];
            this.thoiGianCanhBaoLong = _data["thoiGianCanhBaoLong"];
            this.loaiCanhBao = _data["loaiCanhBao"];
            this.loaiCanhBaoShow = _data["loaiCanhBaoShow"];
            this.mucDo = _data["mucDo"];
            this.trangThai = _data["trangThai"];
            this.giaTri = _data["giaTri"];
            this.thietBiTBEntity = _data["thietBiTBEntity"];
            this.tramTBEntity = _data["tramTBEntity"];
            this.loaiThietBi = _data["loaiThietBi"];
            this.mienId = _data["mienId"];
        }
    }

    static fromJS(data: any): TabViewCanhBao {
        data = typeof data === 'object' ? data : {};
        let result = new TabViewCanhBao();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idCanhBao"] = this.idCanhBao;
        data["idThietBi"] = this.idThietBi;
        data["idTram"] = this.idTram;
        data["tenTram"] = this.tenTram;
        data["thoiGianCanhBao"] = this.thoiGianCanhBao;
        data["thoiGianCanhBaoLong"] = this.thoiGianCanhBaoLong;
        data["loaiCanhBao"] = this.loaiCanhBao;
        data["loaiCanhBaoShow"] = this.loaiCanhBaoShow;
        data["mucDo"] = this.mucDo;
        data["trangThai"] = this.trangThai;
        data["giaTri"] = this.giaTri;
        data["thietBiTBEntity"] = this.thietBiTBEntity;
        data["tramTBEntity"] = this.tramTBEntity;
        data["loaiThietBi"] = this.loaiThietBi;
        data["mienId"] = this.mienId;
        return data; 
    }

    clone(): TabViewCanhBao {
        const json = this.toJSON();
        let result = new TabViewCanhBao();
        result.init(json);
        return result;
    }
}

export interface ITabViewCanhBao {
    idCanhBao: string | undefined;
    idThietBi: string | undefined;
    idTram: number;
    tenTram: string | undefined;
    thoiGianCanhBao: string | undefined;
    thoiGianCanhBaoLong: number;
    loaiCanhBao: string | undefined;
    loaiCanhBaoShow: string | undefined;
    mucDo: string | undefined;
    trangThai: string | undefined;
    giaTri: string | undefined;
    thietBiTBEntity: string | undefined;
    tramTBEntity: string | undefined;
    loaiThietBi: number | undefined;
    mienId: number;
}

export class CanhBaoPieChartTabView implements ICanhBaoPieChartTabView {
    mienBac: number;
    mienTrung: number;
    mienNam: number;
    dataPieChartDetail: number[] | undefined;
    listAll: TabViewCanhBao[] | undefined;
    listNhietDo: TabViewCanhBao[] | undefined;
    listDoAm: TabViewCanhBao[] | undefined;
    listDienAp: TabViewCanhBao[] | undefined;
    listDongDien: TabViewCanhBao[] | undefined;
    listChay: TabViewCanhBao[] | undefined;
    listKhoi: TabViewCanhBao[] | undefined;
    listMatTinHieu: TabViewCanhBao[] | undefined;
    listChuyenDong: TabViewCanhBao[] | undefined;
    listCua: TabViewCanhBao[] | undefined;
    listNhienLieu: TabViewCanhBao[] | undefined;
    listNgapNuoc: TabViewCanhBao[] | undefined;
    listGocNghiengAnten: TabViewCanhBao[] | undefined;
    listKhac: TabViewCanhBao[] | undefined;

    constructor(data?: ICanhBaoPieChartTabView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mienBac = _data["mienBac"];
            this.mienTrung = _data["mienTrung"];
            this.mienNam = _data["mienNam"];
            if (Array.isArray(_data["dataPieChartDetail"])) {
                this.dataPieChartDetail = [] as any;
                for (let item of _data["dataPieChartDetail"])
                    this.dataPieChartDetail.push(item);
            }
            if (Array.isArray(_data["listAll"])) {
                this.listAll = [] as any;
                for (let item of _data["listAll"])
                    this.listAll.push(TabViewCanhBao.fromJS(item));
            }
            if (Array.isArray(_data["listNhietDo"])) {
                this.listNhietDo = [] as any;
                for (let item of _data["listNhietDo"])
                    this.listNhietDo.push(TabViewCanhBao.fromJS(item));
            }
            if (Array.isArray(_data["listDoAm"])) {
                this.listDoAm = [] as any;
                for (let item of _data["listDoAm"])
                    this.listDoAm.push(TabViewCanhBao.fromJS(item));
            }
            if (Array.isArray(_data["listDienAp"])) {
                this.listDienAp = [] as any;
                for (let item of _data["listDienAp"])
                    this.listDienAp.push(TabViewCanhBao.fromJS(item));
            }
            if (Array.isArray(_data["listDongDien"])) {
                this.listDongDien = [] as any;
                for (let item of _data["listDongDien"])
                    this.listDongDien.push(TabViewCanhBao.fromJS(item));
            }
            if (Array.isArray(_data["listChay"])) {
                this.listChay = [] as any;
                for (let item of _data["listChay"])
                    this.listChay.push(TabViewCanhBao.fromJS(item));
            }
            if (Array.isArray(_data["listKhoi"])) {
                this.listKhoi = [] as any;
                for (let item of _data["listKhoi"])
                    this.listKhoi.push(TabViewCanhBao.fromJS(item));
            }
            if (Array.isArray(_data["listMatTinHieu"])) {
                this.listMatTinHieu = [] as any;
                for (let item of _data["listMatTinHieu"])
                    this.listMatTinHieu.push(TabViewCanhBao.fromJS(item));
            }
            if (Array.isArray(_data["listChuyenDong"])) {
                this.listChuyenDong = [] as any;
                for (let item of _data["listChuyenDong"])
                    this.listChuyenDong.push(TabViewCanhBao.fromJS(item));
            }
            if (Array.isArray(_data["listCua"])) {
                this.listCua = [] as any;
                for (let item of _data["listCua"])
                    this.listCua.push(TabViewCanhBao.fromJS(item));
            }
            if (Array.isArray(_data["listNhienLieu"])) {
                this.listNhienLieu = [] as any;
                for (let item of _data["listNhienLieu"])
                    this.listNhienLieu.push(TabViewCanhBao.fromJS(item));
            }
            if (Array.isArray(_data["listNgapNuoc"])) {
                this.listNgapNuoc = [] as any;
                for (let item of _data["listNgapNuoc"])
                    this.listNgapNuoc.push(TabViewCanhBao.fromJS(item));
            }
            if (Array.isArray(_data["listGocNghiengAnten"])) {
                this.listGocNghiengAnten = [] as any;
                for (let item of _data["listGocNghiengAnten"])
                    this.listGocNghiengAnten.push(TabViewCanhBao.fromJS(item));
            }
            if (Array.isArray(_data["listKhac"])) {
                this.listKhac = [] as any;
                for (let item of _data["listKhac"])
                    this.listKhac.push(TabViewCanhBao.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CanhBaoPieChartTabView {
        data = typeof data === 'object' ? data : {};
        let result = new CanhBaoPieChartTabView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mienBac"] = this.mienBac;
        data["mienTrung"] = this.mienTrung;
        data["mienNam"] = this.mienNam;
        if (Array.isArray(this.dataPieChartDetail)) {
            data["dataPieChartDetail"] = [];
            for (let item of this.dataPieChartDetail)
                data["dataPieChartDetail"].push(item);
        }
        if (Array.isArray(this.listAll)) {
            data["listAll"] = [];
            for (let item of this.listAll)
                data["listAll"].push(item.toJSON());
        }
        if (Array.isArray(this.listNhietDo)) {
            data["listNhietDo"] = [];
            for (let item of this.listNhietDo)
                data["listNhietDo"].push(item.toJSON());
        }
        if (Array.isArray(this.listDoAm)) {
            data["listDoAm"] = [];
            for (let item of this.listDoAm)
                data["listDoAm"].push(item.toJSON());
        }
        if (Array.isArray(this.listDienAp)) {
            data["listDienAp"] = [];
            for (let item of this.listDienAp)
                data["listDienAp"].push(item.toJSON());
        }
        if (Array.isArray(this.listDongDien)) {
            data["listDongDien"] = [];
            for (let item of this.listDongDien)
                data["listDongDien"].push(item.toJSON());
        }
        if (Array.isArray(this.listChay)) {
            data["listChay"] = [];
            for (let item of this.listChay)
                data["listChay"].push(item.toJSON());
        }
        if (Array.isArray(this.listKhoi)) {
            data["listKhoi"] = [];
            for (let item of this.listKhoi)
                data["listKhoi"].push(item.toJSON());
        }
        if (Array.isArray(this.listMatTinHieu)) {
            data["listMatTinHieu"] = [];
            for (let item of this.listMatTinHieu)
                data["listMatTinHieu"].push(item.toJSON());
        }
        if (Array.isArray(this.listChuyenDong)) {
            data["listChuyenDong"] = [];
            for (let item of this.listChuyenDong)
                data["listChuyenDong"].push(item.toJSON());
        }
        if (Array.isArray(this.listCua)) {
            data["listCua"] = [];
            for (let item of this.listCua)
                data["listCua"].push(item.toJSON());
        }
        if (Array.isArray(this.listNhienLieu)) {
            data["listNhienLieu"] = [];
            for (let item of this.listNhienLieu)
                data["listNhienLieu"].push(item.toJSON());
        }
        if (Array.isArray(this.listNgapNuoc)) {
            data["listNgapNuoc"] = [];
            for (let item of this.listNgapNuoc)
                data["listNgapNuoc"].push(item.toJSON());
        }
        if (Array.isArray(this.listGocNghiengAnten)) {
            data["listGocNghiengAnten"] = [];
            for (let item of this.listGocNghiengAnten)
                data["listGocNghiengAnten"].push(item.toJSON());
        }
        if (Array.isArray(this.listKhac)) {
            data["listKhac"] = [];
            for (let item of this.listKhac)
                data["listKhac"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CanhBaoPieChartTabView {
        const json = this.toJSON();
        let result = new CanhBaoPieChartTabView();
        result.init(json);
        return result;
    }
}

export interface ICanhBaoPieChartTabView {
    mienBac: number;
    mienTrung: number;
    mienNam: number;
    dataPieChartDetail: number[] | undefined;
    listAll: TabViewCanhBao[] | undefined;
    listNhietDo: TabViewCanhBao[] | undefined;
    listDoAm: TabViewCanhBao[] | undefined;
    listDienAp: TabViewCanhBao[] | undefined;
    listDongDien: TabViewCanhBao[] | undefined;
    listChay: TabViewCanhBao[] | undefined;
    listKhoi: TabViewCanhBao[] | undefined;
    listMatTinHieu: TabViewCanhBao[] | undefined;
    listChuyenDong: TabViewCanhBao[] | undefined;
    listCua: TabViewCanhBao[] | undefined;
    listNhienLieu: TabViewCanhBao[] | undefined;
    listNgapNuoc: TabViewCanhBao[] | undefined;
    listGocNghiengAnten: TabViewCanhBao[] | undefined;
    listKhac: TabViewCanhBao[] | undefined;
}

export class DMCanhBaoOutput implements IDMCanhBaoOutput {
    idCanhBao: string | undefined;
    idThietBi: string | undefined;
    idTram: number;
    tenTram: string | undefined;
    tenBoCanhBao: string | undefined;
    thoiGianCanhBao: string | undefined;
    thoiGianCls: string | undefined;
    thoiGianCanhBaoLong: number;
    thoiGianCoCanhBao: string | undefined;
    loaiCanhBao: string | undefined;
    loaiCanhBaoShow: string | undefined;
    mucDo: string | undefined;
    trangThai: string | undefined;
    giaTri: string | undefined;
    tbEntityId: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IDMCanhBaoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idCanhBao = _data["idCanhBao"];
            this.idThietBi = _data["idThietBi"];
            this.idTram = _data["idTram"];
            this.tenTram = _data["tenTram"];
            this.tenBoCanhBao = _data["tenBoCanhBao"];
            this.thoiGianCanhBao = _data["thoiGianCanhBao"];
            this.thoiGianCls = _data["thoiGianCls"];
            this.thoiGianCanhBaoLong = _data["thoiGianCanhBaoLong"];
            this.thoiGianCoCanhBao = _data["thoiGianCoCanhBao"];
            this.loaiCanhBao = _data["loaiCanhBao"];
            this.loaiCanhBaoShow = _data["loaiCanhBaoShow"];
            this.mucDo = _data["mucDo"];
            this.trangThai = _data["trangThai"];
            this.giaTri = _data["giaTri"];
            this.tbEntityId = _data["tbEntityId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DMCanhBaoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DMCanhBaoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idCanhBao"] = this.idCanhBao;
        data["idThietBi"] = this.idThietBi;
        data["idTram"] = this.idTram;
        data["tenTram"] = this.tenTram;
        data["tenBoCanhBao"] = this.tenBoCanhBao;
        data["thoiGianCanhBao"] = this.thoiGianCanhBao;
        data["thoiGianCls"] = this.thoiGianCls;
        data["thoiGianCanhBaoLong"] = this.thoiGianCanhBaoLong;
        data["thoiGianCoCanhBao"] = this.thoiGianCoCanhBao;
        data["loaiCanhBao"] = this.loaiCanhBao;
        data["loaiCanhBaoShow"] = this.loaiCanhBaoShow;
        data["mucDo"] = this.mucDo;
        data["trangThai"] = this.trangThai;
        data["giaTri"] = this.giaTri;
        data["tbEntityId"] = this.tbEntityId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DMCanhBaoOutput {
        const json = this.toJSON();
        let result = new DMCanhBaoOutput();
        result.init(json);
        return result;
    }
}

export interface IDMCanhBaoOutput {
    idCanhBao: string | undefined;
    idThietBi: string | undefined;
    idTram: number;
    tenTram: string | undefined;
    tenBoCanhBao: string | undefined;
    thoiGianCanhBao: string | undefined;
    thoiGianCls: string | undefined;
    thoiGianCanhBaoLong: number;
    thoiGianCoCanhBao: string | undefined;
    loaiCanhBao: string | undefined;
    loaiCanhBaoShow: string | undefined;
    mucDo: string | undefined;
    trangThai: string | undefined;
    giaTri: string | undefined;
    tbEntityId: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class DemoDto implements IDemoDto {
    ma: string | undefined;
    ten: string | undefined;
    checkbox: string | undefined;
    checkboxTrueFalse: boolean | undefined;
    radioButton: number | undefined;
    inputSwitch: boolean | undefined;
    inputMask: string | undefined;
    slider: number | undefined;
    description: string | undefined;
    inputTextarea: string | undefined;
    integerOnly: number | undefined;
    decimal: number | undefined;
    dateBasic: moment.Moment | undefined;
    dateTime: moment.Moment | undefined;
    dateDisable: moment.Moment | undefined;
    dateMinMax: moment.Moment | undefined;
    dateFrom: moment.Moment | undefined;
    dateTo: moment.Moment | undefined;
    dateMultiple: string | undefined;
    dateMultipleMonth: moment.Moment | undefined;
    monthOnly: moment.Moment | undefined;
    timeOnly: string | undefined;
    autoCompleteSingle: number | undefined;
    autoCompleteMultiple: string | undefined;
    dropdownSingle: number | undefined;
    dropdownMultiple: string | undefined;
    id: number;

    constructor(data?: IDemoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma = _data["ma"];
            this.ten = _data["ten"];
            this.checkbox = _data["checkbox"];
            this.checkboxTrueFalse = _data["checkboxTrueFalse"];
            this.radioButton = _data["radioButton"];
            this.inputSwitch = _data["inputSwitch"];
            this.inputMask = _data["inputMask"];
            this.slider = _data["slider"];
            this.description = _data["description"];
            this.inputTextarea = _data["inputTextarea"];
            this.integerOnly = _data["integerOnly"];
            this.decimal = _data["decimal"];
            this.dateBasic = _data["dateBasic"] ? moment(_data["dateBasic"].toString()) : <any>undefined;
            this.dateTime = _data["dateTime"] ? moment(_data["dateTime"].toString()) : <any>undefined;
            this.dateDisable = _data["dateDisable"] ? moment(_data["dateDisable"].toString()) : <any>undefined;
            this.dateMinMax = _data["dateMinMax"] ? moment(_data["dateMinMax"].toString()) : <any>undefined;
            this.dateFrom = _data["dateFrom"] ? moment(_data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["dateTo"] ? moment(_data["dateTo"].toString()) : <any>undefined;
            this.dateMultiple = _data["dateMultiple"];
            this.dateMultipleMonth = _data["dateMultipleMonth"] ? moment(_data["dateMultipleMonth"].toString()) : <any>undefined;
            this.monthOnly = _data["monthOnly"] ? moment(_data["monthOnly"].toString()) : <any>undefined;
            this.timeOnly = _data["timeOnly"];
            this.autoCompleteSingle = _data["autoCompleteSingle"];
            this.autoCompleteMultiple = _data["autoCompleteMultiple"];
            this.dropdownSingle = _data["dropdownSingle"];
            this.dropdownMultiple = _data["dropdownMultiple"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DemoDto {
        data = typeof data === 'object' ? data : {};
        let result = new DemoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma"] = this.ma;
        data["ten"] = this.ten;
        data["checkbox"] = this.checkbox;
        data["checkboxTrueFalse"] = this.checkboxTrueFalse;
        data["radioButton"] = this.radioButton;
        data["inputSwitch"] = this.inputSwitch;
        data["inputMask"] = this.inputMask;
        data["slider"] = this.slider;
        data["description"] = this.description;
        data["inputTextarea"] = this.inputTextarea;
        data["integerOnly"] = this.integerOnly;
        data["decimal"] = this.decimal;
        data["dateBasic"] = this.dateBasic ? this.dateBasic.toISOString() : <any>undefined;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["dateDisable"] = this.dateDisable ? this.dateDisable.toISOString() : <any>undefined;
        data["dateMinMax"] = this.dateMinMax ? this.dateMinMax.toISOString() : <any>undefined;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        data["dateMultiple"] = this.dateMultiple;
        data["dateMultipleMonth"] = this.dateMultipleMonth ? this.dateMultipleMonth.toISOString() : <any>undefined;
        data["monthOnly"] = this.monthOnly ? this.monthOnly.toISOString() : <any>undefined;
        data["timeOnly"] = this.timeOnly;
        data["autoCompleteSingle"] = this.autoCompleteSingle;
        data["autoCompleteMultiple"] = this.autoCompleteMultiple;
        data["dropdownSingle"] = this.dropdownSingle;
        data["dropdownMultiple"] = this.dropdownMultiple;
        data["id"] = this.id;
        return data; 
    }

    clone(): DemoDto {
        const json = this.toJSON();
        let result = new DemoDto();
        result.init(json);
        return result;
    }
}

export interface IDemoDto {
    ma: string | undefined;
    ten: string | undefined;
    checkbox: string | undefined;
    checkboxTrueFalse: boolean | undefined;
    radioButton: number | undefined;
    inputSwitch: boolean | undefined;
    inputMask: string | undefined;
    slider: number | undefined;
    description: string | undefined;
    inputTextarea: string | undefined;
    integerOnly: number | undefined;
    decimal: number | undefined;
    dateBasic: moment.Moment | undefined;
    dateTime: moment.Moment | undefined;
    dateDisable: moment.Moment | undefined;
    dateMinMax: moment.Moment | undefined;
    dateFrom: moment.Moment | undefined;
    dateTo: moment.Moment | undefined;
    dateMultiple: string | undefined;
    dateMultipleMonth: moment.Moment | undefined;
    monthOnly: moment.Moment | undefined;
    timeOnly: string | undefined;
    autoCompleteSingle: number | undefined;
    autoCompleteMultiple: string | undefined;
    dropdownSingle: number | undefined;
    dropdownMultiple: string | undefined;
    id: number;
}

export class DemoForView implements IDemoForView {
    demo: DemoDto;
    trangThai: string | undefined;
    trangThaiDuyet: string | undefined;

    constructor(data?: IDemoForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.demo = _data["demo"] ? DemoDto.fromJS(_data["demo"]) : <any>undefined;
            this.trangThai = _data["trangThai"];
            this.trangThaiDuyet = _data["trangThaiDuyet"];
        }
    }

    static fromJS(data: any): DemoForView {
        data = typeof data === 'object' ? data : {};
        let result = new DemoForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["demo"] = this.demo ? this.demo.toJSON() : <any>undefined;
        data["trangThai"] = this.trangThai;
        data["trangThaiDuyet"] = this.trangThaiDuyet;
        return data; 
    }

    clone(): DemoForView {
        const json = this.toJSON();
        let result = new DemoForView();
        result.init(json);
        return result;
    }
}

export interface IDemoForView {
    demo: DemoDto;
    trangThai: string | undefined;
    trangThaiDuyet: string | undefined;
}

export class DemoForViewPagedResultDto implements IDemoForViewPagedResultDto {
    totalCount: number;
    items: DemoForView[] | undefined;

    constructor(data?: IDemoForViewPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DemoForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DemoForViewPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DemoForViewPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DemoForViewPagedResultDto {
        const json = this.toJSON();
        let result = new DemoForViewPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDemoForViewPagedResultDto {
    totalCount: number;
    items: DemoForView[] | undefined;
}

export class Demo_File implements IDemo_File {
    tenantId: number | undefined;
    demoId: number | undefined;
    tenFile: string | undefined;
    linkFile: string | undefined;
    loaiFile: number | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IDemo_File) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.demoId = _data["demoId"];
            this.tenFile = _data["tenFile"];
            this.linkFile = _data["linkFile"];
            this.loaiFile = _data["loaiFile"];
            this.ghiChu = _data["ghiChu"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Demo_File {
        data = typeof data === 'object' ? data : {};
        let result = new Demo_File();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["demoId"] = this.demoId;
        data["tenFile"] = this.tenFile;
        data["linkFile"] = this.linkFile;
        data["loaiFile"] = this.loaiFile;
        data["ghiChu"] = this.ghiChu;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Demo_File {
        const json = this.toJSON();
        let result = new Demo_File();
        result.init(json);
        return result;
    }
}

export interface IDemo_File {
    tenantId: number | undefined;
    demoId: number | undefined;
    tenFile: string | undefined;
    linkFile: string | undefined;
    loaiFile: number | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class DemoCreateInput implements IDemoCreateInput {
    ma: string | undefined;
    ten: string | undefined;
    checkbox: string | undefined;
    checkboxTrueFalse: boolean | undefined;
    radioButton: number | undefined;
    inputSwitch: boolean | undefined;
    inputMask: string | undefined;
    slider: number | undefined;
    description: string | undefined;
    inputTextarea: string | undefined;
    integerOnly: number | undefined;
    decimal: number | undefined;
    dateBasic: moment.Moment | undefined;
    dateTime: moment.Moment | undefined;
    dateDisable: moment.Moment | undefined;
    dateMinMax: moment.Moment | undefined;
    dateFrom: moment.Moment | undefined;
    dateTo: moment.Moment | undefined;
    dateMultiple: string | undefined;
    dateMultipleMonth: moment.Moment | undefined;
    monthOnly: moment.Moment | undefined;
    timeOnly: string | undefined;
    autoCompleteSingle: number | undefined;
    autoCompleteMultiple: string | undefined;
    dropdownSingle: number | undefined;
    dropdownMultiple: string | undefined;
    listDemoFile: Demo_File[] | undefined;
    id: number | undefined;

    constructor(data?: IDemoCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma = _data["ma"];
            this.ten = _data["ten"];
            this.checkbox = _data["checkbox"];
            this.checkboxTrueFalse = _data["checkboxTrueFalse"];
            this.radioButton = _data["radioButton"];
            this.inputSwitch = _data["inputSwitch"];
            this.inputMask = _data["inputMask"];
            this.slider = _data["slider"];
            this.description = _data["description"];
            this.inputTextarea = _data["inputTextarea"];
            this.integerOnly = _data["integerOnly"];
            this.decimal = _data["decimal"];
            this.dateBasic = _data["dateBasic"] ? moment(_data["dateBasic"].toString()) : <any>undefined;
            this.dateTime = _data["dateTime"] ? moment(_data["dateTime"].toString()) : <any>undefined;
            this.dateDisable = _data["dateDisable"] ? moment(_data["dateDisable"].toString()) : <any>undefined;
            this.dateMinMax = _data["dateMinMax"] ? moment(_data["dateMinMax"].toString()) : <any>undefined;
            this.dateFrom = _data["dateFrom"] ? moment(_data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["dateTo"] ? moment(_data["dateTo"].toString()) : <any>undefined;
            this.dateMultiple = _data["dateMultiple"];
            this.dateMultipleMonth = _data["dateMultipleMonth"] ? moment(_data["dateMultipleMonth"].toString()) : <any>undefined;
            this.monthOnly = _data["monthOnly"] ? moment(_data["monthOnly"].toString()) : <any>undefined;
            this.timeOnly = _data["timeOnly"];
            this.autoCompleteSingle = _data["autoCompleteSingle"];
            this.autoCompleteMultiple = _data["autoCompleteMultiple"];
            this.dropdownSingle = _data["dropdownSingle"];
            this.dropdownMultiple = _data["dropdownMultiple"];
            if (Array.isArray(_data["listDemoFile"])) {
                this.listDemoFile = [] as any;
                for (let item of _data["listDemoFile"])
                    this.listDemoFile.push(Demo_File.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DemoCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new DemoCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma"] = this.ma;
        data["ten"] = this.ten;
        data["checkbox"] = this.checkbox;
        data["checkboxTrueFalse"] = this.checkboxTrueFalse;
        data["radioButton"] = this.radioButton;
        data["inputSwitch"] = this.inputSwitch;
        data["inputMask"] = this.inputMask;
        data["slider"] = this.slider;
        data["description"] = this.description;
        data["inputTextarea"] = this.inputTextarea;
        data["integerOnly"] = this.integerOnly;
        data["decimal"] = this.decimal;
        data["dateBasic"] = this.dateBasic ? this.dateBasic.toISOString() : <any>undefined;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["dateDisable"] = this.dateDisable ? this.dateDisable.toISOString() : <any>undefined;
        data["dateMinMax"] = this.dateMinMax ? this.dateMinMax.toISOString() : <any>undefined;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        data["dateMultiple"] = this.dateMultiple;
        data["dateMultipleMonth"] = this.dateMultipleMonth ? this.dateMultipleMonth.toISOString() : <any>undefined;
        data["monthOnly"] = this.monthOnly ? this.monthOnly.toISOString() : <any>undefined;
        data["timeOnly"] = this.timeOnly;
        data["autoCompleteSingle"] = this.autoCompleteSingle;
        data["autoCompleteMultiple"] = this.autoCompleteMultiple;
        data["dropdownSingle"] = this.dropdownSingle;
        data["dropdownMultiple"] = this.dropdownMultiple;
        if (Array.isArray(this.listDemoFile)) {
            data["listDemoFile"] = [];
            for (let item of this.listDemoFile)
                data["listDemoFile"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): DemoCreateInput {
        const json = this.toJSON();
        let result = new DemoCreateInput();
        result.init(json);
        return result;
    }
}

export interface IDemoCreateInput {
    ma: string | undefined;
    ten: string | undefined;
    checkbox: string | undefined;
    checkboxTrueFalse: boolean | undefined;
    radioButton: number | undefined;
    inputSwitch: boolean | undefined;
    inputMask: string | undefined;
    slider: number | undefined;
    description: string | undefined;
    inputTextarea: string | undefined;
    integerOnly: number | undefined;
    decimal: number | undefined;
    dateBasic: moment.Moment | undefined;
    dateTime: moment.Moment | undefined;
    dateDisable: moment.Moment | undefined;
    dateMinMax: moment.Moment | undefined;
    dateFrom: moment.Moment | undefined;
    dateTo: moment.Moment | undefined;
    dateMultiple: string | undefined;
    dateMultipleMonth: moment.Moment | undefined;
    monthOnly: moment.Moment | undefined;
    timeOnly: string | undefined;
    autoCompleteSingle: number | undefined;
    autoCompleteMultiple: string | undefined;
    dropdownSingle: number | undefined;
    dropdownMultiple: string | undefined;
    listDemoFile: Demo_File[] | undefined;
    id: number | undefined;
}

export class DemoGetAllInputDto implements IDemoGetAllInputDto {
    keyword: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IDemoGetAllInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyword = _data["keyword"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): DemoGetAllInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DemoGetAllInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyword"] = this.keyword;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): DemoGetAllInputDto {
        const json = this.toJSON();
        let result = new DemoGetAllInputDto();
        result.init(json);
        return result;
    }
}

export interface IDemoGetAllInputDto {
    keyword: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class CanhBao implements ICanhBao {
    tbId: string | undefined;
    tbAlarmType: string | undefined;
    ghiChu: string | undefined;
    tbCreateRules: string | undefined;
    tbClearRule: string | undefined;
    boCanhBaoId: number;
    boCanhBao: BoCanhBao;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ICanhBao) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tbId = _data["tbId"];
            this.tbAlarmType = _data["tbAlarmType"];
            this.ghiChu = _data["ghiChu"];
            this.tbCreateRules = _data["tbCreateRules"];
            this.tbClearRule = _data["tbClearRule"];
            this.boCanhBaoId = _data["boCanhBaoId"];
            this.boCanhBao = _data["boCanhBao"] ? BoCanhBao.fromJS(_data["boCanhBao"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CanhBao {
        data = typeof data === 'object' ? data : {};
        let result = new CanhBao();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tbId"] = this.tbId;
        data["tbAlarmType"] = this.tbAlarmType;
        data["ghiChu"] = this.ghiChu;
        data["tbCreateRules"] = this.tbCreateRules;
        data["tbClearRule"] = this.tbClearRule;
        data["boCanhBaoId"] = this.boCanhBaoId;
        data["boCanhBao"] = this.boCanhBao ? this.boCanhBao.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CanhBao {
        const json = this.toJSON();
        let result = new CanhBao();
        result.init(json);
        return result;
    }
}

export interface ICanhBao {
    tbId: string | undefined;
    tbAlarmType: string | undefined;
    ghiChu: string | undefined;
    tbCreateRules: string | undefined;
    tbClearRule: string | undefined;
    boCanhBaoId: number;
    boCanhBao: BoCanhBao;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class BoCanhBao implements IBoCanhBao {
    ten: string | undefined;
    tbId: string | undefined;
    ghiChu: string | undefined;
    canhBao: CanhBao[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IBoCanhBao) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.tbId = _data["tbId"];
            this.ghiChu = _data["ghiChu"];
            if (Array.isArray(_data["canhBao"])) {
                this.canhBao = [] as any;
                for (let item of _data["canhBao"])
                    this.canhBao.push(CanhBao.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BoCanhBao {
        data = typeof data === 'object' ? data : {};
        let result = new BoCanhBao();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["tbId"] = this.tbId;
        data["ghiChu"] = this.ghiChu;
        if (Array.isArray(this.canhBao)) {
            data["canhBao"] = [];
            for (let item of this.canhBao)
                data["canhBao"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): BoCanhBao {
        const json = this.toJSON();
        let result = new BoCanhBao();
        result.init(json);
        return result;
    }
}

export interface IBoCanhBao {
    ten: string | undefined;
    tbId: string | undefined;
    ghiChu: string | undefined;
    canhBao: CanhBao[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class BoCanhBaoPagedResultDto implements IBoCanhBaoPagedResultDto {
    totalCount: number;
    items: BoCanhBao[] | undefined;

    constructor(data?: IBoCanhBaoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(BoCanhBao.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BoCanhBaoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BoCanhBaoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BoCanhBaoPagedResultDto {
        const json = this.toJSON();
        let result = new BoCanhBaoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBoCanhBaoPagedResultDto {
    totalCount: number;
    items: BoCanhBao[] | undefined;
}

export class BoCanhBaoCreateInput implements IBoCanhBaoCreateInput {
    ten: string | undefined;
    tbId: string | undefined;
    ghiChu: string | undefined;
    canhBao: CanhBao[] | undefined;
    id: number | undefined;

    constructor(data?: IBoCanhBaoCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.tbId = _data["tbId"];
            this.ghiChu = _data["ghiChu"];
            if (Array.isArray(_data["canhBao"])) {
                this.canhBao = [] as any;
                for (let item of _data["canhBao"])
                    this.canhBao.push(CanhBao.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BoCanhBaoCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new BoCanhBaoCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["tbId"] = this.tbId;
        data["ghiChu"] = this.ghiChu;
        if (Array.isArray(this.canhBao)) {
            data["canhBao"] = [];
            for (let item of this.canhBao)
                data["canhBao"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): BoCanhBaoCreateInput {
        const json = this.toJSON();
        let result = new BoCanhBaoCreateInput();
        result.init(json);
        return result;
    }
}

export interface IBoCanhBaoCreateInput {
    ten: string | undefined;
    tbId: string | undefined;
    ghiChu: string | undefined;
    canhBao: CanhBao[] | undefined;
    id: number | undefined;
}

export class CanhBaoPagedResultDto implements ICanhBaoPagedResultDto {
    totalCount: number;
    items: CanhBao[] | undefined;

    constructor(data?: ICanhBaoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CanhBao.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CanhBaoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CanhBaoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CanhBaoPagedResultDto {
        const json = this.toJSON();
        let result = new CanhBaoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICanhBaoPagedResultDto {
    totalCount: number;
    items: CanhBao[] | undefined;
}

export class CanhBaoCreateInput implements ICanhBaoCreateInput {
    tbId: string | undefined;
    tbAlarmType: string | undefined;
    ghiChu: string | undefined;
    tbCreateRules: string | undefined;
    tbClearRule: string | undefined;
    boCanhBaoId: number;
    boCanhBao: BoCanhBao;
    id: number | undefined;

    constructor(data?: ICanhBaoCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tbId = _data["tbId"];
            this.tbAlarmType = _data["tbAlarmType"];
            this.ghiChu = _data["ghiChu"];
            this.tbCreateRules = _data["tbCreateRules"];
            this.tbClearRule = _data["tbClearRule"];
            this.boCanhBaoId = _data["boCanhBaoId"];
            this.boCanhBao = _data["boCanhBao"] ? BoCanhBao.fromJS(_data["boCanhBao"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CanhBaoCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new CanhBaoCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tbId"] = this.tbId;
        data["tbAlarmType"] = this.tbAlarmType;
        data["ghiChu"] = this.ghiChu;
        data["tbCreateRules"] = this.tbCreateRules;
        data["tbClearRule"] = this.tbClearRule;
        data["boCanhBaoId"] = this.boCanhBaoId;
        data["boCanhBao"] = this.boCanhBao ? this.boCanhBao.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): CanhBaoCreateInput {
        const json = this.toJSON();
        let result = new CanhBaoCreateInput();
        result.init(json);
        return result;
    }
}

export interface ICanhBaoCreateInput {
    tbId: string | undefined;
    tbAlarmType: string | undefined;
    ghiChu: string | undefined;
    tbCreateRules: string | undefined;
    tbClearRule: string | undefined;
    boCanhBaoId: number;
    boCanhBao: BoCanhBao;
    id: number | undefined;
}

export class MauCanhBao implements IMauCanhBao {
    ten: string | undefined;
    maMau: string | undefined;
    ghiChu: string | undefined;
    mauCanhBaoThuocTinh: MauCanhBaoThuocTinh[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IMauCanhBao) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.maMau = _data["maMau"];
            this.ghiChu = _data["ghiChu"];
            if (Array.isArray(_data["mauCanhBaoThuocTinh"])) {
                this.mauCanhBaoThuocTinh = [] as any;
                for (let item of _data["mauCanhBaoThuocTinh"])
                    this.mauCanhBaoThuocTinh.push(MauCanhBaoThuocTinh.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MauCanhBao {
        data = typeof data === 'object' ? data : {};
        let result = new MauCanhBao();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["maMau"] = this.maMau;
        data["ghiChu"] = this.ghiChu;
        if (Array.isArray(this.mauCanhBaoThuocTinh)) {
            data["mauCanhBaoThuocTinh"] = [];
            for (let item of this.mauCanhBaoThuocTinh)
                data["mauCanhBaoThuocTinh"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MauCanhBao {
        const json = this.toJSON();
        let result = new MauCanhBao();
        result.init(json);
        return result;
    }
}

export interface IMauCanhBao {
    ten: string | undefined;
    maMau: string | undefined;
    ghiChu: string | undefined;
    mauCanhBaoThuocTinh: MauCanhBaoThuocTinh[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum KieuDuLieu {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export class MauDieuKhien implements IMauDieuKhien {
    ten: string | undefined;
    maMau: string | undefined;
    ghiChu: string | undefined;
    mauDieuKhienThuocTinh: MauDieuKhienThuocTinh[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IMauDieuKhien) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.maMau = _data["maMau"];
            this.ghiChu = _data["ghiChu"];
            if (Array.isArray(_data["mauDieuKhienThuocTinh"])) {
                this.mauDieuKhienThuocTinh = [] as any;
                for (let item of _data["mauDieuKhienThuocTinh"])
                    this.mauDieuKhienThuocTinh.push(MauDieuKhienThuocTinh.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MauDieuKhien {
        data = typeof data === 'object' ? data : {};
        let result = new MauDieuKhien();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["maMau"] = this.maMau;
        data["ghiChu"] = this.ghiChu;
        if (Array.isArray(this.mauDieuKhienThuocTinh)) {
            data["mauDieuKhienThuocTinh"] = [];
            for (let item of this.mauDieuKhienThuocTinh)
                data["mauDieuKhienThuocTinh"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MauDieuKhien {
        const json = this.toJSON();
        let result = new MauDieuKhien();
        result.init(json);
        return result;
    }
}

export interface IMauDieuKhien {
    ten: string | undefined;
    maMau: string | undefined;
    ghiChu: string | undefined;
    mauDieuKhienThuocTinh: MauDieuKhienThuocTinh[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class MauDieuKhienThuocTinh implements IMauDieuKhienThuocTinh {
    mauDieuKhienId: number;
    mauDieuKhien: MauDieuKhien;
    mauThuocTinhId: number;
    mauThuocTinh: MauThuocTinh;
    boolValue: boolean | undefined;
    stringValue: string | undefined;
    longValue: number | undefined;
    doubleValue: number | undefined;
    jsonValue: string | undefined;

    constructor(data?: IMauDieuKhienThuocTinh) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mauDieuKhienId = _data["mauDieuKhienId"];
            this.mauDieuKhien = _data["mauDieuKhien"] ? MauDieuKhien.fromJS(_data["mauDieuKhien"]) : <any>undefined;
            this.mauThuocTinhId = _data["mauThuocTinhId"];
            this.mauThuocTinh = _data["mauThuocTinh"] ? MauThuocTinh.fromJS(_data["mauThuocTinh"]) : <any>undefined;
            this.boolValue = _data["boolValue"];
            this.stringValue = _data["stringValue"];
            this.longValue = _data["longValue"];
            this.doubleValue = _data["doubleValue"];
            this.jsonValue = _data["jsonValue"];
        }
    }

    static fromJS(data: any): MauDieuKhienThuocTinh {
        data = typeof data === 'object' ? data : {};
        let result = new MauDieuKhienThuocTinh();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mauDieuKhienId"] = this.mauDieuKhienId;
        data["mauDieuKhien"] = this.mauDieuKhien ? this.mauDieuKhien.toJSON() : <any>undefined;
        data["mauThuocTinhId"] = this.mauThuocTinhId;
        data["mauThuocTinh"] = this.mauThuocTinh ? this.mauThuocTinh.toJSON() : <any>undefined;
        data["boolValue"] = this.boolValue;
        data["stringValue"] = this.stringValue;
        data["longValue"] = this.longValue;
        data["doubleValue"] = this.doubleValue;
        data["jsonValue"] = this.jsonValue;
        return data; 
    }

    clone(): MauDieuKhienThuocTinh {
        const json = this.toJSON();
        let result = new MauDieuKhienThuocTinh();
        result.init(json);
        return result;
    }
}

export interface IMauDieuKhienThuocTinh {
    mauDieuKhienId: number;
    mauDieuKhien: MauDieuKhien;
    mauThuocTinhId: number;
    mauThuocTinh: MauThuocTinh;
    boolValue: boolean | undefined;
    stringValue: string | undefined;
    longValue: number | undefined;
    doubleValue: number | undefined;
    jsonValue: string | undefined;
}

export class MauThuocTinh implements IMauThuocTinh {
    ten: string | undefined;
    tenHienThi: string | undefined;
    kieuDuLieu: KieuDuLieu;
    ghiChu: string | undefined;
    mauDieuKhienThuocTinh: MauDieuKhienThuocTinh[] | undefined;
    mauCanhBaoThuocTinh: MauCanhBaoThuocTinh[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IMauThuocTinh) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.tenHienThi = _data["tenHienThi"];
            this.kieuDuLieu = _data["kieuDuLieu"];
            this.ghiChu = _data["ghiChu"];
            if (Array.isArray(_data["mauDieuKhienThuocTinh"])) {
                this.mauDieuKhienThuocTinh = [] as any;
                for (let item of _data["mauDieuKhienThuocTinh"])
                    this.mauDieuKhienThuocTinh.push(MauDieuKhienThuocTinh.fromJS(item));
            }
            if (Array.isArray(_data["mauCanhBaoThuocTinh"])) {
                this.mauCanhBaoThuocTinh = [] as any;
                for (let item of _data["mauCanhBaoThuocTinh"])
                    this.mauCanhBaoThuocTinh.push(MauCanhBaoThuocTinh.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MauThuocTinh {
        data = typeof data === 'object' ? data : {};
        let result = new MauThuocTinh();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["tenHienThi"] = this.tenHienThi;
        data["kieuDuLieu"] = this.kieuDuLieu;
        data["ghiChu"] = this.ghiChu;
        if (Array.isArray(this.mauDieuKhienThuocTinh)) {
            data["mauDieuKhienThuocTinh"] = [];
            for (let item of this.mauDieuKhienThuocTinh)
                data["mauDieuKhienThuocTinh"].push(item.toJSON());
        }
        if (Array.isArray(this.mauCanhBaoThuocTinh)) {
            data["mauCanhBaoThuocTinh"] = [];
            for (let item of this.mauCanhBaoThuocTinh)
                data["mauCanhBaoThuocTinh"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MauThuocTinh {
        const json = this.toJSON();
        let result = new MauThuocTinh();
        result.init(json);
        return result;
    }
}

export interface IMauThuocTinh {
    ten: string | undefined;
    tenHienThi: string | undefined;
    kieuDuLieu: KieuDuLieu;
    ghiChu: string | undefined;
    mauDieuKhienThuocTinh: MauDieuKhienThuocTinh[] | undefined;
    mauCanhBaoThuocTinh: MauCanhBaoThuocTinh[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class MauCanhBaoThuocTinh implements IMauCanhBaoThuocTinh {
    mauCanhBaoId: number;
    mauCanhBao: MauCanhBao;
    mauThuocTinhId: number;
    mauThuocTinh: MauThuocTinh;
    boolValue: boolean | undefined;
    stringValue: string | undefined;
    longValue: number | undefined;
    doubleValue: number | undefined;
    jsonValue: string | undefined;

    constructor(data?: IMauCanhBaoThuocTinh) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mauCanhBaoId = _data["mauCanhBaoId"];
            this.mauCanhBao = _data["mauCanhBao"] ? MauCanhBao.fromJS(_data["mauCanhBao"]) : <any>undefined;
            this.mauThuocTinhId = _data["mauThuocTinhId"];
            this.mauThuocTinh = _data["mauThuocTinh"] ? MauThuocTinh.fromJS(_data["mauThuocTinh"]) : <any>undefined;
            this.boolValue = _data["boolValue"];
            this.stringValue = _data["stringValue"];
            this.longValue = _data["longValue"];
            this.doubleValue = _data["doubleValue"];
            this.jsonValue = _data["jsonValue"];
        }
    }

    static fromJS(data: any): MauCanhBaoThuocTinh {
        data = typeof data === 'object' ? data : {};
        let result = new MauCanhBaoThuocTinh();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mauCanhBaoId"] = this.mauCanhBaoId;
        data["mauCanhBao"] = this.mauCanhBao ? this.mauCanhBao.toJSON() : <any>undefined;
        data["mauThuocTinhId"] = this.mauThuocTinhId;
        data["mauThuocTinh"] = this.mauThuocTinh ? this.mauThuocTinh.toJSON() : <any>undefined;
        data["boolValue"] = this.boolValue;
        data["stringValue"] = this.stringValue;
        data["longValue"] = this.longValue;
        data["doubleValue"] = this.doubleValue;
        data["jsonValue"] = this.jsonValue;
        return data; 
    }

    clone(): MauCanhBaoThuocTinh {
        const json = this.toJSON();
        let result = new MauCanhBaoThuocTinh();
        result.init(json);
        return result;
    }
}

export interface IMauCanhBaoThuocTinh {
    mauCanhBaoId: number;
    mauCanhBao: MauCanhBao;
    mauThuocTinhId: number;
    mauThuocTinh: MauThuocTinh;
    boolValue: boolean | undefined;
    stringValue: string | undefined;
    longValue: number | undefined;
    doubleValue: number | undefined;
    jsonValue: string | undefined;
}

export class MauCanhBaoDto implements IMauCanhBaoDto {
    ten: string | undefined;
    maMau: string | undefined;
    ghiChu: string | undefined;
    mauCanhBaoThuocTinh: MauCanhBaoThuocTinh[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IMauCanhBaoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.maMau = _data["maMau"];
            this.ghiChu = _data["ghiChu"];
            if (Array.isArray(_data["mauCanhBaoThuocTinh"])) {
                this.mauCanhBaoThuocTinh = [] as any;
                for (let item of _data["mauCanhBaoThuocTinh"])
                    this.mauCanhBaoThuocTinh.push(MauCanhBaoThuocTinh.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MauCanhBaoDto {
        data = typeof data === 'object' ? data : {};
        let result = new MauCanhBaoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["maMau"] = this.maMau;
        data["ghiChu"] = this.ghiChu;
        if (Array.isArray(this.mauCanhBaoThuocTinh)) {
            data["mauCanhBaoThuocTinh"] = [];
            for (let item of this.mauCanhBaoThuocTinh)
                data["mauCanhBaoThuocTinh"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MauCanhBaoDto {
        const json = this.toJSON();
        let result = new MauCanhBaoDto();
        result.init(json);
        return result;
    }
}

export interface IMauCanhBaoDto {
    ten: string | undefined;
    maMau: string | undefined;
    ghiChu: string | undefined;
    mauCanhBaoThuocTinh: MauCanhBaoThuocTinh[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class MauCanhBaoDtoPagedResultDto implements IMauCanhBaoDtoPagedResultDto {
    totalCount: number;
    items: MauCanhBaoDto[] | undefined;

    constructor(data?: IMauCanhBaoDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MauCanhBaoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MauCanhBaoDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MauCanhBaoDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): MauCanhBaoDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MauCanhBaoDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMauCanhBaoDtoPagedResultDto {
    totalCount: number;
    items: MauCanhBaoDto[] | undefined;
}

export class CreateOrEditMauCanhBao implements ICreateOrEditMauCanhBao {
    ten: string | undefined;
    maMau: string | undefined;
    ghiChu: string | undefined;
    mauCanhBaoThuocTinh: MauCanhBaoThuocTinh[] | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditMauCanhBao) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.maMau = _data["maMau"];
            this.ghiChu = _data["ghiChu"];
            if (Array.isArray(_data["mauCanhBaoThuocTinh"])) {
                this.mauCanhBaoThuocTinh = [] as any;
                for (let item of _data["mauCanhBaoThuocTinh"])
                    this.mauCanhBaoThuocTinh.push(MauCanhBaoThuocTinh.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMauCanhBao {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMauCanhBao();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["maMau"] = this.maMau;
        data["ghiChu"] = this.ghiChu;
        if (Array.isArray(this.mauCanhBaoThuocTinh)) {
            data["mauCanhBaoThuocTinh"] = [];
            for (let item of this.mauCanhBaoThuocTinh)
                data["mauCanhBaoThuocTinh"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditMauCanhBao {
        const json = this.toJSON();
        let result = new CreateOrEditMauCanhBao();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditMauCanhBao {
    ten: string | undefined;
    maMau: string | undefined;
    ghiChu: string | undefined;
    mauCanhBaoThuocTinh: MauCanhBaoThuocTinh[] | undefined;
    id: number | undefined;
}

export class MauDieuKhienDto implements IMauDieuKhienDto {
    ten: string | undefined;
    maMau: string | undefined;
    ghiChu: string | undefined;
    mauDieuKhienThuocTinh: MauDieuKhienThuocTinh[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IMauDieuKhienDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.maMau = _data["maMau"];
            this.ghiChu = _data["ghiChu"];
            if (Array.isArray(_data["mauDieuKhienThuocTinh"])) {
                this.mauDieuKhienThuocTinh = [] as any;
                for (let item of _data["mauDieuKhienThuocTinh"])
                    this.mauDieuKhienThuocTinh.push(MauDieuKhienThuocTinh.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MauDieuKhienDto {
        data = typeof data === 'object' ? data : {};
        let result = new MauDieuKhienDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["maMau"] = this.maMau;
        data["ghiChu"] = this.ghiChu;
        if (Array.isArray(this.mauDieuKhienThuocTinh)) {
            data["mauDieuKhienThuocTinh"] = [];
            for (let item of this.mauDieuKhienThuocTinh)
                data["mauDieuKhienThuocTinh"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MauDieuKhienDto {
        const json = this.toJSON();
        let result = new MauDieuKhienDto();
        result.init(json);
        return result;
    }
}

export interface IMauDieuKhienDto {
    ten: string | undefined;
    maMau: string | undefined;
    ghiChu: string | undefined;
    mauDieuKhienThuocTinh: MauDieuKhienThuocTinh[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class MauDieuKhienDtoPagedResultDto implements IMauDieuKhienDtoPagedResultDto {
    totalCount: number;
    items: MauDieuKhienDto[] | undefined;

    constructor(data?: IMauDieuKhienDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MauDieuKhienDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MauDieuKhienDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MauDieuKhienDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): MauDieuKhienDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MauDieuKhienDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMauDieuKhienDtoPagedResultDto {
    totalCount: number;
    items: MauDieuKhienDto[] | undefined;
}

export class CreateOrEditMauDieuKhien implements ICreateOrEditMauDieuKhien {
    ten: string | undefined;
    maMau: string | undefined;
    ghiChu: string | undefined;
    mauDieuKhienThuocTinh: MauDieuKhienThuocTinh[] | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditMauDieuKhien) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.maMau = _data["maMau"];
            this.ghiChu = _data["ghiChu"];
            if (Array.isArray(_data["mauDieuKhienThuocTinh"])) {
                this.mauDieuKhienThuocTinh = [] as any;
                for (let item of _data["mauDieuKhienThuocTinh"])
                    this.mauDieuKhienThuocTinh.push(MauDieuKhienThuocTinh.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMauDieuKhien {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMauDieuKhien();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["maMau"] = this.maMau;
        data["ghiChu"] = this.ghiChu;
        if (Array.isArray(this.mauDieuKhienThuocTinh)) {
            data["mauDieuKhienThuocTinh"] = [];
            for (let item of this.mauDieuKhienThuocTinh)
                data["mauDieuKhienThuocTinh"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditMauDieuKhien {
        const json = this.toJSON();
        let result = new CreateOrEditMauDieuKhien();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditMauDieuKhien {
    ten: string | undefined;
    maMau: string | undefined;
    ghiChu: string | undefined;
    mauDieuKhienThuocTinh: MauDieuKhienThuocTinh[] | undefined;
    id: number | undefined;
}

export class MauDuLieuCamBienDto implements IMauDuLieuCamBienDto {
    ten: string | undefined;
    tenHienThi: string | undefined;
    kieuDuLieu: KieuDuLieu;
    kieuDuLieuHienthi: string | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IMauDuLieuCamBienDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.tenHienThi = _data["tenHienThi"];
            this.kieuDuLieu = _data["kieuDuLieu"];
            this.kieuDuLieuHienthi = _data["kieuDuLieuHienthi"];
            this.ghiChu = _data["ghiChu"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MauDuLieuCamBienDto {
        data = typeof data === 'object' ? data : {};
        let result = new MauDuLieuCamBienDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["tenHienThi"] = this.tenHienThi;
        data["kieuDuLieu"] = this.kieuDuLieu;
        data["kieuDuLieuHienthi"] = this.kieuDuLieuHienthi;
        data["ghiChu"] = this.ghiChu;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MauDuLieuCamBienDto {
        const json = this.toJSON();
        let result = new MauDuLieuCamBienDto();
        result.init(json);
        return result;
    }
}

export interface IMauDuLieuCamBienDto {
    ten: string | undefined;
    tenHienThi: string | undefined;
    kieuDuLieu: KieuDuLieu;
    kieuDuLieuHienthi: string | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class MauDuLieuCamBienDtoPagedResultDto implements IMauDuLieuCamBienDtoPagedResultDto {
    totalCount: number;
    items: MauDuLieuCamBienDto[] | undefined;

    constructor(data?: IMauDuLieuCamBienDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MauDuLieuCamBienDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MauDuLieuCamBienDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MauDuLieuCamBienDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): MauDuLieuCamBienDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MauDuLieuCamBienDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMauDuLieuCamBienDtoPagedResultDto {
    totalCount: number;
    items: MauDuLieuCamBienDto[] | undefined;
}

export class CreateOrEditMauDuLieuCamBienDto implements ICreateOrEditMauDuLieuCamBienDto {
    ten: string | undefined;
    tenHienThi: string | undefined;
    kieuDuLieu: KieuDuLieu;
    ghiChu: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditMauDuLieuCamBienDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.tenHienThi = _data["tenHienThi"];
            this.kieuDuLieu = _data["kieuDuLieu"];
            this.ghiChu = _data["ghiChu"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMauDuLieuCamBienDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMauDuLieuCamBienDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["tenHienThi"] = this.tenHienThi;
        data["kieuDuLieu"] = this.kieuDuLieu;
        data["ghiChu"] = this.ghiChu;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditMauDuLieuCamBienDto {
        const json = this.toJSON();
        let result = new CreateOrEditMauDuLieuCamBienDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditMauDuLieuCamBienDto {
    ten: string | undefined;
    tenHienThi: string | undefined;
    kieuDuLieu: KieuDuLieu;
    ghiChu: string | undefined;
    id: number | undefined;
}

export class KieuDuLieuLookupTable implements IKieuDuLieuLookupTable {
    id: number;
    displayName: string | undefined;
    kieuDuLieu: KieuDuLieu;
    disabled: boolean | undefined;
    ten: string | undefined;
    tenHienThi: string | undefined;

    constructor(data?: IKieuDuLieuLookupTable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.kieuDuLieu = _data["kieuDuLieu"];
            this.disabled = _data["disabled"];
            this.ten = _data["ten"];
            this.tenHienThi = _data["tenHienThi"];
        }
    }

    static fromJS(data: any): KieuDuLieuLookupTable {
        data = typeof data === 'object' ? data : {};
        let result = new KieuDuLieuLookupTable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["kieuDuLieu"] = this.kieuDuLieu;
        data["disabled"] = this.disabled;
        data["ten"] = this.ten;
        data["tenHienThi"] = this.tenHienThi;
        return data; 
    }

    clone(): KieuDuLieuLookupTable {
        const json = this.toJSON();
        let result = new KieuDuLieuLookupTable();
        result.init(json);
        return result;
    }
}

export interface IKieuDuLieuLookupTable {
    id: number;
    displayName: string | undefined;
    kieuDuLieu: KieuDuLieu;
    disabled: boolean | undefined;
    ten: string | undefined;
    tenHienThi: string | undefined;
}

export class MauThuocTinhDto implements IMauThuocTinhDto {
    ten: string | undefined;
    tenHienThi: string | undefined;
    kieuDuLieu: KieuDuLieu;
    kieuDuLieuString: string | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IMauThuocTinhDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.tenHienThi = _data["tenHienThi"];
            this.kieuDuLieu = _data["kieuDuLieu"];
            this.kieuDuLieuString = _data["kieuDuLieuString"];
            this.ghiChu = _data["ghiChu"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MauThuocTinhDto {
        data = typeof data === 'object' ? data : {};
        let result = new MauThuocTinhDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["tenHienThi"] = this.tenHienThi;
        data["kieuDuLieu"] = this.kieuDuLieu;
        data["kieuDuLieuString"] = this.kieuDuLieuString;
        data["ghiChu"] = this.ghiChu;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MauThuocTinhDto {
        const json = this.toJSON();
        let result = new MauThuocTinhDto();
        result.init(json);
        return result;
    }
}

export interface IMauThuocTinhDto {
    ten: string | undefined;
    tenHienThi: string | undefined;
    kieuDuLieu: KieuDuLieu;
    kieuDuLieuString: string | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class MauThuocTinhDtoPagedResultDto implements IMauThuocTinhDtoPagedResultDto {
    totalCount: number;
    items: MauThuocTinhDto[] | undefined;

    constructor(data?: IMauThuocTinhDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MauThuocTinhDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MauThuocTinhDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MauThuocTinhDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): MauThuocTinhDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MauThuocTinhDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMauThuocTinhDtoPagedResultDto {
    totalCount: number;
    items: MauThuocTinhDto[] | undefined;
}

export class CreateOrEditMauThuocTinhDto implements ICreateOrEditMauThuocTinhDto {
    ten: string | undefined;
    tenHienThi: string | undefined;
    kieuDuLieu: KieuDuLieu;
    ghiChu: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditMauThuocTinhDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.tenHienThi = _data["tenHienThi"];
            this.kieuDuLieu = _data["kieuDuLieu"];
            this.ghiChu = _data["ghiChu"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMauThuocTinhDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMauThuocTinhDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["tenHienThi"] = this.tenHienThi;
        data["kieuDuLieu"] = this.kieuDuLieu;
        data["ghiChu"] = this.ghiChu;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditMauThuocTinhDto {
        const json = this.toJSON();
        let result = new CreateOrEditMauThuocTinhDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditMauThuocTinhDto {
    ten: string | undefined;
    tenHienThi: string | undefined;
    kieuDuLieu: KieuDuLieu;
    ghiChu: string | undefined;
    id: number | undefined;
}

export class NguoiNhanCanhBaoDto implements INguoiNhanCanhBaoDto {
    ten: string | undefined;
    email: string | undefined;
    sdt: string | undefined;
    ghiChu: string | undefined;
    id: number;

    constructor(data?: INguoiNhanCanhBaoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.email = _data["email"];
            this.sdt = _data["sdt"];
            this.ghiChu = _data["ghiChu"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NguoiNhanCanhBaoDto {
        data = typeof data === 'object' ? data : {};
        let result = new NguoiNhanCanhBaoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["email"] = this.email;
        data["sdt"] = this.sdt;
        data["ghiChu"] = this.ghiChu;
        data["id"] = this.id;
        return data; 
    }

    clone(): NguoiNhanCanhBaoDto {
        const json = this.toJSON();
        let result = new NguoiNhanCanhBaoDto();
        result.init(json);
        return result;
    }
}

export interface INguoiNhanCanhBaoDto {
    ten: string | undefined;
    email: string | undefined;
    sdt: string | undefined;
    ghiChu: string | undefined;
    id: number;
}

export class NguoiNhanCanhBaoDtoPagedResultDto implements INguoiNhanCanhBaoDtoPagedResultDto {
    totalCount: number;
    items: NguoiNhanCanhBaoDto[] | undefined;

    constructor(data?: INguoiNhanCanhBaoDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(NguoiNhanCanhBaoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NguoiNhanCanhBaoDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NguoiNhanCanhBaoDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): NguoiNhanCanhBaoDtoPagedResultDto {
        const json = this.toJSON();
        let result = new NguoiNhanCanhBaoDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface INguoiNhanCanhBaoDtoPagedResultDto {
    totalCount: number;
    items: NguoiNhanCanhBaoDto[] | undefined;
}

export class NguoiNhanCanhBaoCreateInput implements INguoiNhanCanhBaoCreateInput {
    ten: string;
    email: string;
    sdt: string;
    ghiChu: string | undefined;
    id: number | undefined;

    constructor(data?: INguoiNhanCanhBaoCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.email = _data["email"];
            this.sdt = _data["sdt"];
            this.ghiChu = _data["ghiChu"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NguoiNhanCanhBaoCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new NguoiNhanCanhBaoCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["email"] = this.email;
        data["sdt"] = this.sdt;
        data["ghiChu"] = this.ghiChu;
        data["id"] = this.id;
        return data; 
    }

    clone(): NguoiNhanCanhBaoCreateInput {
        const json = this.toJSON();
        let result = new NguoiNhanCanhBaoCreateInput();
        result.init(json);
        return result;
    }
}

export interface INguoiNhanCanhBaoCreateInput {
    ten: string;
    email: string;
    sdt: string;
    ghiChu: string | undefined;
    id: number | undefined;
}

export class EmailToSendInput implements IEmailToSendInput {
    tramId: number;
    idCanhBao: string | undefined;
    emails: string[];
    subject: string;
    body: string;
    isBodyHtml: boolean;

    constructor(data?: IEmailToSendInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.emails = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tramId = _data["tramId"];
            this.idCanhBao = _data["idCanhBao"];
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails.push(item);
            }
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.isBodyHtml = _data["isBodyHtml"];
        }
    }

    static fromJS(data: any): EmailToSendInput {
        data = typeof data === 'object' ? data : {};
        let result = new EmailToSendInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tramId"] = this.tramId;
        data["idCanhBao"] = this.idCanhBao;
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["isBodyHtml"] = this.isBodyHtml;
        return data; 
    }

    clone(): EmailToSendInput {
        const json = this.toJSON();
        let result = new EmailToSendInput();
        result.init(json);
        return result;
    }
}

export interface IEmailToSendInput {
    tramId: number;
    idCanhBao: string | undefined;
    emails: string[];
    subject: string;
    body: string;
    isBodyHtml: boolean;
}

export class NhanVienRaVaoTramDto implements INhanVienRaVaoTramDto {
    maNhanVien: string | undefined;
    maThe: string | undefined;
    ten: string | undefined;
    email: string | undefined;
    sdt: string | undefined;
    diaChi: string | undefined;
    ghiChu: string | undefined;
    passWord: string | undefined;
    id: number;

    constructor(data?: INhanVienRaVaoTramDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maNhanVien = _data["maNhanVien"];
            this.maThe = _data["maThe"];
            this.ten = _data["ten"];
            this.email = _data["email"];
            this.sdt = _data["sdt"];
            this.diaChi = _data["diaChi"];
            this.ghiChu = _data["ghiChu"];
            this.passWord = _data["passWord"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NhanVienRaVaoTramDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhanVienRaVaoTramDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maNhanVien"] = this.maNhanVien;
        data["maThe"] = this.maThe;
        data["ten"] = this.ten;
        data["email"] = this.email;
        data["sdt"] = this.sdt;
        data["diaChi"] = this.diaChi;
        data["ghiChu"] = this.ghiChu;
        data["passWord"] = this.passWord;
        data["id"] = this.id;
        return data; 
    }

    clone(): NhanVienRaVaoTramDto {
        const json = this.toJSON();
        let result = new NhanVienRaVaoTramDto();
        result.init(json);
        return result;
    }
}

export interface INhanVienRaVaoTramDto {
    maNhanVien: string | undefined;
    maThe: string | undefined;
    ten: string | undefined;
    email: string | undefined;
    sdt: string | undefined;
    diaChi: string | undefined;
    ghiChu: string | undefined;
    passWord: string | undefined;
    id: number;
}

export class NhanVienRaVaoTramDtoPagedResultDto implements INhanVienRaVaoTramDtoPagedResultDto {
    totalCount: number;
    items: NhanVienRaVaoTramDto[] | undefined;

    constructor(data?: INhanVienRaVaoTramDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(NhanVienRaVaoTramDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NhanVienRaVaoTramDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhanVienRaVaoTramDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): NhanVienRaVaoTramDtoPagedResultDto {
        const json = this.toJSON();
        let result = new NhanVienRaVaoTramDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface INhanVienRaVaoTramDtoPagedResultDto {
    totalCount: number;
    items: NhanVienRaVaoTramDto[] | undefined;
}

export class NhanVienRaVaoTramGetByTramIdOutputDto implements INhanVienRaVaoTramGetByTramIdOutputDto {
    maNhanVien: string | undefined;
    ten: string | undefined;
    maThe: string | undefined;
    email: string | undefined;
    sdt: string | undefined;
    chucVu: string | undefined;
    idNhanVien: number;
    idTram: number;
    chucVuNumber: number;

    constructor(data?: INhanVienRaVaoTramGetByTramIdOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maNhanVien = _data["maNhanVien"];
            this.ten = _data["ten"];
            this.maThe = _data["maThe"];
            this.email = _data["email"];
            this.sdt = _data["sdt"];
            this.chucVu = _data["chucVu"];
            this.idNhanVien = _data["idNhanVien"];
            this.idTram = _data["idTram"];
            this.chucVuNumber = _data["chucVuNumber"];
        }
    }

    static fromJS(data: any): NhanVienRaVaoTramGetByTramIdOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhanVienRaVaoTramGetByTramIdOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maNhanVien"] = this.maNhanVien;
        data["ten"] = this.ten;
        data["maThe"] = this.maThe;
        data["email"] = this.email;
        data["sdt"] = this.sdt;
        data["chucVu"] = this.chucVu;
        data["idNhanVien"] = this.idNhanVien;
        data["idTram"] = this.idTram;
        data["chucVuNumber"] = this.chucVuNumber;
        return data; 
    }

    clone(): NhanVienRaVaoTramGetByTramIdOutputDto {
        const json = this.toJSON();
        let result = new NhanVienRaVaoTramGetByTramIdOutputDto();
        result.init(json);
        return result;
    }
}

export interface INhanVienRaVaoTramGetByTramIdOutputDto {
    maNhanVien: string | undefined;
    ten: string | undefined;
    maThe: string | undefined;
    email: string | undefined;
    sdt: string | undefined;
    chucVu: string | undefined;
    idNhanVien: number;
    idTram: number;
    chucVuNumber: number;
}

export class NhanVienRaVaoTramGetByTramIdOutputDtoPagedResultDto implements INhanVienRaVaoTramGetByTramIdOutputDtoPagedResultDto {
    totalCount: number;
    items: NhanVienRaVaoTramGetByTramIdOutputDto[] | undefined;

    constructor(data?: INhanVienRaVaoTramGetByTramIdOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(NhanVienRaVaoTramGetByTramIdOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NhanVienRaVaoTramGetByTramIdOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhanVienRaVaoTramGetByTramIdOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): NhanVienRaVaoTramGetByTramIdOutputDtoPagedResultDto {
        const json = this.toJSON();
        let result = new NhanVienRaVaoTramGetByTramIdOutputDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface INhanVienRaVaoTramGetByTramIdOutputDtoPagedResultDto {
    totalCount: number;
    items: NhanVienRaVaoTramGetByTramIdOutputDto[] | undefined;
}

export class TramNhanVienDto implements ITramNhanVienDto {
    tenTram: string | undefined;
    chucVu: string | undefined;

    constructor(data?: ITramNhanVienDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenTram = _data["tenTram"];
            this.chucVu = _data["chucVu"];
        }
    }

    static fromJS(data: any): TramNhanVienDto {
        data = typeof data === 'object' ? data : {};
        let result = new TramNhanVienDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenTram"] = this.tenTram;
        data["chucVu"] = this.chucVu;
        return data; 
    }

    clone(): TramNhanVienDto {
        const json = this.toJSON();
        let result = new TramNhanVienDto();
        result.init(json);
        return result;
    }
}

export interface ITramNhanVienDto {
    tenTram: string | undefined;
    chucVu: string | undefined;
}

export class NhanVienRaVaoTram implements INhanVienRaVaoTram {
    maNhanVien: string | undefined;
    maThe: string | undefined;
    ten: string | undefined;
    email: string | undefined;
    sdt: string | undefined;
    diaChi: string | undefined;
    ghiChu: string | undefined;
    passWord: string | undefined;
    urlAvatar: string | undefined;
    tramNhanVien: TramNhanVien[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: INhanVienRaVaoTram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maNhanVien = _data["maNhanVien"];
            this.maThe = _data["maThe"];
            this.ten = _data["ten"];
            this.email = _data["email"];
            this.sdt = _data["sdt"];
            this.diaChi = _data["diaChi"];
            this.ghiChu = _data["ghiChu"];
            this.passWord = _data["passWord"];
            this.urlAvatar = _data["urlAvatar"];
            if (Array.isArray(_data["tramNhanVien"])) {
                this.tramNhanVien = [] as any;
                for (let item of _data["tramNhanVien"])
                    this.tramNhanVien.push(TramNhanVien.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NhanVienRaVaoTram {
        data = typeof data === 'object' ? data : {};
        let result = new NhanVienRaVaoTram();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maNhanVien"] = this.maNhanVien;
        data["maThe"] = this.maThe;
        data["ten"] = this.ten;
        data["email"] = this.email;
        data["sdt"] = this.sdt;
        data["diaChi"] = this.diaChi;
        data["ghiChu"] = this.ghiChu;
        data["passWord"] = this.passWord;
        data["urlAvatar"] = this.urlAvatar;
        if (Array.isArray(this.tramNhanVien)) {
            data["tramNhanVien"] = [];
            for (let item of this.tramNhanVien)
                data["tramNhanVien"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): NhanVienRaVaoTram {
        const json = this.toJSON();
        let result = new NhanVienRaVaoTram();
        result.init(json);
        return result;
    }
}

export interface INhanVienRaVaoTram {
    maNhanVien: string | undefined;
    maThe: string | undefined;
    ten: string | undefined;
    email: string | undefined;
    sdt: string | undefined;
    diaChi: string | undefined;
    ghiChu: string | undefined;
    passWord: string | undefined;
    urlAvatar: string | undefined;
    tramNhanVien: TramNhanVien[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum Ordinates {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _65535 = 65535,
    _65536 = 65536,
    _65539 = 65539,
    _65543 = 65543,
    _131072 = 131072,
    _262144 = 262144,
    _524288 = 524288,
    _1048576 = 1048576,
    _2097152 = 2097152,
    _4194304 = 4194304,
    _8388608 = 8388608,
    _16777216 = 16777216,
    _33554432 = 33554432,
    _67108864 = 67108864,
    _134217728 = 134217728,
    _268435456 = 268435456,
    _536870912 = 536870912,
    _1073741824 = 1073741824,
    __2147483648 = -2147483648,
    __65536 = -65536,
    __1 = -1,
}

export class CoordinateSequence implements ICoordinateSequence {
    readonly dimension: number;
    readonly measures: number;
    readonly spatial: number;
    ordinates: Ordinates;
    readonly hasZ: boolean;
    readonly hasM: boolean;
    readonly zOrdinateIndex: number;
    readonly mOrdinateIndex: number;
    readonly count: number;

    constructor(data?: ICoordinateSequence) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).dimension = _data["dimension"];
            (<any>this).measures = _data["measures"];
            (<any>this).spatial = _data["spatial"];
            this.ordinates = _data["ordinates"];
            (<any>this).hasZ = _data["hasZ"];
            (<any>this).hasM = _data["hasM"];
            (<any>this).zOrdinateIndex = _data["zOrdinateIndex"];
            (<any>this).mOrdinateIndex = _data["mOrdinateIndex"];
            (<any>this).count = _data["count"];
        }
    }

    static fromJS(data: any): CoordinateSequence {
        data = typeof data === 'object' ? data : {};
        let result = new CoordinateSequence();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dimension"] = this.dimension;
        data["measures"] = this.measures;
        data["spatial"] = this.spatial;
        data["ordinates"] = this.ordinates;
        data["hasZ"] = this.hasZ;
        data["hasM"] = this.hasM;
        data["zOrdinateIndex"] = this.zOrdinateIndex;
        data["mOrdinateIndex"] = this.mOrdinateIndex;
        data["count"] = this.count;
        return data; 
    }

    clone(): CoordinateSequence {
        const json = this.toJSON();
        let result = new CoordinateSequence();
        result.init(json);
        return result;
    }
}

export interface ICoordinateSequence {
    dimension: number;
    measures: number;
    spatial: number;
    ordinates: Ordinates;
    hasZ: boolean;
    hasM: boolean;
    zOrdinateIndex: number;
    mOrdinateIndex: number;
    count: number;
}

export class Coordinate implements ICoordinate {
    x: number;
    y: number;
    z: number;
    m: number;
    coordinateValue: Coordinate;

    constructor(data?: ICoordinate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.x = _data["x"];
            this.y = _data["y"];
            this.z = _data["z"];
            this.m = _data["m"];
            this.coordinateValue = _data["coordinateValue"] ? Coordinate.fromJS(_data["coordinateValue"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Coordinate {
        data = typeof data === 'object' ? data : {};
        let result = new Coordinate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["x"] = this.x;
        data["y"] = this.y;
        data["z"] = this.z;
        data["m"] = this.m;
        data["coordinateValue"] = this.coordinateValue ? this.coordinateValue.toJSON() : <any>undefined;
        return data; 
    }

    clone(): Coordinate {
        const json = this.toJSON();
        let result = new Coordinate();
        result.init(json);
        return result;
    }
}

export interface ICoordinate {
    x: number;
    y: number;
    z: number;
    m: number;
    coordinateValue: Coordinate;
}

export enum Dimension {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    __3 = -3,
    __2 = -2,
    __1 = -1,
}

export enum OgcGeometryType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
    _15 = 15,
    _16 = 16,
}

export enum PrecisionModels {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class PrecisionModel implements IPrecisionModel {
    readonly isFloating: boolean;
    readonly maximumSignificantDigits: number;
    scale: number;
    precisionModelType: PrecisionModels;

    constructor(data?: IPrecisionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isFloating = _data["isFloating"];
            (<any>this).maximumSignificantDigits = _data["maximumSignificantDigits"];
            this.scale = _data["scale"];
            this.precisionModelType = _data["precisionModelType"];
        }
    }

    static fromJS(data: any): PrecisionModel {
        data = typeof data === 'object' ? data : {};
        let result = new PrecisionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFloating"] = this.isFloating;
        data["maximumSignificantDigits"] = this.maximumSignificantDigits;
        data["scale"] = this.scale;
        data["precisionModelType"] = this.precisionModelType;
        return data; 
    }

    clone(): PrecisionModel {
        const json = this.toJSON();
        let result = new PrecisionModel();
        result.init(json);
        return result;
    }
}

export interface IPrecisionModel {
    isFloating: boolean;
    maximumSignificantDigits: number;
    scale: number;
    precisionModelType: PrecisionModels;
}

export class CoordinateSequenceFactory implements ICoordinateSequenceFactory {
    ordinates: Ordinates;

    constructor(data?: ICoordinateSequenceFactory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ordinates = _data["ordinates"];
        }
    }

    static fromJS(data: any): CoordinateSequenceFactory {
        data = typeof data === 'object' ? data : {};
        let result = new CoordinateSequenceFactory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ordinates"] = this.ordinates;
        return data; 
    }

    clone(): CoordinateSequenceFactory {
        const json = this.toJSON();
        let result = new CoordinateSequenceFactory();
        result.init(json);
        return result;
    }
}

export interface ICoordinateSequenceFactory {
    ordinates: Ordinates;
}

export class GeometryFactory implements IGeometryFactory {
    precisionModel: PrecisionModel;
    coordinateSequenceFactory: CoordinateSequenceFactory;
    readonly srid: number;

    constructor(data?: IGeometryFactory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.precisionModel = _data["precisionModel"] ? PrecisionModel.fromJS(_data["precisionModel"]) : <any>undefined;
            this.coordinateSequenceFactory = _data["coordinateSequenceFactory"] ? CoordinateSequenceFactory.fromJS(_data["coordinateSequenceFactory"]) : <any>undefined;
            (<any>this).srid = _data["srid"];
        }
    }

    static fromJS(data: any): GeometryFactory {
        data = typeof data === 'object' ? data : {};
        let result = new GeometryFactory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["precisionModel"] = this.precisionModel ? this.precisionModel.toJSON() : <any>undefined;
        data["coordinateSequenceFactory"] = this.coordinateSequenceFactory ? this.coordinateSequenceFactory.toJSON() : <any>undefined;
        data["srid"] = this.srid;
        return data; 
    }

    clone(): GeometryFactory {
        const json = this.toJSON();
        let result = new GeometryFactory();
        result.init(json);
        return result;
    }
}

export interface IGeometryFactory {
    precisionModel: PrecisionModel;
    coordinateSequenceFactory: CoordinateSequenceFactory;
    srid: number;
}

export class Envelope implements IEnvelope {
    readonly isNull: boolean;
    readonly width: number;
    readonly height: number;
    readonly minX: number;
    readonly maxX: number;
    readonly minY: number;
    readonly maxY: number;
    readonly area: number;
    readonly minExtent: number;
    readonly maxExtent: number;
    centre: Coordinate;

    constructor(data?: IEnvelope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isNull = _data["isNull"];
            (<any>this).width = _data["width"];
            (<any>this).height = _data["height"];
            (<any>this).minX = _data["minX"];
            (<any>this).maxX = _data["maxX"];
            (<any>this).minY = _data["minY"];
            (<any>this).maxY = _data["maxY"];
            (<any>this).area = _data["area"];
            (<any>this).minExtent = _data["minExtent"];
            (<any>this).maxExtent = _data["maxExtent"];
            this.centre = _data["centre"] ? Coordinate.fromJS(_data["centre"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Envelope {
        data = typeof data === 'object' ? data : {};
        let result = new Envelope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isNull"] = this.isNull;
        data["width"] = this.width;
        data["height"] = this.height;
        data["minX"] = this.minX;
        data["maxX"] = this.maxX;
        data["minY"] = this.minY;
        data["maxY"] = this.maxY;
        data["area"] = this.area;
        data["minExtent"] = this.minExtent;
        data["maxExtent"] = this.maxExtent;
        data["centre"] = this.centre ? this.centre.toJSON() : <any>undefined;
        return data; 
    }

    clone(): Envelope {
        const json = this.toJSON();
        let result = new Envelope();
        result.init(json);
        return result;
    }
}

export interface IEnvelope {
    isNull: boolean;
    width: number;
    height: number;
    minX: number;
    maxX: number;
    minY: number;
    maxY: number;
    area: number;
    minExtent: number;
    maxExtent: number;
    centre: Coordinate;
}

export class Geometry implements IGeometry {
    factory: GeometryFactory;
    userData: any | undefined;
    srid: number;
    readonly geometryType: string | undefined;
    ogcGeometryType: OgcGeometryType;
    precisionModel: PrecisionModel;
    coordinate: Coordinate;
    readonly coordinates: Coordinate[] | undefined;
    readonly numPoints: number;
    readonly numGeometries: number;
    readonly isSimple: boolean;
    readonly isValid: boolean;
    readonly isEmpty: boolean;
    readonly area: number;
    readonly length: number;
    centroid: Point;
    interiorPoint: Point;
    pointOnSurface: Point;
    dimension: Dimension;
    boundary: Geometry;
    boundaryDimension: Dimension;
    envelope: Geometry;
    envelopeInternal: Envelope;
    readonly isRectangle: boolean;

    constructor(data?: IGeometry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.factory = _data["factory"] ? GeometryFactory.fromJS(_data["factory"]) : <any>undefined;
            this.userData = _data["userData"];
            this.srid = _data["srid"];
            (<any>this).geometryType = _data["geometryType"];
            this.ogcGeometryType = _data["ogcGeometryType"];
            this.precisionModel = _data["precisionModel"] ? PrecisionModel.fromJS(_data["precisionModel"]) : <any>undefined;
            this.coordinate = _data["coordinate"] ? Coordinate.fromJS(_data["coordinate"]) : <any>undefined;
            if (Array.isArray(_data["coordinates"])) {
                (<any>this).coordinates = [] as any;
                for (let item of _data["coordinates"])
                    (<any>this).coordinates.push(Coordinate.fromJS(item));
            }
            (<any>this).numPoints = _data["numPoints"];
            (<any>this).numGeometries = _data["numGeometries"];
            (<any>this).isSimple = _data["isSimple"];
            (<any>this).isValid = _data["isValid"];
            (<any>this).isEmpty = _data["isEmpty"];
            (<any>this).area = _data["area"];
            (<any>this).length = _data["length"];
            this.centroid = _data["centroid"] ? Point.fromJS(_data["centroid"]) : <any>undefined;
            this.interiorPoint = _data["interiorPoint"] ? Point.fromJS(_data["interiorPoint"]) : <any>undefined;
            this.pointOnSurface = _data["pointOnSurface"] ? Point.fromJS(_data["pointOnSurface"]) : <any>undefined;
            this.dimension = _data["dimension"];
            this.boundary = _data["boundary"] ? Geometry.fromJS(_data["boundary"]) : <any>undefined;
            this.boundaryDimension = _data["boundaryDimension"];
            this.envelope = _data["envelope"] ? Geometry.fromJS(_data["envelope"]) : <any>undefined;
            this.envelopeInternal = _data["envelopeInternal"] ? Envelope.fromJS(_data["envelopeInternal"]) : <any>undefined;
            (<any>this).isRectangle = _data["isRectangle"];
        }
    }

    static fromJS(data: any): Geometry {
        data = typeof data === 'object' ? data : {};
        let result = new Geometry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["factory"] = this.factory ? this.factory.toJSON() : <any>undefined;
        data["userData"] = this.userData;
        data["srid"] = this.srid;
        data["geometryType"] = this.geometryType;
        data["ogcGeometryType"] = this.ogcGeometryType;
        data["precisionModel"] = this.precisionModel ? this.precisionModel.toJSON() : <any>undefined;
        data["coordinate"] = this.coordinate ? this.coordinate.toJSON() : <any>undefined;
        if (Array.isArray(this.coordinates)) {
            data["coordinates"] = [];
            for (let item of this.coordinates)
                data["coordinates"].push(item.toJSON());
        }
        data["numPoints"] = this.numPoints;
        data["numGeometries"] = this.numGeometries;
        data["isSimple"] = this.isSimple;
        data["isValid"] = this.isValid;
        data["isEmpty"] = this.isEmpty;
        data["area"] = this.area;
        data["length"] = this.length;
        data["centroid"] = this.centroid ? this.centroid.toJSON() : <any>undefined;
        data["interiorPoint"] = this.interiorPoint ? this.interiorPoint.toJSON() : <any>undefined;
        data["pointOnSurface"] = this.pointOnSurface ? this.pointOnSurface.toJSON() : <any>undefined;
        data["dimension"] = this.dimension;
        data["boundary"] = this.boundary ? this.boundary.toJSON() : <any>undefined;
        data["boundaryDimension"] = this.boundaryDimension;
        data["envelope"] = this.envelope ? this.envelope.toJSON() : <any>undefined;
        data["envelopeInternal"] = this.envelopeInternal ? this.envelopeInternal.toJSON() : <any>undefined;
        data["isRectangle"] = this.isRectangle;
        return data; 
    }

    clone(): Geometry {
        const json = this.toJSON();
        let result = new Geometry();
        result.init(json);
        return result;
    }
}

export interface IGeometry {
    factory: GeometryFactory;
    userData: any | undefined;
    srid: number;
    geometryType: string | undefined;
    ogcGeometryType: OgcGeometryType;
    precisionModel: PrecisionModel;
    coordinate: Coordinate;
    coordinates: Coordinate[] | undefined;
    numPoints: number;
    numGeometries: number;
    isSimple: boolean;
    isValid: boolean;
    isEmpty: boolean;
    area: number;
    length: number;
    centroid: Point;
    interiorPoint: Point;
    pointOnSurface: Point;
    dimension: Dimension;
    boundary: Geometry;
    boundaryDimension: Dimension;
    envelope: Geometry;
    envelopeInternal: Envelope;
    isRectangle: boolean;
}

export class Point implements IPoint {
    coordinateSequence: CoordinateSequence;
    readonly coordinates: Coordinate[] | undefined;
    readonly numPoints: number;
    readonly isEmpty: boolean;
    dimension: Dimension;
    boundaryDimension: Dimension;
    x: number;
    y: number;
    coordinate: Coordinate;
    readonly geometryType: string | undefined;
    ogcGeometryType: OgcGeometryType;
    boundary: Geometry;
    z: number;
    m: number;
    factory: GeometryFactory;
    userData: any | undefined;
    srid: number;
    precisionModel: PrecisionModel;
    readonly numGeometries: number;
    readonly isSimple: boolean;
    readonly isValid: boolean;
    readonly area: number;
    readonly length: number;
    centroid: Point;
    interiorPoint: Point;
    pointOnSurface: Point;
    envelope: Geometry;
    envelopeInternal: Envelope;
    readonly isRectangle: boolean;

    constructor(data?: IPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.coordinateSequence = _data["coordinateSequence"] ? CoordinateSequence.fromJS(_data["coordinateSequence"]) : <any>undefined;
            if (Array.isArray(_data["coordinates"])) {
                (<any>this).coordinates = [] as any;
                for (let item of _data["coordinates"])
                    (<any>this).coordinates.push(Coordinate.fromJS(item));
            }
            (<any>this).numPoints = _data["numPoints"];
            (<any>this).isEmpty = _data["isEmpty"];
            this.dimension = _data["dimension"];
            this.boundaryDimension = _data["boundaryDimension"];
            this.x = _data["x"];
            this.y = _data["y"];
            this.coordinate = _data["coordinate"] ? Coordinate.fromJS(_data["coordinate"]) : <any>undefined;
            (<any>this).geometryType = _data["geometryType"];
            this.ogcGeometryType = _data["ogcGeometryType"];
            this.boundary = _data["boundary"] ? Geometry.fromJS(_data["boundary"]) : <any>undefined;
            this.z = _data["z"];
            this.m = _data["m"];
            this.factory = _data["factory"] ? GeometryFactory.fromJS(_data["factory"]) : <any>undefined;
            this.userData = _data["userData"];
            this.srid = _data["srid"];
            this.precisionModel = _data["precisionModel"] ? PrecisionModel.fromJS(_data["precisionModel"]) : <any>undefined;
            (<any>this).numGeometries = _data["numGeometries"];
            (<any>this).isSimple = _data["isSimple"];
            (<any>this).isValid = _data["isValid"];
            (<any>this).area = _data["area"];
            (<any>this).length = _data["length"];
            this.centroid = _data["centroid"] ? Point.fromJS(_data["centroid"]) : <any>undefined;
            this.interiorPoint = _data["interiorPoint"] ? Point.fromJS(_data["interiorPoint"]) : <any>undefined;
            this.pointOnSurface = _data["pointOnSurface"] ? Point.fromJS(_data["pointOnSurface"]) : <any>undefined;
            this.envelope = _data["envelope"] ? Geometry.fromJS(_data["envelope"]) : <any>undefined;
            this.envelopeInternal = _data["envelopeInternal"] ? Envelope.fromJS(_data["envelopeInternal"]) : <any>undefined;
            (<any>this).isRectangle = _data["isRectangle"];
        }
    }

    static fromJS(data: any): Point {
        data = typeof data === 'object' ? data : {};
        let result = new Point();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coordinateSequence"] = this.coordinateSequence ? this.coordinateSequence.toJSON() : <any>undefined;
        if (Array.isArray(this.coordinates)) {
            data["coordinates"] = [];
            for (let item of this.coordinates)
                data["coordinates"].push(item.toJSON());
        }
        data["numPoints"] = this.numPoints;
        data["isEmpty"] = this.isEmpty;
        data["dimension"] = this.dimension;
        data["boundaryDimension"] = this.boundaryDimension;
        data["x"] = this.x;
        data["y"] = this.y;
        data["coordinate"] = this.coordinate ? this.coordinate.toJSON() : <any>undefined;
        data["geometryType"] = this.geometryType;
        data["ogcGeometryType"] = this.ogcGeometryType;
        data["boundary"] = this.boundary ? this.boundary.toJSON() : <any>undefined;
        data["z"] = this.z;
        data["m"] = this.m;
        data["factory"] = this.factory ? this.factory.toJSON() : <any>undefined;
        data["userData"] = this.userData;
        data["srid"] = this.srid;
        data["precisionModel"] = this.precisionModel ? this.precisionModel.toJSON() : <any>undefined;
        data["numGeometries"] = this.numGeometries;
        data["isSimple"] = this.isSimple;
        data["isValid"] = this.isValid;
        data["area"] = this.area;
        data["length"] = this.length;
        data["centroid"] = this.centroid ? this.centroid.toJSON() : <any>undefined;
        data["interiorPoint"] = this.interiorPoint ? this.interiorPoint.toJSON() : <any>undefined;
        data["pointOnSurface"] = this.pointOnSurface ? this.pointOnSurface.toJSON() : <any>undefined;
        data["envelope"] = this.envelope ? this.envelope.toJSON() : <any>undefined;
        data["envelopeInternal"] = this.envelopeInternal ? this.envelopeInternal.toJSON() : <any>undefined;
        data["isRectangle"] = this.isRectangle;
        return data; 
    }

    clone(): Point {
        const json = this.toJSON();
        let result = new Point();
        result.init(json);
        return result;
    }
}

export interface IPoint {
    coordinateSequence: CoordinateSequence;
    coordinates: Coordinate[] | undefined;
    numPoints: number;
    isEmpty: boolean;
    dimension: Dimension;
    boundaryDimension: Dimension;
    x: number;
    y: number;
    coordinate: Coordinate;
    geometryType: string | undefined;
    ogcGeometryType: OgcGeometryType;
    boundary: Geometry;
    z: number;
    m: number;
    factory: GeometryFactory;
    userData: any | undefined;
    srid: number;
    precisionModel: PrecisionModel;
    numGeometries: number;
    isSimple: boolean;
    isValid: boolean;
    area: number;
    length: number;
    centroid: Point;
    interiorPoint: Point;
    pointOnSurface: Point;
    envelope: Geometry;
    envelopeInternal: Envelope;
    isRectangle: boolean;
}

export class UserToken implements IUserToken {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
    id: number;

    constructor(data?: IUserToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.expireDate = _data["expireDate"] ? moment(_data["expireDate"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserToken {
        data = typeof data === 'object' ? data : {};
        let result = new UserToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["name"] = this.name;
        data["value"] = this.value;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserToken {
        const json = this.toJSON();
        let result = new UserToken();
        result.init(json);
        return result;
    }
}

export interface IUserToken {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
    id: number;
}

export class UserLogin implements IUserLogin {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string;
    providerKey: string;
    id: number;

    constructor(data?: IUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.providerKey = _data["providerKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new UserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLogin {
        const json = this.toJSON();
        let result = new UserLogin();
        result.init(json);
        return result;
    }
}

export interface IUserLogin {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string;
    providerKey: string;
    id: number;
}

export class UserRole implements IUserRole {
    tenantId: number | undefined;
    userId: number;
    roleId: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserRole {
        const json = this.toJSON();
        let result = new UserRole();
        result.init(json);
        return result;
    }
}

export interface IUserRole {
    tenantId: number | undefined;
    userId: number;
    roleId: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class UserClaim implements IUserClaim {
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserClaim {
        const json = this.toJSON();
        let result = new UserClaim();
        result.init(json);
        return result;
    }
}

export interface IUserClaim {
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class UserPermissionSetting implements IUserPermissionSetting {
    userId: number;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUserPermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.isGranted = _data["isGranted"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserPermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserPermissionSetting {
        const json = this.toJSON();
        let result = new UserPermissionSetting();
        result.init(json);
        return result;
    }
}

export interface IUserPermissionSetting {
    userId: number;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Setting implements ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["value"] = this.value;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Setting {
        const json = this.toJSON();
        let result = new Setting();
        result.init(json);
        return result;
    }
}

export interface ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class User implements IUser {
    diaChi: string | undefined;
    chucVu: string | undefined;
    ghiChu: string | undefined;
    phanVungPhuTrach: PhanVungPhuTrach[] | undefined;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    readonly fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.diaChi = _data["diaChi"];
            this.chucVu = _data["chucVu"];
            this.ghiChu = _data["ghiChu"];
            if (Array.isArray(_data["phanVungPhuTrach"])) {
                this.phanVungPhuTrach = [] as any;
                for (let item of _data["phanVungPhuTrach"])
                    this.phanVungPhuTrach.push(PhanVungPhuTrach.fromJS(item));
            }
            this.normalizedUserName = _data["normalizedUserName"];
            this.normalizedEmailAddress = _data["normalizedEmailAddress"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            if (Array.isArray(_data["tokens"])) {
                this.tokens = [] as any;
                for (let item of _data["tokens"])
                    this.tokens.push(UserToken.fromJS(item));
            }
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.authenticationSource = _data["authenticationSource"];
            this.userName = _data["userName"];
            this.tenantId = _data["tenantId"];
            this.emailAddress = _data["emailAddress"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            (<any>this).fullName = _data["fullName"];
            this.password = _data["password"];
            this.emailConfirmationCode = _data["emailConfirmationCode"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.lockoutEndDateUtc = _data["lockoutEndDateUtc"] ? moment(_data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.accessFailedCount = _data["accessFailedCount"];
            this.isLockoutEnabled = _data["isLockoutEnabled"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.securityStamp = _data["securityStamp"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            if (Array.isArray(_data["logins"])) {
                this.logins = [] as any;
                for (let item of _data["logins"])
                    this.logins.push(UserLogin.fromJS(item));
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles.push(UserRole.fromJS(item));
            }
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims.push(UserClaim.fromJS(item));
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(UserPermissionSetting.fromJS(item));
            }
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings.push(Setting.fromJS(item));
            }
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["diaChi"] = this.diaChi;
        data["chucVu"] = this.chucVu;
        data["ghiChu"] = this.ghiChu;
        if (Array.isArray(this.phanVungPhuTrach)) {
            data["phanVungPhuTrach"] = [];
            for (let item of this.phanVungPhuTrach)
                data["phanVungPhuTrach"].push(item.toJSON());
        }
        data["normalizedUserName"] = this.normalizedUserName;
        data["normalizedEmailAddress"] = this.normalizedEmailAddress;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (Array.isArray(this.tokens)) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["authenticationSource"] = this.authenticationSource;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["emailAddress"] = this.emailAddress;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["emailConfirmationCode"] = this.emailConfirmationCode;
        data["passwordResetCode"] = this.passwordResetCode;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["accessFailedCount"] = this.accessFailedCount;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["securityStamp"] = this.securityStamp;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        if (Array.isArray(this.logins)) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    diaChi: string | undefined;
    chucVu: string | undefined;
    ghiChu: string | undefined;
    phanVungPhuTrach: PhanVungPhuTrach[] | undefined;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class PhanVungPhuTrach implements IPhanVungPhuTrach {
    phanVungId: number;
    phanVung: PhanVung;
    userId: number;
    user: User;

    constructor(data?: IPhanVungPhuTrach) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phanVungId = _data["phanVungId"];
            this.phanVung = _data["phanVung"] ? PhanVung.fromJS(_data["phanVung"]) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PhanVungPhuTrach {
        data = typeof data === 'object' ? data : {};
        let result = new PhanVungPhuTrach();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phanVungId"] = this.phanVungId;
        data["phanVung"] = this.phanVung ? this.phanVung.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }

    clone(): PhanVungPhuTrach {
        const json = this.toJSON();
        let result = new PhanVungPhuTrach();
        result.init(json);
        return result;
    }
}

export interface IPhanVungPhuTrach {
    phanVungId: number;
    phanVung: PhanVung;
    userId: number;
    user: User;
}

export class NguoiNhanCanhBao implements INguoiNhanCanhBao {
    ten: string | undefined;
    email: string | undefined;
    sdt: string | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: INguoiNhanCanhBao) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.email = _data["email"];
            this.sdt = _data["sdt"];
            this.ghiChu = _data["ghiChu"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NguoiNhanCanhBao {
        data = typeof data === 'object' ? data : {};
        let result = new NguoiNhanCanhBao();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["email"] = this.email;
        data["sdt"] = this.sdt;
        data["ghiChu"] = this.ghiChu;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): NguoiNhanCanhBao {
        const json = this.toJSON();
        let result = new NguoiNhanCanhBao();
        result.init(json);
        return result;
    }
}

export interface INguoiNhanCanhBao {
    ten: string | undefined;
    email: string | undefined;
    sdt: string | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class PhanVungNhanCanhBao implements IPhanVungNhanCanhBao {
    phanVungId: number;
    phanVung: PhanVung;
    nguoiNhanCanhBaoId: number;
    nguoiNhanCanhBao: NguoiNhanCanhBao;
    boCanhBaoId: number;
    boCanhBao: BoCanhBao;

    constructor(data?: IPhanVungNhanCanhBao) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phanVungId = _data["phanVungId"];
            this.phanVung = _data["phanVung"] ? PhanVung.fromJS(_data["phanVung"]) : <any>undefined;
            this.nguoiNhanCanhBaoId = _data["nguoiNhanCanhBaoId"];
            this.nguoiNhanCanhBao = _data["nguoiNhanCanhBao"] ? NguoiNhanCanhBao.fromJS(_data["nguoiNhanCanhBao"]) : <any>undefined;
            this.boCanhBaoId = _data["boCanhBaoId"];
            this.boCanhBao = _data["boCanhBao"] ? BoCanhBao.fromJS(_data["boCanhBao"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PhanVungNhanCanhBao {
        data = typeof data === 'object' ? data : {};
        let result = new PhanVungNhanCanhBao();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phanVungId"] = this.phanVungId;
        data["phanVung"] = this.phanVung ? this.phanVung.toJSON() : <any>undefined;
        data["nguoiNhanCanhBaoId"] = this.nguoiNhanCanhBaoId;
        data["nguoiNhanCanhBao"] = this.nguoiNhanCanhBao ? this.nguoiNhanCanhBao.toJSON() : <any>undefined;
        data["boCanhBaoId"] = this.boCanhBaoId;
        data["boCanhBao"] = this.boCanhBao ? this.boCanhBao.toJSON() : <any>undefined;
        return data; 
    }

    clone(): PhanVungNhanCanhBao {
        const json = this.toJSON();
        let result = new PhanVungNhanCanhBao();
        result.init(json);
        return result;
    }
}

export interface IPhanVungNhanCanhBao {
    phanVungId: number;
    phanVung: PhanVung;
    nguoiNhanCanhBaoId: number;
    nguoiNhanCanhBao: NguoiNhanCanhBao;
    boCanhBaoId: number;
    boCanhBao: BoCanhBao;
}

export class PhanVung implements IPhanVung {
    ten: string | undefined;
    maPhanVung: string | undefined;
    tbEntityId: string | undefined;
    phanVungChaId: number | undefined;
    phanVungCha: PhanVung;
    phanVungPhuTrach: PhanVungPhuTrach[] | undefined;
    phanVungNhanCanhBao: PhanVungNhanCanhBao[] | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IPhanVung) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.maPhanVung = _data["maPhanVung"];
            this.tbEntityId = _data["tbEntityId"];
            this.phanVungChaId = _data["phanVungChaId"];
            this.phanVungCha = _data["phanVungCha"] ? PhanVung.fromJS(_data["phanVungCha"]) : <any>undefined;
            if (Array.isArray(_data["phanVungPhuTrach"])) {
                this.phanVungPhuTrach = [] as any;
                for (let item of _data["phanVungPhuTrach"])
                    this.phanVungPhuTrach.push(PhanVungPhuTrach.fromJS(item));
            }
            if (Array.isArray(_data["phanVungNhanCanhBao"])) {
                this.phanVungNhanCanhBao = [] as any;
                for (let item of _data["phanVungNhanCanhBao"])
                    this.phanVungNhanCanhBao.push(PhanVungNhanCanhBao.fromJS(item));
            }
            this.ghiChu = _data["ghiChu"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PhanVung {
        data = typeof data === 'object' ? data : {};
        let result = new PhanVung();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["maPhanVung"] = this.maPhanVung;
        data["tbEntityId"] = this.tbEntityId;
        data["phanVungChaId"] = this.phanVungChaId;
        data["phanVungCha"] = this.phanVungCha ? this.phanVungCha.toJSON() : <any>undefined;
        if (Array.isArray(this.phanVungPhuTrach)) {
            data["phanVungPhuTrach"] = [];
            for (let item of this.phanVungPhuTrach)
                data["phanVungPhuTrach"].push(item.toJSON());
        }
        if (Array.isArray(this.phanVungNhanCanhBao)) {
            data["phanVungNhanCanhBao"] = [];
            for (let item of this.phanVungNhanCanhBao)
                data["phanVungNhanCanhBao"].push(item.toJSON());
        }
        data["ghiChu"] = this.ghiChu;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PhanVung {
        const json = this.toJSON();
        let result = new PhanVung();
        result.init(json);
        return result;
    }
}

export interface IPhanVung {
    ten: string | undefined;
    maPhanVung: string | undefined;
    tbEntityId: string | undefined;
    phanVungChaId: number | undefined;
    phanVungCha: PhanVung;
    phanVungPhuTrach: PhanVungPhuTrach[] | undefined;
    phanVungNhanCanhBao: PhanVungNhanCanhBao[] | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class PhanVungTram implements IPhanVungTram {
    phanVungId: number;
    phanVung: PhanVung;
    tramId: number;
    tram: Tram;

    constructor(data?: IPhanVungTram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phanVungId = _data["phanVungId"];
            this.phanVung = _data["phanVung"] ? PhanVung.fromJS(_data["phanVung"]) : <any>undefined;
            this.tramId = _data["tramId"];
            this.tram = _data["tram"] ? Tram.fromJS(_data["tram"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PhanVungTram {
        data = typeof data === 'object' ? data : {};
        let result = new PhanVungTram();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phanVungId"] = this.phanVungId;
        data["phanVung"] = this.phanVung ? this.phanVung.toJSON() : <any>undefined;
        data["tramId"] = this.tramId;
        data["tram"] = this.tram ? this.tram.toJSON() : <any>undefined;
        return data; 
    }

    clone(): PhanVungTram {
        const json = this.toJSON();
        let result = new PhanVungTram();
        result.init(json);
        return result;
    }
}

export interface IPhanVungTram {
    phanVungId: number;
    phanVung: PhanVung;
    tramId: number;
    tram: Tram;
}

export enum LoaiThietBi {
    _100 = 100,
    _101 = 101,
    _102 = 102,
    _103 = 103,
    _104 = 104,
    _105 = 105,
    _106 = 106,
    _107 = 107,
    _108 = 108,
    _109 = 109,
    _110 = 110,
    _111 = 111,
    _200 = 200,
    _201 = 201,
    _202 = 202,
    _203 = 203,
    _204 = 204,
    _205 = 205,
    _206 = 206,
    _207 = 207,
    _208 = 208,
    _209 = 209,
    _210 = 210,
    _300 = 300,
    _400 = 400,
    _488 = 488,
    _499 = 499,
    _599 = 599,
}

export class ThietBi implements IThietBi {
    ten: string | undefined;
    maThietBi: string | undefined;
    tbEntityId: string | undefined;
    accessToken: string | undefined;
    loaiThietBi: LoaiThietBi;
    tramId: number;
    tram: Tram;
    ghiChu: string | undefined;
    cameraLink: string | undefined;
    boCanhBaoId: number | undefined;
    xacThucThietBi: number | undefined;
    boCanhBao: BoCanhBao;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IThietBi) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.maThietBi = _data["maThietBi"];
            this.tbEntityId = _data["tbEntityId"];
            this.accessToken = _data["accessToken"];
            this.loaiThietBi = _data["loaiThietBi"];
            this.tramId = _data["tramId"];
            this.tram = _data["tram"] ? Tram.fromJS(_data["tram"]) : <any>undefined;
            this.ghiChu = _data["ghiChu"];
            this.cameraLink = _data["cameraLink"];
            this.boCanhBaoId = _data["boCanhBaoId"];
            this.xacThucThietBi = _data["xacThucThietBi"];
            this.boCanhBao = _data["boCanhBao"] ? BoCanhBao.fromJS(_data["boCanhBao"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ThietBi {
        data = typeof data === 'object' ? data : {};
        let result = new ThietBi();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["maThietBi"] = this.maThietBi;
        data["tbEntityId"] = this.tbEntityId;
        data["accessToken"] = this.accessToken;
        data["loaiThietBi"] = this.loaiThietBi;
        data["tramId"] = this.tramId;
        data["tram"] = this.tram ? this.tram.toJSON() : <any>undefined;
        data["ghiChu"] = this.ghiChu;
        data["cameraLink"] = this.cameraLink;
        data["boCanhBaoId"] = this.boCanhBaoId;
        data["xacThucThietBi"] = this.xacThucThietBi;
        data["boCanhBao"] = this.boCanhBao ? this.boCanhBao.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ThietBi {
        const json = this.toJSON();
        let result = new ThietBi();
        result.init(json);
        return result;
    }
}

export interface IThietBi {
    ten: string | undefined;
    maThietBi: string | undefined;
    tbEntityId: string | undefined;
    accessToken: string | undefined;
    loaiThietBi: LoaiThietBi;
    tramId: number;
    tram: Tram;
    ghiChu: string | undefined;
    cameraLink: string | undefined;
    boCanhBaoId: number | undefined;
    xacThucThietBi: number | undefined;
    boCanhBao: BoCanhBao;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TramDieuKhienThuocTinh implements ITramDieuKhienThuocTinh {
    tramId: number;
    mauThuocTinhId: number;
    boolValue: boolean | undefined;
    stringValue: string | undefined;
    longValue: number | undefined;
    doubleValue: number | undefined;
    jsonValue: string | undefined;
    tram: Tram;
    mauThuocTinh: MauThuocTinh;

    constructor(data?: ITramDieuKhienThuocTinh) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tramId = _data["tramId"];
            this.mauThuocTinhId = _data["mauThuocTinhId"];
            this.boolValue = _data["boolValue"];
            this.stringValue = _data["stringValue"];
            this.longValue = _data["longValue"];
            this.doubleValue = _data["doubleValue"];
            this.jsonValue = _data["jsonValue"];
            this.tram = _data["tram"] ? Tram.fromJS(_data["tram"]) : <any>undefined;
            this.mauThuocTinh = _data["mauThuocTinh"] ? MauThuocTinh.fromJS(_data["mauThuocTinh"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TramDieuKhienThuocTinh {
        data = typeof data === 'object' ? data : {};
        let result = new TramDieuKhienThuocTinh();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tramId"] = this.tramId;
        data["mauThuocTinhId"] = this.mauThuocTinhId;
        data["boolValue"] = this.boolValue;
        data["stringValue"] = this.stringValue;
        data["longValue"] = this.longValue;
        data["doubleValue"] = this.doubleValue;
        data["jsonValue"] = this.jsonValue;
        data["tram"] = this.tram ? this.tram.toJSON() : <any>undefined;
        data["mauThuocTinh"] = this.mauThuocTinh ? this.mauThuocTinh.toJSON() : <any>undefined;
        return data; 
    }

    clone(): TramDieuKhienThuocTinh {
        const json = this.toJSON();
        let result = new TramDieuKhienThuocTinh();
        result.init(json);
        return result;
    }
}

export interface ITramDieuKhienThuocTinh {
    tramId: number;
    mauThuocTinhId: number;
    boolValue: boolean | undefined;
    stringValue: string | undefined;
    longValue: number | undefined;
    doubleValue: number | undefined;
    jsonValue: string | undefined;
    tram: Tram;
    mauThuocTinh: MauThuocTinh;
}

export class TramCanhBaoThuocTinh implements ITramCanhBaoThuocTinh {
    tramId: number;
    tram: Tram;
    mauThuocTinhId: number;
    mauThuocTinh: MauThuocTinh;
    boolValue: boolean | undefined;
    stringValue: string | undefined;
    longValue: number | undefined;
    doubleValue: number | undefined;
    jsonValue: string | undefined;

    constructor(data?: ITramCanhBaoThuocTinh) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tramId = _data["tramId"];
            this.tram = _data["tram"] ? Tram.fromJS(_data["tram"]) : <any>undefined;
            this.mauThuocTinhId = _data["mauThuocTinhId"];
            this.mauThuocTinh = _data["mauThuocTinh"] ? MauThuocTinh.fromJS(_data["mauThuocTinh"]) : <any>undefined;
            this.boolValue = _data["boolValue"];
            this.stringValue = _data["stringValue"];
            this.longValue = _data["longValue"];
            this.doubleValue = _data["doubleValue"];
            this.jsonValue = _data["jsonValue"];
        }
    }

    static fromJS(data: any): TramCanhBaoThuocTinh {
        data = typeof data === 'object' ? data : {};
        let result = new TramCanhBaoThuocTinh();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tramId"] = this.tramId;
        data["tram"] = this.tram ? this.tram.toJSON() : <any>undefined;
        data["mauThuocTinhId"] = this.mauThuocTinhId;
        data["mauThuocTinh"] = this.mauThuocTinh ? this.mauThuocTinh.toJSON() : <any>undefined;
        data["boolValue"] = this.boolValue;
        data["stringValue"] = this.stringValue;
        data["longValue"] = this.longValue;
        data["doubleValue"] = this.doubleValue;
        data["jsonValue"] = this.jsonValue;
        return data; 
    }

    clone(): TramCanhBaoThuocTinh {
        const json = this.toJSON();
        let result = new TramCanhBaoThuocTinh();
        result.init(json);
        return result;
    }
}

export interface ITramCanhBaoThuocTinh {
    tramId: number;
    tram: Tram;
    mauThuocTinhId: number;
    mauThuocTinh: MauThuocTinh;
    boolValue: boolean | undefined;
    stringValue: string | undefined;
    longValue: number | undefined;
    doubleValue: number | undefined;
    jsonValue: string | undefined;
}

export class Tram implements ITram {
    ten: string | undefined;
    maTram: string | undefined;
    diaChi: string | undefined;
    toaDo: Point;
    tbEntityId: string | undefined;
    accessToken: string | undefined;
    ghiChu: string | undefined;
    loaiNguonDien: number | undefined;
    phanVungTram: PhanVungTram[] | undefined;
    tramNhanVien: TramNhanVien[] | undefined;
    thietBi: ThietBi[] | undefined;
    mauDieuKhienId: number | undefined;
    mauDieuKhien: MauDieuKhien;
    mauCanhBaoId: number | undefined;
    mauCanhBao: MauCanhBao;
    tramDieuKhienThuocTinh: TramDieuKhienThuocTinh[] | undefined;
    tramCanhBaoThuocTinh: TramCanhBaoThuocTinh[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.maTram = _data["maTram"];
            this.diaChi = _data["diaChi"];
            this.toaDo = _data["toaDo"] ? Point.fromJS(_data["toaDo"]) : <any>undefined;
            this.tbEntityId = _data["tbEntityId"];
            this.accessToken = _data["accessToken"];
            this.ghiChu = _data["ghiChu"];
            this.loaiNguonDien = _data["loaiNguonDien"];
            if (Array.isArray(_data["phanVungTram"])) {
                this.phanVungTram = [] as any;
                for (let item of _data["phanVungTram"])
                    this.phanVungTram.push(PhanVungTram.fromJS(item));
            }
            if (Array.isArray(_data["tramNhanVien"])) {
                this.tramNhanVien = [] as any;
                for (let item of _data["tramNhanVien"])
                    this.tramNhanVien.push(TramNhanVien.fromJS(item));
            }
            if (Array.isArray(_data["thietBi"])) {
                this.thietBi = [] as any;
                for (let item of _data["thietBi"])
                    this.thietBi.push(ThietBi.fromJS(item));
            }
            this.mauDieuKhienId = _data["mauDieuKhienId"];
            this.mauDieuKhien = _data["mauDieuKhien"] ? MauDieuKhien.fromJS(_data["mauDieuKhien"]) : <any>undefined;
            this.mauCanhBaoId = _data["mauCanhBaoId"];
            this.mauCanhBao = _data["mauCanhBao"] ? MauCanhBao.fromJS(_data["mauCanhBao"]) : <any>undefined;
            if (Array.isArray(_data["tramDieuKhienThuocTinh"])) {
                this.tramDieuKhienThuocTinh = [] as any;
                for (let item of _data["tramDieuKhienThuocTinh"])
                    this.tramDieuKhienThuocTinh.push(TramDieuKhienThuocTinh.fromJS(item));
            }
            if (Array.isArray(_data["tramCanhBaoThuocTinh"])) {
                this.tramCanhBaoThuocTinh = [] as any;
                for (let item of _data["tramCanhBaoThuocTinh"])
                    this.tramCanhBaoThuocTinh.push(TramCanhBaoThuocTinh.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Tram {
        data = typeof data === 'object' ? data : {};
        let result = new Tram();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["maTram"] = this.maTram;
        data["diaChi"] = this.diaChi;
        data["toaDo"] = this.toaDo ? this.toaDo.toJSON() : <any>undefined;
        data["tbEntityId"] = this.tbEntityId;
        data["accessToken"] = this.accessToken;
        data["ghiChu"] = this.ghiChu;
        data["loaiNguonDien"] = this.loaiNguonDien;
        if (Array.isArray(this.phanVungTram)) {
            data["phanVungTram"] = [];
            for (let item of this.phanVungTram)
                data["phanVungTram"].push(item.toJSON());
        }
        if (Array.isArray(this.tramNhanVien)) {
            data["tramNhanVien"] = [];
            for (let item of this.tramNhanVien)
                data["tramNhanVien"].push(item.toJSON());
        }
        if (Array.isArray(this.thietBi)) {
            data["thietBi"] = [];
            for (let item of this.thietBi)
                data["thietBi"].push(item.toJSON());
        }
        data["mauDieuKhienId"] = this.mauDieuKhienId;
        data["mauDieuKhien"] = this.mauDieuKhien ? this.mauDieuKhien.toJSON() : <any>undefined;
        data["mauCanhBaoId"] = this.mauCanhBaoId;
        data["mauCanhBao"] = this.mauCanhBao ? this.mauCanhBao.toJSON() : <any>undefined;
        if (Array.isArray(this.tramDieuKhienThuocTinh)) {
            data["tramDieuKhienThuocTinh"] = [];
            for (let item of this.tramDieuKhienThuocTinh)
                data["tramDieuKhienThuocTinh"].push(item.toJSON());
        }
        if (Array.isArray(this.tramCanhBaoThuocTinh)) {
            data["tramCanhBaoThuocTinh"] = [];
            for (let item of this.tramCanhBaoThuocTinh)
                data["tramCanhBaoThuocTinh"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Tram {
        const json = this.toJSON();
        let result = new Tram();
        result.init(json);
        return result;
    }
}

export interface ITram {
    ten: string | undefined;
    maTram: string | undefined;
    diaChi: string | undefined;
    toaDo: Point;
    tbEntityId: string | undefined;
    accessToken: string | undefined;
    ghiChu: string | undefined;
    loaiNguonDien: number | undefined;
    phanVungTram: PhanVungTram[] | undefined;
    tramNhanVien: TramNhanVien[] | undefined;
    thietBi: ThietBi[] | undefined;
    mauDieuKhienId: number | undefined;
    mauDieuKhien: MauDieuKhien;
    mauCanhBaoId: number | undefined;
    mauCanhBao: MauCanhBao;
    tramDieuKhienThuocTinh: TramDieuKhienThuocTinh[] | undefined;
    tramCanhBaoThuocTinh: TramCanhBaoThuocTinh[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum ChucVuNhanVienRaVaoTram {
    _1 = 1,
    _2 = 2,
}

export class TramNhanVien implements ITramNhanVien {
    nhanVienId: number;
    nhanVien: NhanVienRaVaoTram;
    tramId: number;
    tram: Tram;
    chucVu: ChucVuNhanVienRaVaoTram;

    constructor(data?: ITramNhanVien) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhanVienId = _data["nhanVienId"];
            this.nhanVien = _data["nhanVien"] ? NhanVienRaVaoTram.fromJS(_data["nhanVien"]) : <any>undefined;
            this.tramId = _data["tramId"];
            this.tram = _data["tram"] ? Tram.fromJS(_data["tram"]) : <any>undefined;
            this.chucVu = _data["chucVu"];
        }
    }

    static fromJS(data: any): TramNhanVien {
        data = typeof data === 'object' ? data : {};
        let result = new TramNhanVien();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhanVienId"] = this.nhanVienId;
        data["nhanVien"] = this.nhanVien ? this.nhanVien.toJSON() : <any>undefined;
        data["tramId"] = this.tramId;
        data["tram"] = this.tram ? this.tram.toJSON() : <any>undefined;
        data["chucVu"] = this.chucVu;
        return data; 
    }

    clone(): TramNhanVien {
        const json = this.toJSON();
        let result = new TramNhanVien();
        result.init(json);
        return result;
    }
}

export interface ITramNhanVien {
    nhanVienId: number;
    nhanVien: NhanVienRaVaoTram;
    tramId: number;
    tram: Tram;
    chucVu: ChucVuNhanVienRaVaoTram;
}

export class SetQuanLyTramInputDto implements ISetQuanLyTramInputDto {
    nhanViensSet: NhanVienRaVaoTramGetByTramIdOutputDto[] | undefined;
    nhanViensRemain: NhanVienRaVaoTramGetByTramIdOutputDto[] | undefined;
    tbEntityId: string | undefined;

    constructor(data?: ISetQuanLyTramInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["nhanViensSet"])) {
                this.nhanViensSet = [] as any;
                for (let item of _data["nhanViensSet"])
                    this.nhanViensSet.push(NhanVienRaVaoTramGetByTramIdOutputDto.fromJS(item));
            }
            if (Array.isArray(_data["nhanViensRemain"])) {
                this.nhanViensRemain = [] as any;
                for (let item of _data["nhanViensRemain"])
                    this.nhanViensRemain.push(NhanVienRaVaoTramGetByTramIdOutputDto.fromJS(item));
            }
            this.tbEntityId = _data["tbEntityId"];
        }
    }

    static fromJS(data: any): SetQuanLyTramInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetQuanLyTramInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.nhanViensSet)) {
            data["nhanViensSet"] = [];
            for (let item of this.nhanViensSet)
                data["nhanViensSet"].push(item.toJSON());
        }
        if (Array.isArray(this.nhanViensRemain)) {
            data["nhanViensRemain"] = [];
            for (let item of this.nhanViensRemain)
                data["nhanViensRemain"].push(item.toJSON());
        }
        data["tbEntityId"] = this.tbEntityId;
        return data; 
    }

    clone(): SetQuanLyTramInputDto {
        const json = this.toJSON();
        let result = new SetQuanLyTramInputDto();
        result.init(json);
        return result;
    }
}

export interface ISetQuanLyTramInputDto {
    nhanViensSet: NhanVienRaVaoTramGetByTramIdOutputDto[] | undefined;
    nhanViensRemain: NhanVienRaVaoTramGetByTramIdOutputDto[] | undefined;
    tbEntityId: string | undefined;
}

export class GanNhanViensVaoTramInputDto implements IGanNhanViensVaoTramInputDto {
    idTram: number;
    idNhanViens: NhanVienRaVaoTramDto[] | undefined;
    idNhanViensOld: NhanVienRaVaoTramGetByTramIdOutputDto[] | undefined;
    tbEntityId: string | undefined;

    constructor(data?: IGanNhanViensVaoTramInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idTram = _data["idTram"];
            if (Array.isArray(_data["idNhanViens"])) {
                this.idNhanViens = [] as any;
                for (let item of _data["idNhanViens"])
                    this.idNhanViens.push(NhanVienRaVaoTramDto.fromJS(item));
            }
            if (Array.isArray(_data["idNhanViensOld"])) {
                this.idNhanViensOld = [] as any;
                for (let item of _data["idNhanViensOld"])
                    this.idNhanViensOld.push(NhanVienRaVaoTramGetByTramIdOutputDto.fromJS(item));
            }
            this.tbEntityId = _data["tbEntityId"];
        }
    }

    static fromJS(data: any): GanNhanViensVaoTramInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GanNhanViensVaoTramInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idTram"] = this.idTram;
        if (Array.isArray(this.idNhanViens)) {
            data["idNhanViens"] = [];
            for (let item of this.idNhanViens)
                data["idNhanViens"].push(item.toJSON());
        }
        if (Array.isArray(this.idNhanViensOld)) {
            data["idNhanViensOld"] = [];
            for (let item of this.idNhanViensOld)
                data["idNhanViensOld"].push(item.toJSON());
        }
        data["tbEntityId"] = this.tbEntityId;
        return data; 
    }

    clone(): GanNhanViensVaoTramInputDto {
        const json = this.toJSON();
        let result = new GanNhanViensVaoTramInputDto();
        result.init(json);
        return result;
    }
}

export interface IGanNhanViensVaoTramInputDto {
    idTram: number;
    idNhanViens: NhanVienRaVaoTramDto[] | undefined;
    idNhanViensOld: NhanVienRaVaoTramGetByTramIdOutputDto[] | undefined;
    tbEntityId: string | undefined;
}

export class PhanVungDto implements IPhanVungDto {
    ten: string | undefined;
    maPhanVung: string | undefined;
    tbEntityId: string | undefined;
    phanVungChaId: number | undefined;
    phanVungCha: PhanVung;
    phanVungPhuTrach: PhanVungPhuTrach[] | undefined;
    phanVungNhanCanhBao: PhanVungNhanCanhBao[] | undefined;
    ghiChu: string | undefined;
    id: number;

    constructor(data?: IPhanVungDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.maPhanVung = _data["maPhanVung"];
            this.tbEntityId = _data["tbEntityId"];
            this.phanVungChaId = _data["phanVungChaId"];
            this.phanVungCha = _data["phanVungCha"] ? PhanVung.fromJS(_data["phanVungCha"]) : <any>undefined;
            if (Array.isArray(_data["phanVungPhuTrach"])) {
                this.phanVungPhuTrach = [] as any;
                for (let item of _data["phanVungPhuTrach"])
                    this.phanVungPhuTrach.push(PhanVungPhuTrach.fromJS(item));
            }
            if (Array.isArray(_data["phanVungNhanCanhBao"])) {
                this.phanVungNhanCanhBao = [] as any;
                for (let item of _data["phanVungNhanCanhBao"])
                    this.phanVungNhanCanhBao.push(PhanVungNhanCanhBao.fromJS(item));
            }
            this.ghiChu = _data["ghiChu"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PhanVungDto {
        data = typeof data === 'object' ? data : {};
        let result = new PhanVungDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["maPhanVung"] = this.maPhanVung;
        data["tbEntityId"] = this.tbEntityId;
        data["phanVungChaId"] = this.phanVungChaId;
        data["phanVungCha"] = this.phanVungCha ? this.phanVungCha.toJSON() : <any>undefined;
        if (Array.isArray(this.phanVungPhuTrach)) {
            data["phanVungPhuTrach"] = [];
            for (let item of this.phanVungPhuTrach)
                data["phanVungPhuTrach"].push(item.toJSON());
        }
        if (Array.isArray(this.phanVungNhanCanhBao)) {
            data["phanVungNhanCanhBao"] = [];
            for (let item of this.phanVungNhanCanhBao)
                data["phanVungNhanCanhBao"].push(item.toJSON());
        }
        data["ghiChu"] = this.ghiChu;
        data["id"] = this.id;
        return data; 
    }

    clone(): PhanVungDto {
        const json = this.toJSON();
        let result = new PhanVungDto();
        result.init(json);
        return result;
    }
}

export interface IPhanVungDto {
    ten: string | undefined;
    maPhanVung: string | undefined;
    tbEntityId: string | undefined;
    phanVungChaId: number | undefined;
    phanVungCha: PhanVung;
    phanVungPhuTrach: PhanVungPhuTrach[] | undefined;
    phanVungNhanCanhBao: PhanVungNhanCanhBao[] | undefined;
    ghiChu: string | undefined;
    id: number;
}

export class PhanVungForView implements IPhanVungForView {
    expanded: boolean;
    data: PhanVungDto;
    children: PhanVungForView[] | undefined;

    constructor(data?: IPhanVungForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expanded = _data["expanded"];
            this.data = _data["data"] ? PhanVungDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children.push(PhanVungForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PhanVungForView {
        data = typeof data === 'object' ? data : {};
        let result = new PhanVungForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expanded"] = this.expanded;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PhanVungForView {
        const json = this.toJSON();
        let result = new PhanVungForView();
        result.init(json);
        return result;
    }
}

export interface IPhanVungForView {
    expanded: boolean;
    data: PhanVungDto;
    children: PhanVungForView[] | undefined;
}

export class PhanVungLuatNhanCanhBaoDto implements IPhanVungLuatNhanCanhBaoDto {
    nguoiNhanCanhBao: number;
    luatCanhBao: number[] | undefined;

    constructor(data?: IPhanVungLuatNhanCanhBaoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nguoiNhanCanhBao = _data["nguoiNhanCanhBao"];
            if (Array.isArray(_data["luatCanhBao"])) {
                this.luatCanhBao = [] as any;
                for (let item of _data["luatCanhBao"])
                    this.luatCanhBao.push(item);
            }
        }
    }

    static fromJS(data: any): PhanVungLuatNhanCanhBaoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PhanVungLuatNhanCanhBaoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nguoiNhanCanhBao"] = this.nguoiNhanCanhBao;
        if (Array.isArray(this.luatCanhBao)) {
            data["luatCanhBao"] = [];
            for (let item of this.luatCanhBao)
                data["luatCanhBao"].push(item);
        }
        return data; 
    }

    clone(): PhanVungLuatNhanCanhBaoDto {
        const json = this.toJSON();
        let result = new PhanVungLuatNhanCanhBaoDto();
        result.init(json);
        return result;
    }
}

export interface IPhanVungLuatNhanCanhBaoDto {
    nguoiNhanCanhBao: number;
    luatCanhBao: number[] | undefined;
}

export class PhanVungCreateInputDto implements IPhanVungCreateInputDto {
    ten: string | undefined;
    maPhanVung: string | undefined;
    tbEntityId: string | undefined;
    phanVungChaId: number | undefined;
    phanVungCha: PhanVung;
    phanVungPhuTrach: PhanVungPhuTrach[] | undefined;
    phanVungNhanCanhBao: PhanVungNhanCanhBao[] | undefined;
    ghiChu: string | undefined;
    pvNhanCanhBao: PhanVungLuatNhanCanhBaoDto[] | undefined;
    id: number | undefined;

    constructor(data?: IPhanVungCreateInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.maPhanVung = _data["maPhanVung"];
            this.tbEntityId = _data["tbEntityId"];
            this.phanVungChaId = _data["phanVungChaId"];
            this.phanVungCha = _data["phanVungCha"] ? PhanVung.fromJS(_data["phanVungCha"]) : <any>undefined;
            if (Array.isArray(_data["phanVungPhuTrach"])) {
                this.phanVungPhuTrach = [] as any;
                for (let item of _data["phanVungPhuTrach"])
                    this.phanVungPhuTrach.push(PhanVungPhuTrach.fromJS(item));
            }
            if (Array.isArray(_data["phanVungNhanCanhBao"])) {
                this.phanVungNhanCanhBao = [] as any;
                for (let item of _data["phanVungNhanCanhBao"])
                    this.phanVungNhanCanhBao.push(PhanVungNhanCanhBao.fromJS(item));
            }
            this.ghiChu = _data["ghiChu"];
            if (Array.isArray(_data["pvNhanCanhBao"])) {
                this.pvNhanCanhBao = [] as any;
                for (let item of _data["pvNhanCanhBao"])
                    this.pvNhanCanhBao.push(PhanVungLuatNhanCanhBaoDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PhanVungCreateInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PhanVungCreateInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["maPhanVung"] = this.maPhanVung;
        data["tbEntityId"] = this.tbEntityId;
        data["phanVungChaId"] = this.phanVungChaId;
        data["phanVungCha"] = this.phanVungCha ? this.phanVungCha.toJSON() : <any>undefined;
        if (Array.isArray(this.phanVungPhuTrach)) {
            data["phanVungPhuTrach"] = [];
            for (let item of this.phanVungPhuTrach)
                data["phanVungPhuTrach"].push(item.toJSON());
        }
        if (Array.isArray(this.phanVungNhanCanhBao)) {
            data["phanVungNhanCanhBao"] = [];
            for (let item of this.phanVungNhanCanhBao)
                data["phanVungNhanCanhBao"].push(item.toJSON());
        }
        data["ghiChu"] = this.ghiChu;
        if (Array.isArray(this.pvNhanCanhBao)) {
            data["pvNhanCanhBao"] = [];
            for (let item of this.pvNhanCanhBao)
                data["pvNhanCanhBao"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): PhanVungCreateInputDto {
        const json = this.toJSON();
        let result = new PhanVungCreateInputDto();
        result.init(json);
        return result;
    }
}

export interface IPhanVungCreateInputDto {
    ten: string | undefined;
    maPhanVung: string | undefined;
    tbEntityId: string | undefined;
    phanVungChaId: number | undefined;
    phanVungCha: PhanVung;
    phanVungPhuTrach: PhanVungPhuTrach[] | undefined;
    phanVungNhanCanhBao: PhanVungNhanCanhBao[] | undefined;
    ghiChu: string | undefined;
    pvNhanCanhBao: PhanVungLuatNhanCanhBaoDto[] | undefined;
    id: number | undefined;
}

export class PhanVungNguoiDungDto implements IPhanVungNguoiDungDto {
    name: string | undefined;
    userName: string | undefined;
    id: number;

    constructor(data?: IPhanVungNguoiDungDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.userName = _data["userName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PhanVungNguoiDungDto {
        data = typeof data === 'object' ? data : {};
        let result = new PhanVungNguoiDungDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["id"] = this.id;
        return data; 
    }

    clone(): PhanVungNguoiDungDto {
        const json = this.toJSON();
        let result = new PhanVungNguoiDungDto();
        result.init(json);
        return result;
    }
}

export interface IPhanVungNguoiDungDto {
    name: string | undefined;
    userName: string | undefined;
    id: number;
}

export class NguoiNhanCanhBaoLookupTable implements INguoiNhanCanhBaoLookupTable {
    id: number;
    displayName: string | undefined;
    disabled: boolean | undefined;

    constructor(data?: INguoiNhanCanhBaoLookupTable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.disabled = _data["disabled"];
        }
    }

    static fromJS(data: any): NguoiNhanCanhBaoLookupTable {
        data = typeof data === 'object' ? data : {};
        let result = new NguoiNhanCanhBaoLookupTable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["disabled"] = this.disabled;
        return data; 
    }

    clone(): NguoiNhanCanhBaoLookupTable {
        const json = this.toJSON();
        let result = new NguoiNhanCanhBaoLookupTable();
        result.init(json);
        return result;
    }
}

export interface INguoiNhanCanhBaoLookupTable {
    id: number;
    displayName: string | undefined;
    disabled: boolean | undefined;
}

export class DMCanhBaoInput implements IDMCanhBaoInput {
    keyWord: string | undefined;
    trangThai: number | undefined;
    tramId: number | undefined;
    tuNgay: moment.Moment | undefined;
    denNgay: moment.Moment | undefined;

    constructor(data?: IDMCanhBaoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyWord = _data["keyWord"];
            this.trangThai = _data["trangThai"];
            this.tramId = _data["tramId"];
            this.tuNgay = _data["tuNgay"] ? moment(_data["tuNgay"].toString()) : <any>undefined;
            this.denNgay = _data["denNgay"] ? moment(_data["denNgay"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DMCanhBaoInput {
        data = typeof data === 'object' ? data : {};
        let result = new DMCanhBaoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyWord"] = this.keyWord;
        data["trangThai"] = this.trangThai;
        data["tramId"] = this.tramId;
        data["tuNgay"] = this.tuNgay ? this.tuNgay.toISOString() : <any>undefined;
        data["denNgay"] = this.denNgay ? this.denNgay.toISOString() : <any>undefined;
        return data; 
    }

    clone(): DMCanhBaoInput {
        const json = this.toJSON();
        let result = new DMCanhBaoInput();
        result.init(json);
        return result;
    }
}

export interface IDMCanhBaoInput {
    keyWord: string | undefined;
    trangThai: number | undefined;
    tramId: number | undefined;
    tuNgay: moment.Moment | undefined;
    denNgay: moment.Moment | undefined;
}

export class AlarmId implements IAlarmId {
    id: string | undefined;
    readonly entityType: string | undefined;

    constructor(data?: IAlarmId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).entityType = _data["entityType"];
        }
    }

    static fromJS(data: any): AlarmId {
        data = typeof data === 'object' ? data : {};
        let result = new AlarmId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entityType"] = this.entityType;
        return data; 
    }

    clone(): AlarmId {
        const json = this.toJSON();
        let result = new AlarmId();
        result.init(json);
        return result;
    }
}

export interface IAlarmId {
    id: string | undefined;
    entityType: string | undefined;
}

export enum EntityIdEntityType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
}

export class EntityId implements IEntityId {
    entityType: EntityIdEntityType;
    id: string | undefined;

    constructor(data?: IEntityId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityType = _data["entityType"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityId {
        data = typeof data === 'object' ? data : {};
        let result = new EntityId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityType"] = this.entityType;
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityId {
        const json = this.toJSON();
        let result = new EntityId();
        result.init(json);
        return result;
    }
}

export interface IEntityId {
    entityType: EntityIdEntityType;
    id: string | undefined;
}

export enum AlarmInfoSeverity {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum AlarmInfoStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class TenantId implements ITenantId {
    id: string | undefined;
    readonly entityType: string | undefined;

    constructor(data?: ITenantId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).entityType = _data["entityType"];
        }
    }

    static fromJS(data: any): TenantId {
        data = typeof data === 'object' ? data : {};
        let result = new TenantId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entityType"] = this.entityType;
        return data; 
    }

    clone(): TenantId {
        const json = this.toJSON();
        let result = new TenantId();
        result.init(json);
        return result;
    }
}

export interface ITenantId {
    id: string | undefined;
    entityType: string | undefined;
}

export class AlarmInfo implements IAlarmInfo {
    ackTs: number | undefined;
    clearTs: number | undefined;
    createdTime: number | undefined;
    details: { [key: string]: any; } | undefined;
    endTs: number | undefined;
    id: AlarmId;
    name: string | undefined;
    originator: EntityId;
    originatorName: string | undefined;
    propagate: boolean | undefined;
    propagateRelationTypes: string[] | undefined;
    severity: AlarmInfoSeverity;
    startTs: number | undefined;
    status: AlarmInfoStatus;
    tenantId: TenantId;
    type: string | undefined;

    constructor(data?: IAlarmInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ackTs = _data["ackTs"];
            this.clearTs = _data["clearTs"];
            this.createdTime = _data["createdTime"];
            if (_data["details"]) {
                this.details = {} as any;
                for (let key in _data["details"]) {
                    if (_data["details"].hasOwnProperty(key))
                        this.details[key] = _data["details"][key];
                }
            }
            this.endTs = _data["endTs"];
            this.id = _data["id"] ? AlarmId.fromJS(_data["id"]) : <any>undefined;
            this.name = _data["name"];
            this.originator = _data["originator"] ? EntityId.fromJS(_data["originator"]) : <any>undefined;
            this.originatorName = _data["originatorName"];
            this.propagate = _data["propagate"];
            if (Array.isArray(_data["propagateRelationTypes"])) {
                this.propagateRelationTypes = [] as any;
                for (let item of _data["propagateRelationTypes"])
                    this.propagateRelationTypes.push(item);
            }
            this.severity = _data["severity"];
            this.startTs = _data["startTs"];
            this.status = _data["status"];
            this.tenantId = _data["tenantId"] ? TenantId.fromJS(_data["tenantId"]) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): AlarmInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AlarmInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ackTs"] = this.ackTs;
        data["clearTs"] = this.clearTs;
        data["createdTime"] = this.createdTime;
        if (this.details) {
            data["details"] = {};
            for (let key in this.details) {
                if (this.details.hasOwnProperty(key))
                    data["details"][key] = this.details[key];
            }
        }
        data["endTs"] = this.endTs;
        data["id"] = this.id ? this.id.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["originator"] = this.originator ? this.originator.toJSON() : <any>undefined;
        data["originatorName"] = this.originatorName;
        data["propagate"] = this.propagate;
        if (Array.isArray(this.propagateRelationTypes)) {
            data["propagateRelationTypes"] = [];
            for (let item of this.propagateRelationTypes)
                data["propagateRelationTypes"].push(item);
        }
        data["severity"] = this.severity;
        data["startTs"] = this.startTs;
        data["status"] = this.status;
        data["tenantId"] = this.tenantId ? this.tenantId.toJSON() : <any>undefined;
        data["type"] = this.type;
        return data; 
    }

    clone(): AlarmInfo {
        const json = this.toJSON();
        let result = new AlarmInfo();
        result.init(json);
        return result;
    }
}

export interface IAlarmInfo {
    ackTs: number | undefined;
    clearTs: number | undefined;
    createdTime: number | undefined;
    details: { [key: string]: any; } | undefined;
    endTs: number | undefined;
    id: AlarmId;
    name: string | undefined;
    originator: EntityId;
    originatorName: string | undefined;
    propagate: boolean | undefined;
    propagateRelationTypes: string[] | undefined;
    severity: AlarmInfoSeverity;
    startTs: number | undefined;
    status: AlarmInfoStatus;
    tenantId: TenantId;
    type: string | undefined;
}

export class DeviceSync implements IDeviceSync {
    deviceId: string | undefined;
    deviceName: string | undefined;
    accessToken: string | undefined;

    constructor(data?: IDeviceSync) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.deviceName = _data["deviceName"];
            this.accessToken = _data["accessToken"];
        }
    }

    static fromJS(data: any): DeviceSync {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceSync();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["accessToken"] = this.accessToken;
        return data; 
    }

    clone(): DeviceSync {
        const json = this.toJSON();
        let result = new DeviceSync();
        result.init(json);
        return result;
    }
}

export interface IDeviceSync {
    deviceId: string | undefined;
    deviceName: string | undefined;
    accessToken: string | undefined;
}

export class GetListCamera implements IGetListCamera {
    cameraLink: string | undefined;
    tramId: number | undefined;
    tenCam: string | undefined;

    constructor(data?: IGetListCamera) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cameraLink = _data["cameraLink"];
            this.tramId = _data["tramId"];
            this.tenCam = _data["tenCam"];
        }
    }

    static fromJS(data: any): GetListCamera {
        data = typeof data === 'object' ? data : {};
        let result = new GetListCamera();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cameraLink"] = this.cameraLink;
        data["tramId"] = this.tramId;
        data["tenCam"] = this.tenCam;
        return data; 
    }

    clone(): GetListCamera {
        const json = this.toJSON();
        let result = new GetListCamera();
        result.init(json);
        return result;
    }
}

export interface IGetListCamera {
    cameraLink: string | undefined;
    tramId: number | undefined;
    tenCam: string | undefined;
}

export class ThietBiDto implements IThietBiDto {
    ten: string | undefined;
    maThietBi: string | undefined;
    tbEntityId: string | undefined;
    accessToken: string | undefined;
    loaiThietBi: LoaiThietBi;
    tramId: number;
    tram: Tram;
    ghiChu: string | undefined;
    cameraLink: string | undefined;
    boCanhBaoId: number | undefined;
    boCanhBao: BoCanhBao;
    tenLoaiThietBi: string | undefined;
    xacThucThietBi: number | undefined;
    id: number | undefined;

    constructor(data?: IThietBiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.maThietBi = _data["maThietBi"];
            this.tbEntityId = _data["tbEntityId"];
            this.accessToken = _data["accessToken"];
            this.loaiThietBi = _data["loaiThietBi"];
            this.tramId = _data["tramId"];
            this.tram = _data["tram"] ? Tram.fromJS(_data["tram"]) : <any>undefined;
            this.ghiChu = _data["ghiChu"];
            this.cameraLink = _data["cameraLink"];
            this.boCanhBaoId = _data["boCanhBaoId"];
            this.boCanhBao = _data["boCanhBao"] ? BoCanhBao.fromJS(_data["boCanhBao"]) : <any>undefined;
            this.tenLoaiThietBi = _data["tenLoaiThietBi"];
            this.xacThucThietBi = _data["xacThucThietBi"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ThietBiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThietBiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["maThietBi"] = this.maThietBi;
        data["tbEntityId"] = this.tbEntityId;
        data["accessToken"] = this.accessToken;
        data["loaiThietBi"] = this.loaiThietBi;
        data["tramId"] = this.tramId;
        data["tram"] = this.tram ? this.tram.toJSON() : <any>undefined;
        data["ghiChu"] = this.ghiChu;
        data["cameraLink"] = this.cameraLink;
        data["boCanhBaoId"] = this.boCanhBaoId;
        data["boCanhBao"] = this.boCanhBao ? this.boCanhBao.toJSON() : <any>undefined;
        data["tenLoaiThietBi"] = this.tenLoaiThietBi;
        data["xacThucThietBi"] = this.xacThucThietBi;
        data["id"] = this.id;
        return data; 
    }

    clone(): ThietBiDto {
        const json = this.toJSON();
        let result = new ThietBiDto();
        result.init(json);
        return result;
    }
}

export interface IThietBiDto {
    ten: string | undefined;
    maThietBi: string | undefined;
    tbEntityId: string | undefined;
    accessToken: string | undefined;
    loaiThietBi: LoaiThietBi;
    tramId: number;
    tram: Tram;
    ghiChu: string | undefined;
    cameraLink: string | undefined;
    boCanhBaoId: number | undefined;
    boCanhBao: BoCanhBao;
    tenLoaiThietBi: string | undefined;
    xacThucThietBi: number | undefined;
    id: number | undefined;
}

export class ThietBiDtoPagedResultDto implements IThietBiDtoPagedResultDto {
    totalCount: number;
    items: ThietBiDto[] | undefined;

    constructor(data?: IThietBiDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ThietBiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ThietBiDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThietBiDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ThietBiDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ThietBiDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IThietBiDtoPagedResultDto {
    totalCount: number;
    items: ThietBiDto[] | undefined;
}

export class ChangValueTemplateDto implements IChangValueTemplateDto {
    tramEntityId: string | undefined;
    value: string | undefined;
    keyName: string | undefined;
    changeAt: number;

    constructor(data?: IChangValueTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tramEntityId = _data["tramEntityId"];
            this.value = _data["value"];
            this.keyName = _data["keyName"];
            this.changeAt = _data["changeAt"];
        }
    }

    static fromJS(data: any): ChangValueTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangValueTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tramEntityId"] = this.tramEntityId;
        data["value"] = this.value;
        data["keyName"] = this.keyName;
        data["changeAt"] = this.changeAt;
        return data; 
    }

    clone(): ChangValueTemplateDto {
        const json = this.toJSON();
        let result = new ChangValueTemplateDto();
        result.init(json);
        return result;
    }
}

export interface IChangValueTemplateDto {
    tramEntityId: string | undefined;
    value: string | undefined;
    keyName: string | undefined;
    changeAt: number;
}

export class TrangThaiTram implements ITrangThaiTram {
    trangThaiKetNoiId: number | undefined;
    trangThaiCanhBaoId: number | undefined;
    trangThaiKetNoi: string | undefined;
    trangThaiCanhBao: string | undefined;

    constructor(data?: ITrangThaiTram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trangThaiKetNoiId = _data["trangThaiKetNoiId"];
            this.trangThaiCanhBaoId = _data["trangThaiCanhBaoId"];
            this.trangThaiKetNoi = _data["trangThaiKetNoi"];
            this.trangThaiCanhBao = _data["trangThaiCanhBao"];
        }
    }

    static fromJS(data: any): TrangThaiTram {
        data = typeof data === 'object' ? data : {};
        let result = new TrangThaiTram();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trangThaiKetNoiId"] = this.trangThaiKetNoiId;
        data["trangThaiCanhBaoId"] = this.trangThaiCanhBaoId;
        data["trangThaiKetNoi"] = this.trangThaiKetNoi;
        data["trangThaiCanhBao"] = this.trangThaiCanhBao;
        return data; 
    }

    clone(): TrangThaiTram {
        const json = this.toJSON();
        let result = new TrangThaiTram();
        result.init(json);
        return result;
    }
}

export interface ITrangThaiTram {
    trangThaiKetNoiId: number | undefined;
    trangThaiCanhBaoId: number | undefined;
    trangThaiKetNoi: string | undefined;
    trangThaiCanhBao: string | undefined;
}

export class DSGopTram implements IDSGopTram {
    tramId: number | undefined;
    phanVungId: number | undefined;
    phanVungChaId: number | undefined;
    maTram: string | undefined;
    tenTram: string | undefined;
    diaChi: string | undefined;
    toaDo: string | undefined;
    level: number | undefined;
    phanVung: string | undefined;
    isConfigured: boolean;
    tbEntityId: string | undefined;
    trangThaiKetNoiId: number | undefined;
    trangThaiKetNoi: string | undefined;
    trangThaiCanhBaoId: number | undefined;
    trangThaiCanhBao: string | undefined;

    constructor(data?: IDSGopTram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tramId = _data["tramId"];
            this.phanVungId = _data["phanVungId"];
            this.phanVungChaId = _data["phanVungChaId"];
            this.maTram = _data["maTram"];
            this.tenTram = _data["tenTram"];
            this.diaChi = _data["diaChi"];
            this.toaDo = _data["toaDo"];
            this.level = _data["level"];
            this.phanVung = _data["phanVung"];
            this.isConfigured = _data["isConfigured"];
            this.tbEntityId = _data["tbEntityId"];
            this.trangThaiKetNoiId = _data["trangThaiKetNoiId"];
            this.trangThaiKetNoi = _data["trangThaiKetNoi"];
            this.trangThaiCanhBaoId = _data["trangThaiCanhBaoId"];
            this.trangThaiCanhBao = _data["trangThaiCanhBao"];
        }
    }

    static fromJS(data: any): DSGopTram {
        data = typeof data === 'object' ? data : {};
        let result = new DSGopTram();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tramId"] = this.tramId;
        data["phanVungId"] = this.phanVungId;
        data["phanVungChaId"] = this.phanVungChaId;
        data["maTram"] = this.maTram;
        data["tenTram"] = this.tenTram;
        data["diaChi"] = this.diaChi;
        data["toaDo"] = this.toaDo;
        data["level"] = this.level;
        data["phanVung"] = this.phanVung;
        data["isConfigured"] = this.isConfigured;
        data["tbEntityId"] = this.tbEntityId;
        data["trangThaiKetNoiId"] = this.trangThaiKetNoiId;
        data["trangThaiKetNoi"] = this.trangThaiKetNoi;
        data["trangThaiCanhBaoId"] = this.trangThaiCanhBaoId;
        data["trangThaiCanhBao"] = this.trangThaiCanhBao;
        return data; 
    }

    clone(): DSGopTram {
        const json = this.toJSON();
        let result = new DSGopTram();
        result.init(json);
        return result;
    }
}

export interface IDSGopTram {
    tramId: number | undefined;
    phanVungId: number | undefined;
    phanVungChaId: number | undefined;
    maTram: string | undefined;
    tenTram: string | undefined;
    diaChi: string | undefined;
    toaDo: string | undefined;
    level: number | undefined;
    phanVung: string | undefined;
    isConfigured: boolean;
    tbEntityId: string | undefined;
    trangThaiKetNoiId: number | undefined;
    trangThaiKetNoi: string | undefined;
    trangThaiCanhBaoId: number | undefined;
    trangThaiCanhBao: string | undefined;
}

export class DanhSachTramView implements IDanhSachTramView {
    data: DSGopTram;
    children: DanhSachTramView[] | undefined;
    expanded: boolean;

    constructor(data?: IDanhSachTramView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? DSGopTram.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children.push(DanhSachTramView.fromJS(item));
            }
            this.expanded = _data["expanded"];
        }
    }

    static fromJS(data: any): DanhSachTramView {
        data = typeof data === 'object' ? data : {};
        let result = new DanhSachTramView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["expanded"] = this.expanded;
        return data; 
    }

    clone(): DanhSachTramView {
        const json = this.toJSON();
        let result = new DanhSachTramView();
        result.init(json);
        return result;
    }
}

export interface IDanhSachTramView {
    data: DSGopTram;
    children: DanhSachTramView[] | undefined;
    expanded: boolean;
}

export class TramDto implements ITramDto {
    ten: string | undefined;
    maTram: string | undefined;
    diaChi: string | undefined;
    toaDo: Point;
    loaiNguonDien: number | undefined;
    tbEntityId: string | undefined;
    accessToken: string | undefined;
    ghiChu: string | undefined;
    phanVungTram: PhanVungTram[] | undefined;
    tramNhanVien: TramNhanVien[] | undefined;
    thietBi: ThietBi[] | undefined;
    mauDieuKhienId: number | undefined;
    mauDieuKhien: MauDieuKhien;
    mauCanhBaoId: number | undefined;
    mauCanhBao: MauCanhBao;
    tramDieuKhienThuocTinh: TramDieuKhienThuocTinh[] | undefined;
    tramCanhBaoThuocTinh: TramCanhBaoThuocTinh[] | undefined;
    id: number;

    constructor(data?: ITramDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.maTram = _data["maTram"];
            this.diaChi = _data["diaChi"];
            this.toaDo = _data["toaDo"] ? Point.fromJS(_data["toaDo"]) : <any>undefined;
            this.loaiNguonDien = _data["loaiNguonDien"];
            this.tbEntityId = _data["tbEntityId"];
            this.accessToken = _data["accessToken"];
            this.ghiChu = _data["ghiChu"];
            if (Array.isArray(_data["phanVungTram"])) {
                this.phanVungTram = [] as any;
                for (let item of _data["phanVungTram"])
                    this.phanVungTram.push(PhanVungTram.fromJS(item));
            }
            if (Array.isArray(_data["tramNhanVien"])) {
                this.tramNhanVien = [] as any;
                for (let item of _data["tramNhanVien"])
                    this.tramNhanVien.push(TramNhanVien.fromJS(item));
            }
            if (Array.isArray(_data["thietBi"])) {
                this.thietBi = [] as any;
                for (let item of _data["thietBi"])
                    this.thietBi.push(ThietBi.fromJS(item));
            }
            this.mauDieuKhienId = _data["mauDieuKhienId"];
            this.mauDieuKhien = _data["mauDieuKhien"] ? MauDieuKhien.fromJS(_data["mauDieuKhien"]) : <any>undefined;
            this.mauCanhBaoId = _data["mauCanhBaoId"];
            this.mauCanhBao = _data["mauCanhBao"] ? MauCanhBao.fromJS(_data["mauCanhBao"]) : <any>undefined;
            if (Array.isArray(_data["tramDieuKhienThuocTinh"])) {
                this.tramDieuKhienThuocTinh = [] as any;
                for (let item of _data["tramDieuKhienThuocTinh"])
                    this.tramDieuKhienThuocTinh.push(TramDieuKhienThuocTinh.fromJS(item));
            }
            if (Array.isArray(_data["tramCanhBaoThuocTinh"])) {
                this.tramCanhBaoThuocTinh = [] as any;
                for (let item of _data["tramCanhBaoThuocTinh"])
                    this.tramCanhBaoThuocTinh.push(TramCanhBaoThuocTinh.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TramDto {
        data = typeof data === 'object' ? data : {};
        let result = new TramDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["maTram"] = this.maTram;
        data["diaChi"] = this.diaChi;
        data["toaDo"] = this.toaDo ? this.toaDo.toJSON() : <any>undefined;
        data["loaiNguonDien"] = this.loaiNguonDien;
        data["tbEntityId"] = this.tbEntityId;
        data["accessToken"] = this.accessToken;
        data["ghiChu"] = this.ghiChu;
        if (Array.isArray(this.phanVungTram)) {
            data["phanVungTram"] = [];
            for (let item of this.phanVungTram)
                data["phanVungTram"].push(item.toJSON());
        }
        if (Array.isArray(this.tramNhanVien)) {
            data["tramNhanVien"] = [];
            for (let item of this.tramNhanVien)
                data["tramNhanVien"].push(item.toJSON());
        }
        if (Array.isArray(this.thietBi)) {
            data["thietBi"] = [];
            for (let item of this.thietBi)
                data["thietBi"].push(item.toJSON());
        }
        data["mauDieuKhienId"] = this.mauDieuKhienId;
        data["mauDieuKhien"] = this.mauDieuKhien ? this.mauDieuKhien.toJSON() : <any>undefined;
        data["mauCanhBaoId"] = this.mauCanhBaoId;
        data["mauCanhBao"] = this.mauCanhBao ? this.mauCanhBao.toJSON() : <any>undefined;
        if (Array.isArray(this.tramDieuKhienThuocTinh)) {
            data["tramDieuKhienThuocTinh"] = [];
            for (let item of this.tramDieuKhienThuocTinh)
                data["tramDieuKhienThuocTinh"].push(item.toJSON());
        }
        if (Array.isArray(this.tramCanhBaoThuocTinh)) {
            data["tramCanhBaoThuocTinh"] = [];
            for (let item of this.tramCanhBaoThuocTinh)
                data["tramCanhBaoThuocTinh"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): TramDto {
        const json = this.toJSON();
        let result = new TramDto();
        result.init(json);
        return result;
    }
}

export interface ITramDto {
    ten: string | undefined;
    maTram: string | undefined;
    diaChi: string | undefined;
    toaDo: Point;
    loaiNguonDien: number | undefined;
    tbEntityId: string | undefined;
    accessToken: string | undefined;
    ghiChu: string | undefined;
    phanVungTram: PhanVungTram[] | undefined;
    tramNhanVien: TramNhanVien[] | undefined;
    thietBi: ThietBi[] | undefined;
    mauDieuKhienId: number | undefined;
    mauDieuKhien: MauDieuKhien;
    mauCanhBaoId: number | undefined;
    mauCanhBao: MauCanhBao;
    tramDieuKhienThuocTinh: TramDieuKhienThuocTinh[] | undefined;
    tramCanhBaoThuocTinh: TramCanhBaoThuocTinh[] | undefined;
    id: number;
}

export class TramViewDetailDto implements ITramViewDetailDto {
    tram: TramDto;
    phanVungString: string | undefined;

    constructor(data?: ITramViewDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tram = _data["tram"] ? TramDto.fromJS(_data["tram"]) : <any>undefined;
            this.phanVungString = _data["phanVungString"];
        }
    }

    static fromJS(data: any): TramViewDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new TramViewDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tram"] = this.tram ? this.tram.toJSON() : <any>undefined;
        data["phanVungString"] = this.phanVungString;
        return data; 
    }

    clone(): TramViewDetailDto {
        const json = this.toJSON();
        let result = new TramViewDetailDto();
        result.init(json);
        return result;
    }
}

export interface ITramViewDetailDto {
    tram: TramDto;
    phanVungString: string | undefined;
}

export class TramJsonDto implements ITramJsonDto {
    tramId: number | undefined;
    tbTramId: string | undefined;
    tenTram: string | undefined;
    maTram: string | undefined;
    long: number;
    lat: number;
    diaChi: string | undefined;

    constructor(data?: ITramJsonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tramId = _data["tramId"];
            this.tbTramId = _data["tbTramId"];
            this.tenTram = _data["tenTram"];
            this.maTram = _data["maTram"];
            this.long = _data["long"];
            this.lat = _data["lat"];
            this.diaChi = _data["diaChi"];
        }
    }

    static fromJS(data: any): TramJsonDto {
        data = typeof data === 'object' ? data : {};
        let result = new TramJsonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tramId"] = this.tramId;
        data["tbTramId"] = this.tbTramId;
        data["tenTram"] = this.tenTram;
        data["maTram"] = this.maTram;
        data["long"] = this.long;
        data["lat"] = this.lat;
        data["diaChi"] = this.diaChi;
        return data; 
    }

    clone(): TramJsonDto {
        const json = this.toJSON();
        let result = new TramJsonDto();
        result.init(json);
        return result;
    }
}

export interface ITramJsonDto {
    tramId: number | undefined;
    tbTramId: string | undefined;
    tenTram: string | undefined;
    maTram: string | undefined;
    long: number;
    lat: number;
    diaChi: string | undefined;
}

export class Geometry1 implements IGeometry1 {
    coordinates: number[] | undefined;
    type: string | undefined;

    constructor(data?: IGeometry1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["coordinates"])) {
                this.coordinates = [] as any;
                for (let item of _data["coordinates"])
                    this.coordinates.push(item);
            }
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): Geometry1 {
        data = typeof data === 'object' ? data : {};
        let result = new Geometry1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.coordinates)) {
            data["coordinates"] = [];
            for (let item of this.coordinates)
                data["coordinates"].push(item);
        }
        data["type"] = this.type;
        return data; 
    }

    clone(): Geometry1 {
        const json = this.toJSON();
        let result = new Geometry1();
        result.init(json);
        return result;
    }
}

export interface IGeometry1 {
    coordinates: number[] | undefined;
    type: string | undefined;
}

export class Properties1 implements IProperties1 {
    label: string | undefined;
    score: number;
    type: string | undefined;
    importance: number;
    id: string | undefined;
    name: string | undefined;
    city: string | undefined;
    citycode: number;
    context: string | undefined;
    distance: number;
    postcode: number;
    x: number;
    y: number;

    constructor(data?: IProperties1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.score = _data["score"];
            this.type = _data["type"];
            this.importance = _data["importance"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.city = _data["city"];
            this.citycode = _data["citycode"];
            this.context = _data["context"];
            this.distance = _data["distance"];
            this.postcode = _data["postcode"];
            this.x = _data["x"];
            this.y = _data["y"];
        }
    }

    static fromJS(data: any): Properties1 {
        data = typeof data === 'object' ? data : {};
        let result = new Properties1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["score"] = this.score;
        data["type"] = this.type;
        data["importance"] = this.importance;
        data["id"] = this.id;
        data["name"] = this.name;
        data["city"] = this.city;
        data["citycode"] = this.citycode;
        data["context"] = this.context;
        data["distance"] = this.distance;
        data["postcode"] = this.postcode;
        data["x"] = this.x;
        data["y"] = this.y;
        return data; 
    }

    clone(): Properties1 {
        const json = this.toJSON();
        let result = new Properties1();
        result.init(json);
        return result;
    }
}

export interface IProperties1 {
    label: string | undefined;
    score: number;
    type: string | undefined;
    importance: number;
    id: string | undefined;
    name: string | undefined;
    city: string | undefined;
    citycode: number;
    context: string | undefined;
    distance: number;
    postcode: number;
    x: number;
    y: number;
}

export class Features1 implements IFeatures1 {
    geometry: Geometry1;
    properties: Properties1;

    constructor(data?: IFeatures1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.geometry = _data["geometry"] ? Geometry1.fromJS(_data["geometry"]) : <any>undefined;
            this.properties = _data["properties"] ? Properties1.fromJS(_data["properties"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Features1 {
        data = typeof data === 'object' ? data : {};
        let result = new Features1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["geometry"] = this.geometry ? this.geometry.toJSON() : <any>undefined;
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        return data; 
    }

    clone(): Features1 {
        const json = this.toJSON();
        let result = new Features1();
        result.init(json);
        return result;
    }
}

export interface IFeatures1 {
    geometry: Geometry1;
    properties: Properties1;
}

export class SuggestionDto implements ISuggestionDto {
    center: number[] | undefined;
    features: Features1[] | undefined;

    constructor(data?: ISuggestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["center"])) {
                this.center = [] as any;
                for (let item of _data["center"])
                    this.center.push(item);
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features.push(Features1.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SuggestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SuggestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.center)) {
            data["center"] = [];
            for (let item of this.center)
                data["center"].push(item);
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SuggestionDto {
        const json = this.toJSON();
        let result = new SuggestionDto();
        result.init(json);
        return result;
    }
}

export interface ISuggestionDto {
    center: number[] | undefined;
    features: Features1[] | undefined;
}

export class TreeviewItemDto implements ITreeviewItemDto {
    text: string | undefined;
    value: number | undefined;
    collapsed: boolean | undefined;
    checked: boolean | undefined;
    disabled: boolean | undefined;
    children: TreeviewItemDto[] | undefined;

    constructor(data?: ITreeviewItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.value = _data["value"];
            this.collapsed = _data["collapsed"];
            this.checked = _data["checked"];
            this.disabled = _data["disabled"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children.push(TreeviewItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TreeviewItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreeviewItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["value"] = this.value;
        data["collapsed"] = this.collapsed;
        data["checked"] = this.checked;
        data["disabled"] = this.disabled;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TreeviewItemDto {
        const json = this.toJSON();
        let result = new TreeviewItemDto();
        result.init(json);
        return result;
    }
}

export interface ITreeviewItemDto {
    text: string | undefined;
    value: number | undefined;
    collapsed: boolean | undefined;
    checked: boolean | undefined;
    disabled: boolean | undefined;
    children: TreeviewItemDto[] | undefined;
}

export class ThuocTinhDieuKhienTramDto implements IThuocTinhDieuKhienTramDto {
    tramId: number;
    mauThuocTinhId: number;
    boolValue: boolean | undefined;
    stringValue: string | undefined;
    longValue: number | undefined;
    doubleValue: number | undefined;
    jsonValue: string | undefined;
    mauThuocTinh: MauThuocTinh;

    constructor(data?: IThuocTinhDieuKhienTramDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tramId = _data["tramId"];
            this.mauThuocTinhId = _data["mauThuocTinhId"];
            this.boolValue = _data["boolValue"];
            this.stringValue = _data["stringValue"];
            this.longValue = _data["longValue"];
            this.doubleValue = _data["doubleValue"];
            this.jsonValue = _data["jsonValue"];
            this.mauThuocTinh = _data["mauThuocTinh"] ? MauThuocTinh.fromJS(_data["mauThuocTinh"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ThuocTinhDieuKhienTramDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThuocTinhDieuKhienTramDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tramId"] = this.tramId;
        data["mauThuocTinhId"] = this.mauThuocTinhId;
        data["boolValue"] = this.boolValue;
        data["stringValue"] = this.stringValue;
        data["longValue"] = this.longValue;
        data["doubleValue"] = this.doubleValue;
        data["jsonValue"] = this.jsonValue;
        data["mauThuocTinh"] = this.mauThuocTinh ? this.mauThuocTinh.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ThuocTinhDieuKhienTramDto {
        const json = this.toJSON();
        let result = new ThuocTinhDieuKhienTramDto();
        result.init(json);
        return result;
    }
}

export interface IThuocTinhDieuKhienTramDto {
    tramId: number;
    mauThuocTinhId: number;
    boolValue: boolean | undefined;
    stringValue: string | undefined;
    longValue: number | undefined;
    doubleValue: number | undefined;
    jsonValue: string | undefined;
    mauThuocTinh: MauThuocTinh;
}

export class ThuocTinhCanhBaoTramDto implements IThuocTinhCanhBaoTramDto {
    tramId: number;
    mauThuocTinhId: number;
    boolValue: boolean | undefined;
    stringValue: string | undefined;
    longValue: number | undefined;
    doubleValue: number | undefined;
    jsonValue: string | undefined;
    mauThuocTinh: MauThuocTinh;

    constructor(data?: IThuocTinhCanhBaoTramDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tramId = _data["tramId"];
            this.mauThuocTinhId = _data["mauThuocTinhId"];
            this.boolValue = _data["boolValue"];
            this.stringValue = _data["stringValue"];
            this.longValue = _data["longValue"];
            this.doubleValue = _data["doubleValue"];
            this.jsonValue = _data["jsonValue"];
            this.mauThuocTinh = _data["mauThuocTinh"] ? MauThuocTinh.fromJS(_data["mauThuocTinh"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ThuocTinhCanhBaoTramDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThuocTinhCanhBaoTramDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tramId"] = this.tramId;
        data["mauThuocTinhId"] = this.mauThuocTinhId;
        data["boolValue"] = this.boolValue;
        data["stringValue"] = this.stringValue;
        data["longValue"] = this.longValue;
        data["doubleValue"] = this.doubleValue;
        data["jsonValue"] = this.jsonValue;
        data["mauThuocTinh"] = this.mauThuocTinh ? this.mauThuocTinh.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ThuocTinhCanhBaoTramDto {
        const json = this.toJSON();
        let result = new ThuocTinhCanhBaoTramDto();
        result.init(json);
        return result;
    }
}

export interface IThuocTinhCanhBaoTramDto {
    tramId: number;
    mauThuocTinhId: number;
    boolValue: boolean | undefined;
    stringValue: string | undefined;
    longValue: number | undefined;
    doubleValue: number | undefined;
    jsonValue: string | undefined;
    mauThuocTinh: MauThuocTinh;
}

export class CreateOrEditDanhMucTramDto implements ICreateOrEditDanhMucTramDto {
    ten: string | undefined;
    maTram: string | undefined;
    diaChi: string | undefined;
    toaDo: Point;
    tbEntityId: string | undefined;
    accessToken: string | undefined;
    loaiNguonDien: number | undefined;
    ghiChu: string | undefined;
    phanVungTram: PhanVungTram[] | undefined;
    tramNhanVien: TramNhanVien[] | undefined;
    thietBi: ThietBi[] | undefined;
    mauDieuKhienId: number | undefined;
    mauDieuKhien: MauDieuKhien;
    mauCanhBaoId: number | undefined;
    mauCanhBao: MauCanhBao;
    tramDieuKhienThuocTinh: TramDieuKhienThuocTinh[] | undefined;
    tramCanhBaoThuocTinh: TramCanhBaoThuocTinh[] | undefined;
    toaDoX: number | undefined;
    toaDoY: number | undefined;
    thuocTinhDieuKhien: ThuocTinhDieuKhienTramDto[] | undefined;
    thuocTinhCanhBao: ThuocTinhCanhBaoTramDto[] | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditDanhMucTramDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.maTram = _data["maTram"];
            this.diaChi = _data["diaChi"];
            this.toaDo = _data["toaDo"] ? Point.fromJS(_data["toaDo"]) : <any>undefined;
            this.tbEntityId = _data["tbEntityId"];
            this.accessToken = _data["accessToken"];
            this.loaiNguonDien = _data["loaiNguonDien"];
            this.ghiChu = _data["ghiChu"];
            if (Array.isArray(_data["phanVungTram"])) {
                this.phanVungTram = [] as any;
                for (let item of _data["phanVungTram"])
                    this.phanVungTram.push(PhanVungTram.fromJS(item));
            }
            if (Array.isArray(_data["tramNhanVien"])) {
                this.tramNhanVien = [] as any;
                for (let item of _data["tramNhanVien"])
                    this.tramNhanVien.push(TramNhanVien.fromJS(item));
            }
            if (Array.isArray(_data["thietBi"])) {
                this.thietBi = [] as any;
                for (let item of _data["thietBi"])
                    this.thietBi.push(ThietBi.fromJS(item));
            }
            this.mauDieuKhienId = _data["mauDieuKhienId"];
            this.mauDieuKhien = _data["mauDieuKhien"] ? MauDieuKhien.fromJS(_data["mauDieuKhien"]) : <any>undefined;
            this.mauCanhBaoId = _data["mauCanhBaoId"];
            this.mauCanhBao = _data["mauCanhBao"] ? MauCanhBao.fromJS(_data["mauCanhBao"]) : <any>undefined;
            if (Array.isArray(_data["tramDieuKhienThuocTinh"])) {
                this.tramDieuKhienThuocTinh = [] as any;
                for (let item of _data["tramDieuKhienThuocTinh"])
                    this.tramDieuKhienThuocTinh.push(TramDieuKhienThuocTinh.fromJS(item));
            }
            if (Array.isArray(_data["tramCanhBaoThuocTinh"])) {
                this.tramCanhBaoThuocTinh = [] as any;
                for (let item of _data["tramCanhBaoThuocTinh"])
                    this.tramCanhBaoThuocTinh.push(TramCanhBaoThuocTinh.fromJS(item));
            }
            this.toaDoX = _data["toaDoX"];
            this.toaDoY = _data["toaDoY"];
            if (Array.isArray(_data["thuocTinhDieuKhien"])) {
                this.thuocTinhDieuKhien = [] as any;
                for (let item of _data["thuocTinhDieuKhien"])
                    this.thuocTinhDieuKhien.push(ThuocTinhDieuKhienTramDto.fromJS(item));
            }
            if (Array.isArray(_data["thuocTinhCanhBao"])) {
                this.thuocTinhCanhBao = [] as any;
                for (let item of _data["thuocTinhCanhBao"])
                    this.thuocTinhCanhBao.push(ThuocTinhCanhBaoTramDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditDanhMucTramDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDanhMucTramDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["maTram"] = this.maTram;
        data["diaChi"] = this.diaChi;
        data["toaDo"] = this.toaDo ? this.toaDo.toJSON() : <any>undefined;
        data["tbEntityId"] = this.tbEntityId;
        data["accessToken"] = this.accessToken;
        data["loaiNguonDien"] = this.loaiNguonDien;
        data["ghiChu"] = this.ghiChu;
        if (Array.isArray(this.phanVungTram)) {
            data["phanVungTram"] = [];
            for (let item of this.phanVungTram)
                data["phanVungTram"].push(item.toJSON());
        }
        if (Array.isArray(this.tramNhanVien)) {
            data["tramNhanVien"] = [];
            for (let item of this.tramNhanVien)
                data["tramNhanVien"].push(item.toJSON());
        }
        if (Array.isArray(this.thietBi)) {
            data["thietBi"] = [];
            for (let item of this.thietBi)
                data["thietBi"].push(item.toJSON());
        }
        data["mauDieuKhienId"] = this.mauDieuKhienId;
        data["mauDieuKhien"] = this.mauDieuKhien ? this.mauDieuKhien.toJSON() : <any>undefined;
        data["mauCanhBaoId"] = this.mauCanhBaoId;
        data["mauCanhBao"] = this.mauCanhBao ? this.mauCanhBao.toJSON() : <any>undefined;
        if (Array.isArray(this.tramDieuKhienThuocTinh)) {
            data["tramDieuKhienThuocTinh"] = [];
            for (let item of this.tramDieuKhienThuocTinh)
                data["tramDieuKhienThuocTinh"].push(item.toJSON());
        }
        if (Array.isArray(this.tramCanhBaoThuocTinh)) {
            data["tramCanhBaoThuocTinh"] = [];
            for (let item of this.tramCanhBaoThuocTinh)
                data["tramCanhBaoThuocTinh"].push(item.toJSON());
        }
        data["toaDoX"] = this.toaDoX;
        data["toaDoY"] = this.toaDoY;
        if (Array.isArray(this.thuocTinhDieuKhien)) {
            data["thuocTinhDieuKhien"] = [];
            for (let item of this.thuocTinhDieuKhien)
                data["thuocTinhDieuKhien"].push(item.toJSON());
        }
        if (Array.isArray(this.thuocTinhCanhBao)) {
            data["thuocTinhCanhBao"] = [];
            for (let item of this.thuocTinhCanhBao)
                data["thuocTinhCanhBao"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditDanhMucTramDto {
        const json = this.toJSON();
        let result = new CreateOrEditDanhMucTramDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditDanhMucTramDto {
    ten: string | undefined;
    maTram: string | undefined;
    diaChi: string | undefined;
    toaDo: Point;
    tbEntityId: string | undefined;
    accessToken: string | undefined;
    loaiNguonDien: number | undefined;
    ghiChu: string | undefined;
    phanVungTram: PhanVungTram[] | undefined;
    tramNhanVien: TramNhanVien[] | undefined;
    thietBi: ThietBi[] | undefined;
    mauDieuKhienId: number | undefined;
    mauDieuKhien: MauDieuKhien;
    mauCanhBaoId: number | undefined;
    mauCanhBao: MauCanhBao;
    tramDieuKhienThuocTinh: TramDieuKhienThuocTinh[] | undefined;
    tramCanhBaoThuocTinh: TramCanhBaoThuocTinh[] | undefined;
    toaDoX: number | undefined;
    toaDoY: number | undefined;
    thuocTinhDieuKhien: ThuocTinhDieuKhienTramDto[] | undefined;
    thuocTinhCanhBao: ThuocTinhCanhBaoTramDto[] | undefined;
    id: number | undefined;
}

export class TramDtoPagedResultDto implements ITramDtoPagedResultDto {
    totalCount: number;
    items: TramDto[] | undefined;

    constructor(data?: ITramDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TramDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TramDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TramDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TramDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TramDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITramDtoPagedResultDto {
    totalCount: number;
    items: TramDto[] | undefined;
}

export class ThuocTinhDieuKhienTramInput implements IThuocTinhDieuKhienTramInput {
    tramId: number;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IThuocTinhDieuKhienTramInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tramId = _data["tramId"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): ThuocTinhDieuKhienTramInput {
        data = typeof data === 'object' ? data : {};
        let result = new ThuocTinhDieuKhienTramInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tramId"] = this.tramId;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): ThuocTinhDieuKhienTramInput {
        const json = this.toJSON();
        let result = new ThuocTinhDieuKhienTramInput();
        result.init(json);
        return result;
    }
}

export interface IThuocTinhDieuKhienTramInput {
    tramId: number;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class ThuocTinhDieuKhienTram implements IThuocTinhDieuKhienTram {
    tramId: number;
    mauThuocTinhId: number;
    boolValue: boolean | undefined;
    stringValue: string | undefined;
    longValue: number | undefined;
    doubleValue: number | undefined;
    jsonValue: string | undefined;
    tram: Tram;
    mauThuocTinh: MauThuocTinh;

    constructor(data?: IThuocTinhDieuKhienTram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tramId = _data["tramId"];
            this.mauThuocTinhId = _data["mauThuocTinhId"];
            this.boolValue = _data["boolValue"];
            this.stringValue = _data["stringValue"];
            this.longValue = _data["longValue"];
            this.doubleValue = _data["doubleValue"];
            this.jsonValue = _data["jsonValue"];
            this.tram = _data["tram"] ? Tram.fromJS(_data["tram"]) : <any>undefined;
            this.mauThuocTinh = _data["mauThuocTinh"] ? MauThuocTinh.fromJS(_data["mauThuocTinh"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ThuocTinhDieuKhienTram {
        data = typeof data === 'object' ? data : {};
        let result = new ThuocTinhDieuKhienTram();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tramId"] = this.tramId;
        data["mauThuocTinhId"] = this.mauThuocTinhId;
        data["boolValue"] = this.boolValue;
        data["stringValue"] = this.stringValue;
        data["longValue"] = this.longValue;
        data["doubleValue"] = this.doubleValue;
        data["jsonValue"] = this.jsonValue;
        data["tram"] = this.tram ? this.tram.toJSON() : <any>undefined;
        data["mauThuocTinh"] = this.mauThuocTinh ? this.mauThuocTinh.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ThuocTinhDieuKhienTram {
        const json = this.toJSON();
        let result = new ThuocTinhDieuKhienTram();
        result.init(json);
        return result;
    }
}

export interface IThuocTinhDieuKhienTram {
    tramId: number;
    mauThuocTinhId: number;
    boolValue: boolean | undefined;
    stringValue: string | undefined;
    longValue: number | undefined;
    doubleValue: number | undefined;
    jsonValue: string | undefined;
    tram: Tram;
    mauThuocTinh: MauThuocTinh;
}

export class ThuocTinhDieuKhienTramPagedResultDto implements IThuocTinhDieuKhienTramPagedResultDto {
    totalCount: number;
    items: ThuocTinhDieuKhienTram[] | undefined;

    constructor(data?: IThuocTinhDieuKhienTramPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ThuocTinhDieuKhienTram.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ThuocTinhDieuKhienTramPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThuocTinhDieuKhienTramPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ThuocTinhDieuKhienTramPagedResultDto {
        const json = this.toJSON();
        let result = new ThuocTinhDieuKhienTramPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IThuocTinhDieuKhienTramPagedResultDto {
    totalCount: number;
    items: ThuocTinhDieuKhienTram[] | undefined;
}

export class ThuocTinhCanhBaoTram implements IThuocTinhCanhBaoTram {
    tramId: number;
    mauThuocTinhId: number;
    boolValue: boolean | undefined;
    stringValue: string | undefined;
    longValue: number | undefined;
    doubleValue: number | undefined;
    jsonValue: string | undefined;
    tram: Tram;
    mauThuocTinh: MauThuocTinh;

    constructor(data?: IThuocTinhCanhBaoTram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tramId = _data["tramId"];
            this.mauThuocTinhId = _data["mauThuocTinhId"];
            this.boolValue = _data["boolValue"];
            this.stringValue = _data["stringValue"];
            this.longValue = _data["longValue"];
            this.doubleValue = _data["doubleValue"];
            this.jsonValue = _data["jsonValue"];
            this.tram = _data["tram"] ? Tram.fromJS(_data["tram"]) : <any>undefined;
            this.mauThuocTinh = _data["mauThuocTinh"] ? MauThuocTinh.fromJS(_data["mauThuocTinh"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ThuocTinhCanhBaoTram {
        data = typeof data === 'object' ? data : {};
        let result = new ThuocTinhCanhBaoTram();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tramId"] = this.tramId;
        data["mauThuocTinhId"] = this.mauThuocTinhId;
        data["boolValue"] = this.boolValue;
        data["stringValue"] = this.stringValue;
        data["longValue"] = this.longValue;
        data["doubleValue"] = this.doubleValue;
        data["jsonValue"] = this.jsonValue;
        data["tram"] = this.tram ? this.tram.toJSON() : <any>undefined;
        data["mauThuocTinh"] = this.mauThuocTinh ? this.mauThuocTinh.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ThuocTinhCanhBaoTram {
        const json = this.toJSON();
        let result = new ThuocTinhCanhBaoTram();
        result.init(json);
        return result;
    }
}

export interface IThuocTinhCanhBaoTram {
    tramId: number;
    mauThuocTinhId: number;
    boolValue: boolean | undefined;
    stringValue: string | undefined;
    longValue: number | undefined;
    doubleValue: number | undefined;
    jsonValue: string | undefined;
    tram: Tram;
    mauThuocTinh: MauThuocTinh;
}

export class ThuocTinhCanhBaoTramPagedResultDto implements IThuocTinhCanhBaoTramPagedResultDto {
    totalCount: number;
    items: ThuocTinhCanhBaoTram[] | undefined;

    constructor(data?: IThuocTinhCanhBaoTramPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ThuocTinhCanhBaoTram.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ThuocTinhCanhBaoTramPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThuocTinhCanhBaoTramPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ThuocTinhCanhBaoTramPagedResultDto {
        const json = this.toJSON();
        let result = new ThuocTinhCanhBaoTramPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IThuocTinhCanhBaoTramPagedResultDto {
    totalCount: number;
    items: ThuocTinhCanhBaoTram[] | undefined;
}

export class DanhSachCanhBaoOutput implements IDanhSachCanhBaoOutput {
    idCanhBao: string | undefined;
    tramId: number;
    thoiGian: moment.Moment;
    idThietBi: string | undefined;
    thoiGianCanhBao: string | undefined;
    thoiGianCanhBaoLong: number;
    thoiGianCoCanhBao: string | undefined;
    thoiGianCLS: number | undefined;
    thoiGianClsStr: string | undefined;
    loaiCanhBao: string | undefined;
    loaiCanhBaoShow: string | undefined;
    mucDo: string | undefined;
    giaTri: string | undefined;
    trangThai: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IDanhSachCanhBaoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idCanhBao = _data["idCanhBao"];
            this.tramId = _data["tramId"];
            this.thoiGian = _data["thoiGian"] ? moment(_data["thoiGian"].toString()) : <any>undefined;
            this.idThietBi = _data["idThietBi"];
            this.thoiGianCanhBao = _data["thoiGianCanhBao"];
            this.thoiGianCanhBaoLong = _data["thoiGianCanhBaoLong"];
            this.thoiGianCoCanhBao = _data["thoiGianCoCanhBao"];
            this.thoiGianCLS = _data["thoiGianCLS"];
            this.thoiGianClsStr = _data["thoiGianClsStr"];
            this.loaiCanhBao = _data["loaiCanhBao"];
            this.loaiCanhBaoShow = _data["loaiCanhBaoShow"];
            this.mucDo = _data["mucDo"];
            this.giaTri = _data["giaTri"];
            this.trangThai = _data["trangThai"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DanhSachCanhBaoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DanhSachCanhBaoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idCanhBao"] = this.idCanhBao;
        data["tramId"] = this.tramId;
        data["thoiGian"] = this.thoiGian ? this.thoiGian.toISOString() : <any>undefined;
        data["idThietBi"] = this.idThietBi;
        data["thoiGianCanhBao"] = this.thoiGianCanhBao;
        data["thoiGianCanhBaoLong"] = this.thoiGianCanhBaoLong;
        data["thoiGianCoCanhBao"] = this.thoiGianCoCanhBao;
        data["thoiGianCLS"] = this.thoiGianCLS;
        data["thoiGianClsStr"] = this.thoiGianClsStr;
        data["loaiCanhBao"] = this.loaiCanhBao;
        data["loaiCanhBaoShow"] = this.loaiCanhBaoShow;
        data["mucDo"] = this.mucDo;
        data["giaTri"] = this.giaTri;
        data["trangThai"] = this.trangThai;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DanhSachCanhBaoOutput {
        const json = this.toJSON();
        let result = new DanhSachCanhBaoOutput();
        result.init(json);
        return result;
    }
}

export interface IDanhSachCanhBaoOutput {
    idCanhBao: string | undefined;
    tramId: number;
    thoiGian: moment.Moment;
    idThietBi: string | undefined;
    thoiGianCanhBao: string | undefined;
    thoiGianCanhBaoLong: number;
    thoiGianCoCanhBao: string | undefined;
    thoiGianCLS: number | undefined;
    thoiGianClsStr: string | undefined;
    loaiCanhBao: string | undefined;
    loaiCanhBaoShow: string | undefined;
    mucDo: string | undefined;
    giaTri: string | undefined;
    trangThai: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class DanhSachCanhBaoOutputPagedResultDto implements IDanhSachCanhBaoOutputPagedResultDto {
    totalCount: number;
    items: DanhSachCanhBaoOutput[] | undefined;

    constructor(data?: IDanhSachCanhBaoOutputPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DanhSachCanhBaoOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DanhSachCanhBaoOutputPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DanhSachCanhBaoOutputPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DanhSachCanhBaoOutputPagedResultDto {
        const json = this.toJSON();
        let result = new DanhSachCanhBaoOutputPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDanhSachCanhBaoOutputPagedResultDto {
    totalCount: number;
    items: DanhSachCanhBaoOutput[] | undefined;
}

export class QuetThe implements IQuetThe {
    rfidCard: string | undefined;
    trangThai: number;
    thoiGian: moment.Moment | undefined;
    tbTramId: string | undefined;
    tenantId: number;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IQuetThe) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rfidCard = _data["rfidCard"];
            this.trangThai = _data["trangThai"];
            this.thoiGian = _data["thoiGian"] ? moment(_data["thoiGian"].toString()) : <any>undefined;
            this.tbTramId = _data["tbTramId"];
            this.tenantId = _data["tenantId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): QuetThe {
        data = typeof data === 'object' ? data : {};
        let result = new QuetThe();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rfidCard"] = this.rfidCard;
        data["trangThai"] = this.trangThai;
        data["thoiGian"] = this.thoiGian ? this.thoiGian.toISOString() : <any>undefined;
        data["tbTramId"] = this.tbTramId;
        data["tenantId"] = this.tenantId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): QuetThe {
        const json = this.toJSON();
        let result = new QuetThe();
        result.init(json);
        return result;
    }
}

export interface IQuetThe {
    rfidCard: string | undefined;
    trangThai: number;
    thoiGian: moment.Moment | undefined;
    tbTramId: string | undefined;
    tenantId: number;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class QuetTheOutput implements IQuetTheOutput {
    the: QuetThe;
    tenTram: string | undefined;
    tbEntityId: string | undefined;
    idTram: number;
    nhanVienId: number;
    tenNhanVien: string | undefined;

    constructor(data?: IQuetTheOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.the = _data["the"] ? QuetThe.fromJS(_data["the"]) : <any>undefined;
            this.tenTram = _data["tenTram"];
            this.tbEntityId = _data["tbEntityId"];
            this.idTram = _data["idTram"];
            this.nhanVienId = _data["nhanVienId"];
            this.tenNhanVien = _data["tenNhanVien"];
        }
    }

    static fromJS(data: any): QuetTheOutput {
        data = typeof data === 'object' ? data : {};
        let result = new QuetTheOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["the"] = this.the ? this.the.toJSON() : <any>undefined;
        data["tenTram"] = this.tenTram;
        data["tbEntityId"] = this.tbEntityId;
        data["idTram"] = this.idTram;
        data["nhanVienId"] = this.nhanVienId;
        data["tenNhanVien"] = this.tenNhanVien;
        return data; 
    }

    clone(): QuetTheOutput {
        const json = this.toJSON();
        let result = new QuetTheOutput();
        result.init(json);
        return result;
    }
}

export interface IQuetTheOutput {
    the: QuetThe;
    tenTram: string | undefined;
    tbEntityId: string | undefined;
    idTram: number;
    nhanVienId: number;
    tenNhanVien: string | undefined;
}

export class QuetTheOutputPagedResultDto implements IQuetTheOutputPagedResultDto {
    totalCount: number;
    items: QuetTheOutput[] | undefined;

    constructor(data?: IQuetTheOutputPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(QuetTheOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuetTheOutputPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuetTheOutputPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): QuetTheOutputPagedResultDto {
        const json = this.toJSON();
        let result = new QuetTheOutputPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IQuetTheOutputPagedResultDto {
    totalCount: number;
    items: QuetTheOutput[] | undefined;
}

export class QuetTheDto implements IQuetTheDto {
    rfidCard: string | undefined;
    status: number;
    createdAt: number;
    gatewayId: string | undefined;

    constructor(data?: IQuetTheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rfidCard = _data["rfidCard"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"];
            this.gatewayId = _data["gatewayId"];
        }
    }

    static fromJS(data: any): QuetTheDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuetTheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rfidCard"] = this.rfidCard;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt;
        data["gatewayId"] = this.gatewayId;
        return data; 
    }

    clone(): QuetTheDto {
        const json = this.toJSON();
        let result = new QuetTheDto();
        result.init(json);
        return result;
    }
}

export interface IQuetTheDto {
    rfidCard: string | undefined;
    status: number;
    createdAt: number;
    gatewayId: string | undefined;
}

export class SyncDuLieuCamBienInputDto implements ISyncDuLieuCamBienInputDto {
    limit: number;
    tramId: number;
    keys: string | undefined;
    startTs: moment.Moment | undefined;
    endTs: moment.Moment | undefined;

    constructor(data?: ISyncDuLieuCamBienInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.tramId = _data["tramId"];
            this.keys = _data["keys"];
            this.startTs = _data["startTs"] ? moment(_data["startTs"].toString()) : <any>undefined;
            this.endTs = _data["endTs"] ? moment(_data["endTs"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SyncDuLieuCamBienInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SyncDuLieuCamBienInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["tramId"] = this.tramId;
        data["keys"] = this.keys;
        data["startTs"] = this.startTs ? this.startTs.toISOString() : <any>undefined;
        data["endTs"] = this.endTs ? this.endTs.toISOString() : <any>undefined;
        return data; 
    }

    clone(): SyncDuLieuCamBienInputDto {
        const json = this.toJSON();
        let result = new SyncDuLieuCamBienInputDto();
        result.init(json);
        return result;
    }
}

export interface ISyncDuLieuCamBienInputDto {
    limit: number;
    tramId: number;
    keys: string | undefined;
    startTs: moment.Moment | undefined;
    endTs: moment.Moment | undefined;
}

export class DuLieuCamBienOutputDto implements IDuLieuCamBienOutputDto {
    thoiGianCapNhat: moment.Moment;
    duLieu: string | undefined;
    giaTri: string | undefined;
    thoiGianCapNhatLong: number;

    constructor(data?: IDuLieuCamBienOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thoiGianCapNhat = _data["thoiGianCapNhat"] ? moment(_data["thoiGianCapNhat"].toString()) : <any>undefined;
            this.duLieu = _data["duLieu"];
            this.giaTri = _data["giaTri"];
            this.thoiGianCapNhatLong = _data["thoiGianCapNhatLong"];
        }
    }

    static fromJS(data: any): DuLieuCamBienOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DuLieuCamBienOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thoiGianCapNhat"] = this.thoiGianCapNhat ? this.thoiGianCapNhat.toISOString() : <any>undefined;
        data["duLieu"] = this.duLieu;
        data["giaTri"] = this.giaTri;
        data["thoiGianCapNhatLong"] = this.thoiGianCapNhatLong;
        return data; 
    }

    clone(): DuLieuCamBienOutputDto {
        const json = this.toJSON();
        let result = new DuLieuCamBienOutputDto();
        result.init(json);
        return result;
    }
}

export interface IDuLieuCamBienOutputDto {
    thoiGianCapNhat: moment.Moment;
    duLieu: string | undefined;
    giaTri: string | undefined;
    thoiGianCapNhatLong: number;
}

export class DataItem implements IDataItem {
    x: string | undefined;
    y: number;

    constructor(data?: IDataItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.x = _data["x"];
            this.y = _data["y"];
        }
    }

    static fromJS(data: any): DataItem {
        data = typeof data === 'object' ? data : {};
        let result = new DataItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["x"] = this.x;
        data["y"] = this.y;
        return data; 
    }

    clone(): DataItem {
        const json = this.toJSON();
        let result = new DataItem();
        result.init(json);
        return result;
    }
}

export interface IDataItem {
    x: string | undefined;
    y: number;
}

export class Series implements ISeries {
    name: string | undefined;
    data: DataItem[] | undefined;

    constructor(data?: ISeries) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(DataItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Series {
        data = typeof data === 'object' ? data : {};
        let result = new Series();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Series {
        const json = this.toJSON();
        let result = new Series();
        result.init(json);
        return result;
    }
}

export interface ISeries {
    name: string | undefined;
    data: DataItem[] | undefined;
}

export class ListGiaTriBieuDoDto implements IListGiaTriBieuDoDto {
    nhietDo: Series[] | undefined;
    tanSoDienAp: Series[] | undefined;
    nhietDoACCU: Series[] | undefined;
    dienApDC: Series[] | undefined;
    dongDienDC: Series[] | undefined;
    congSuatDC: Series[] | undefined;
    dienApLuoi: Series[] | undefined;
    dienApMayPhat: Series[] | undefined;
    dienApTai: Series[] | undefined;
    dongTai: Series[] | undefined;
    congSuatDienAcPha: Series[] | undefined;

    constructor(data?: IListGiaTriBieuDoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["nhietDo"])) {
                this.nhietDo = [] as any;
                for (let item of _data["nhietDo"])
                    this.nhietDo.push(Series.fromJS(item));
            }
            if (Array.isArray(_data["tanSoDienAp"])) {
                this.tanSoDienAp = [] as any;
                for (let item of _data["tanSoDienAp"])
                    this.tanSoDienAp.push(Series.fromJS(item));
            }
            if (Array.isArray(_data["nhietDoACCU"])) {
                this.nhietDoACCU = [] as any;
                for (let item of _data["nhietDoACCU"])
                    this.nhietDoACCU.push(Series.fromJS(item));
            }
            if (Array.isArray(_data["dienApDC"])) {
                this.dienApDC = [] as any;
                for (let item of _data["dienApDC"])
                    this.dienApDC.push(Series.fromJS(item));
            }
            if (Array.isArray(_data["dongDienDC"])) {
                this.dongDienDC = [] as any;
                for (let item of _data["dongDienDC"])
                    this.dongDienDC.push(Series.fromJS(item));
            }
            if (Array.isArray(_data["congSuatDC"])) {
                this.congSuatDC = [] as any;
                for (let item of _data["congSuatDC"])
                    this.congSuatDC.push(Series.fromJS(item));
            }
            if (Array.isArray(_data["dienApLuoi"])) {
                this.dienApLuoi = [] as any;
                for (let item of _data["dienApLuoi"])
                    this.dienApLuoi.push(Series.fromJS(item));
            }
            if (Array.isArray(_data["dienApMayPhat"])) {
                this.dienApMayPhat = [] as any;
                for (let item of _data["dienApMayPhat"])
                    this.dienApMayPhat.push(Series.fromJS(item));
            }
            if (Array.isArray(_data["dienApTai"])) {
                this.dienApTai = [] as any;
                for (let item of _data["dienApTai"])
                    this.dienApTai.push(Series.fromJS(item));
            }
            if (Array.isArray(_data["dongTai"])) {
                this.dongTai = [] as any;
                for (let item of _data["dongTai"])
                    this.dongTai.push(Series.fromJS(item));
            }
            if (Array.isArray(_data["congSuatDienAcPha"])) {
                this.congSuatDienAcPha = [] as any;
                for (let item of _data["congSuatDienAcPha"])
                    this.congSuatDienAcPha.push(Series.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListGiaTriBieuDoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListGiaTriBieuDoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.nhietDo)) {
            data["nhietDo"] = [];
            for (let item of this.nhietDo)
                data["nhietDo"].push(item.toJSON());
        }
        if (Array.isArray(this.tanSoDienAp)) {
            data["tanSoDienAp"] = [];
            for (let item of this.tanSoDienAp)
                data["tanSoDienAp"].push(item.toJSON());
        }
        if (Array.isArray(this.nhietDoACCU)) {
            data["nhietDoACCU"] = [];
            for (let item of this.nhietDoACCU)
                data["nhietDoACCU"].push(item.toJSON());
        }
        if (Array.isArray(this.dienApDC)) {
            data["dienApDC"] = [];
            for (let item of this.dienApDC)
                data["dienApDC"].push(item.toJSON());
        }
        if (Array.isArray(this.dongDienDC)) {
            data["dongDienDC"] = [];
            for (let item of this.dongDienDC)
                data["dongDienDC"].push(item.toJSON());
        }
        if (Array.isArray(this.congSuatDC)) {
            data["congSuatDC"] = [];
            for (let item of this.congSuatDC)
                data["congSuatDC"].push(item.toJSON());
        }
        if (Array.isArray(this.dienApLuoi)) {
            data["dienApLuoi"] = [];
            for (let item of this.dienApLuoi)
                data["dienApLuoi"].push(item.toJSON());
        }
        if (Array.isArray(this.dienApMayPhat)) {
            data["dienApMayPhat"] = [];
            for (let item of this.dienApMayPhat)
                data["dienApMayPhat"].push(item.toJSON());
        }
        if (Array.isArray(this.dienApTai)) {
            data["dienApTai"] = [];
            for (let item of this.dienApTai)
                data["dienApTai"].push(item.toJSON());
        }
        if (Array.isArray(this.dongTai)) {
            data["dongTai"] = [];
            for (let item of this.dongTai)
                data["dongTai"].push(item.toJSON());
        }
        if (Array.isArray(this.congSuatDienAcPha)) {
            data["congSuatDienAcPha"] = [];
            for (let item of this.congSuatDienAcPha)
                data["congSuatDienAcPha"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListGiaTriBieuDoDto {
        const json = this.toJSON();
        let result = new ListGiaTriBieuDoDto();
        result.init(json);
        return result;
    }
}

export interface IListGiaTriBieuDoDto {
    nhietDo: Series[] | undefined;
    tanSoDienAp: Series[] | undefined;
    nhietDoACCU: Series[] | undefined;
    dienApDC: Series[] | undefined;
    dongDienDC: Series[] | undefined;
    congSuatDC: Series[] | undefined;
    dienApLuoi: Series[] | undefined;
    dienApMayPhat: Series[] | undefined;
    dienApTai: Series[] | undefined;
    dongTai: Series[] | undefined;
    congSuatDienAcPha: Series[] | undefined;
}

export class SyncDuLieuCamBienOutputDto implements ISyncDuLieuCamBienOutputDto {
    dulieuCamBien: DuLieuCamBienOutputDto[] | undefined;
    giaTriBieuDo: ListGiaTriBieuDoDto;
    tenTram: string | undefined;

    constructor(data?: ISyncDuLieuCamBienOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["dulieuCamBien"])) {
                this.dulieuCamBien = [] as any;
                for (let item of _data["dulieuCamBien"])
                    this.dulieuCamBien.push(DuLieuCamBienOutputDto.fromJS(item));
            }
            this.giaTriBieuDo = _data["giaTriBieuDo"] ? ListGiaTriBieuDoDto.fromJS(_data["giaTriBieuDo"]) : <any>undefined;
            this.tenTram = _data["tenTram"];
        }
    }

    static fromJS(data: any): SyncDuLieuCamBienOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SyncDuLieuCamBienOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dulieuCamBien)) {
            data["dulieuCamBien"] = [];
            for (let item of this.dulieuCamBien)
                data["dulieuCamBien"].push(item.toJSON());
        }
        data["giaTriBieuDo"] = this.giaTriBieuDo ? this.giaTriBieuDo.toJSON() : <any>undefined;
        data["tenTram"] = this.tenTram;
        return data; 
    }

    clone(): SyncDuLieuCamBienOutputDto {
        const json = this.toJSON();
        let result = new SyncDuLieuCamBienOutputDto();
        result.init(json);
        return result;
    }
}

export interface ISyncDuLieuCamBienOutputDto {
    dulieuCamBien: DuLieuCamBienOutputDto[] | undefined;
    giaTriBieuDo: ListGiaTriBieuDoDto;
    tenTram: string | undefined;
}

export class LookupTableDLCBDto implements ILookupTableDLCBDto {
    id: string | undefined;
    displayName: string | undefined;

    constructor(data?: ILookupTableDLCBDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): LookupTableDLCBDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupTableDLCBDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): LookupTableDLCBDto {
        const json = this.toJSON();
        let result = new LookupTableDLCBDto();
        result.init(json);
        return result;
    }
}

export interface ILookupTableDLCBDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class DanhSachCamBienDto implements IDanhSachCamBienDto {
    id: number;
    ten: string | undefined;
    maThietBi: string | undefined;
    loaiThietBi: LoaiThietBi;
    tramId: number;
    ghiChu: string | undefined;
    donViDo: string | undefined;
    giaTri: any | undefined;
    thoiGianChayDieuHoa1: any | undefined;
    thoiGianChayDieuHoa2: any | undefined;
    thoiGianChayQuat: any | undefined;
    hienThiThoiGian: number | undefined;
    tbId: string | undefined;
    trangThaiKetNoi: boolean;
    key: string | undefined;
    logo: string | undefined;
    button: string | undefined;
    trai: boolean;
    phai: boolean;

    constructor(data?: IDanhSachCamBienDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ten = _data["ten"];
            this.maThietBi = _data["maThietBi"];
            this.loaiThietBi = _data["loaiThietBi"];
            this.tramId = _data["tramId"];
            this.ghiChu = _data["ghiChu"];
            this.donViDo = _data["donViDo"];
            this.giaTri = _data["giaTri"];
            this.thoiGianChayDieuHoa1 = _data["thoiGianChayDieuHoa1"];
            this.thoiGianChayDieuHoa2 = _data["thoiGianChayDieuHoa2"];
            this.thoiGianChayQuat = _data["thoiGianChayQuat"];
            this.hienThiThoiGian = _data["hienThiThoiGian"];
            this.tbId = _data["tbId"];
            this.trangThaiKetNoi = _data["trangThaiKetNoi"];
            this.key = _data["key"];
            this.logo = _data["logo"];
            this.button = _data["button"];
            this.trai = _data["trai"];
            this.phai = _data["phai"];
        }
    }

    static fromJS(data: any): DanhSachCamBienDto {
        data = typeof data === 'object' ? data : {};
        let result = new DanhSachCamBienDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ten"] = this.ten;
        data["maThietBi"] = this.maThietBi;
        data["loaiThietBi"] = this.loaiThietBi;
        data["tramId"] = this.tramId;
        data["ghiChu"] = this.ghiChu;
        data["donViDo"] = this.donViDo;
        data["giaTri"] = this.giaTri;
        data["thoiGianChayDieuHoa1"] = this.thoiGianChayDieuHoa1;
        data["thoiGianChayDieuHoa2"] = this.thoiGianChayDieuHoa2;
        data["thoiGianChayQuat"] = this.thoiGianChayQuat;
        data["hienThiThoiGian"] = this.hienThiThoiGian;
        data["tbId"] = this.tbId;
        data["trangThaiKetNoi"] = this.trangThaiKetNoi;
        data["key"] = this.key;
        data["logo"] = this.logo;
        data["button"] = this.button;
        data["trai"] = this.trai;
        data["phai"] = this.phai;
        return data; 
    }

    clone(): DanhSachCamBienDto {
        const json = this.toJSON();
        let result = new DanhSachCamBienDto();
        result.init(json);
        return result;
    }
}

export interface IDanhSachCamBienDto {
    id: number;
    ten: string | undefined;
    maThietBi: string | undefined;
    loaiThietBi: LoaiThietBi;
    tramId: number;
    ghiChu: string | undefined;
    donViDo: string | undefined;
    giaTri: any | undefined;
    thoiGianChayDieuHoa1: any | undefined;
    thoiGianChayDieuHoa2: any | undefined;
    thoiGianChayQuat: any | undefined;
    hienThiThoiGian: number | undefined;
    tbId: string | undefined;
    trangThaiKetNoi: boolean;
    key: string | undefined;
    logo: string | undefined;
    button: string | undefined;
    trai: boolean;
    phai: boolean;
}

export class DanhSachCamBienTheoLoaiDto implements IDanhSachCamBienTheoLoaiDto {
    ten: string | undefined;
    id: number;
    camBien: DanhSachCamBienDto[] | undefined;

    constructor(data?: IDanhSachCamBienTheoLoaiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.id = _data["id"];
            if (Array.isArray(_data["camBien"])) {
                this.camBien = [] as any;
                for (let item of _data["camBien"])
                    this.camBien.push(DanhSachCamBienDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DanhSachCamBienTheoLoaiDto {
        data = typeof data === 'object' ? data : {};
        let result = new DanhSachCamBienTheoLoaiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["id"] = this.id;
        if (Array.isArray(this.camBien)) {
            data["camBien"] = [];
            for (let item of this.camBien)
                data["camBien"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DanhSachCamBienTheoLoaiDto {
        const json = this.toJSON();
        let result = new DanhSachCamBienTheoLoaiDto();
        result.init(json);
        return result;
    }
}

export interface IDanhSachCamBienTheoLoaiDto {
    ten: string | undefined;
    id: number;
    camBien: DanhSachCamBienDto[] | undefined;
}

export class DanhSachCamBienOutput implements IDanhSachCamBienOutput {
    danhSachCamBien: DanhSachCamBienTheoLoaiDto[] | undefined;

    constructor(data?: IDanhSachCamBienOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["danhSachCamBien"])) {
                this.danhSachCamBien = [] as any;
                for (let item of _data["danhSachCamBien"])
                    this.danhSachCamBien.push(DanhSachCamBienTheoLoaiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DanhSachCamBienOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DanhSachCamBienOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.danhSachCamBien)) {
            data["danhSachCamBien"] = [];
            for (let item of this.danhSachCamBien)
                data["danhSachCamBien"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DanhSachCamBienOutput {
        const json = this.toJSON();
        let result = new DanhSachCamBienOutput();
        result.init(json);
        return result;
    }
}

export interface IDanhSachCamBienOutput {
    danhSachCamBien: DanhSachCamBienTheoLoaiDto[] | undefined;
}

export class Int64LookupTableDto implements IInt64LookupTableDto {
    id: number;
    displayName: string | undefined;

    constructor(data?: IInt64LookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): Int64LookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64LookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): Int64LookupTableDto {
        const json = this.toJSON();
        let result = new Int64LookupTableDto();
        result.init(json);
        return result;
    }
}

export interface IInt64LookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class FlatTreeSelectDto implements IFlatTreeSelectDto {
    id: number;
    parentId: number | undefined;
    displayName: string | undefined;
    isLowestLevel: boolean;
    rootParentId: number | undefined;

    constructor(data?: IFlatTreeSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parentId = _data["parentId"];
            this.displayName = _data["displayName"];
            this.isLowestLevel = _data["isLowestLevel"];
            this.rootParentId = _data["rootParentId"];
        }
    }

    static fromJS(data: any): FlatTreeSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatTreeSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        data["isLowestLevel"] = this.isLowestLevel;
        data["rootParentId"] = this.rootParentId;
        return data; 
    }

    clone(): FlatTreeSelectDto {
        const json = this.toJSON();
        let result = new FlatTreeSelectDto();
        result.init(json);
        return result;
    }
}

export interface IFlatTreeSelectDto {
    id: number;
    parentId: number | undefined;
    displayName: string | undefined;
    isLowestLevel: boolean;
    rootParentId: number | undefined;
}

export class ShowRamCpu implements IShowRamCpu {
    ram: string | undefined;
    cpu: string | undefined;

    constructor(data?: IShowRamCpu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ram = _data["ram"];
            this.cpu = _data["cpu"];
        }
    }

    static fromJS(data: any): ShowRamCpu {
        data = typeof data === 'object' ? data : {};
        let result = new ShowRamCpu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ram"] = this.ram;
        data["cpu"] = this.cpu;
        return data; 
    }

    clone(): ShowRamCpu {
        const json = this.toJSON();
        let result = new ShowRamCpu();
        result.init(json);
        return result;
    }
}

export interface IShowRamCpu {
    ram: string | undefined;
    cpu: string | undefined;
}

export class CameraMobile implements ICameraMobile {
    damTomId: string | undefined;
    name: string | undefined;
    code: string | undefined;
    url: string | undefined;
    note: string | undefined;
    main: boolean;

    constructor(data?: ICameraMobile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.damTomId = _data["damTomId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.url = _data["url"];
            this.note = _data["note"];
            this.main = _data["main"];
        }
    }

    static fromJS(data: any): CameraMobile {
        data = typeof data === 'object' ? data : {};
        let result = new CameraMobile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["damTomId"] = this.damTomId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["url"] = this.url;
        data["note"] = this.note;
        data["main"] = this.main;
        return data; 
    }

    clone(): CameraMobile {
        const json = this.toJSON();
        let result = new CameraMobile();
        result.init(json);
        return result;
    }
}

export interface ICameraMobile {
    damTomId: string | undefined;
    name: string | undefined;
    code: string | undefined;
    url: string | undefined;
    note: string | undefined;
    main: boolean;
}

export class DuLieuCamBienItem implements IDuLieuCamBienItem {
    id: string | undefined;
    zoneId: number;
    name: string | undefined;
    label: string | undefined;
    type: string | undefined;
    telemetryKey: string | undefined;
    telemetryType: string | undefined;
    setValueMethod: string | undefined;
    rpcStatus: any | undefined;
    statusTime: number | undefined;
    lastestSensorData: { [key: string]: any; } | undefined;
    dftDeviceType: string | undefined;

    constructor(data?: IDuLieuCamBienItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.zoneId = _data["zoneId"];
            this.name = _data["name"];
            this.label = _data["label"];
            this.type = _data["type"];
            this.telemetryKey = _data["telemetryKey"];
            this.telemetryType = _data["telemetryType"];
            this.setValueMethod = _data["setValueMethod"];
            this.rpcStatus = _data["rpcStatus"];
            this.statusTime = _data["statusTime"];
            if (_data["lastestSensorData"]) {
                this.lastestSensorData = {} as any;
                for (let key in _data["lastestSensorData"]) {
                    if (_data["lastestSensorData"].hasOwnProperty(key))
                        this.lastestSensorData[key] = _data["lastestSensorData"][key];
                }
            }
            this.dftDeviceType = _data["dftDeviceType"];
        }
    }

    static fromJS(data: any): DuLieuCamBienItem {
        data = typeof data === 'object' ? data : {};
        let result = new DuLieuCamBienItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["zoneId"] = this.zoneId;
        data["name"] = this.name;
        data["label"] = this.label;
        data["type"] = this.type;
        data["telemetryKey"] = this.telemetryKey;
        data["telemetryType"] = this.telemetryType;
        data["setValueMethod"] = this.setValueMethod;
        data["rpcStatus"] = this.rpcStatus;
        data["statusTime"] = this.statusTime;
        if (this.lastestSensorData) {
            data["lastestSensorData"] = {};
            for (let key in this.lastestSensorData) {
                if (this.lastestSensorData.hasOwnProperty(key))
                    data["lastestSensorData"][key] = this.lastestSensorData[key];
            }
        }
        data["dftDeviceType"] = this.dftDeviceType;
        return data; 
    }

    clone(): DuLieuCamBienItem {
        const json = this.toJSON();
        let result = new DuLieuCamBienItem();
        result.init(json);
        return result;
    }
}

export interface IDuLieuCamBienItem {
    id: string | undefined;
    zoneId: number;
    name: string | undefined;
    label: string | undefined;
    type: string | undefined;
    telemetryKey: string | undefined;
    telemetryType: string | undefined;
    setValueMethod: string | undefined;
    rpcStatus: any | undefined;
    statusTime: number | undefined;
    lastestSensorData: { [key: string]: any; } | undefined;
    dftDeviceType: string | undefined;
}

export class NhomDuLieuCamBienMobile implements INhomDuLieuCamBienMobile {
    damtomId: number;
    name: string | undefined;
    listDevices: DuLieuCamBienItem[] | undefined;

    constructor(data?: INhomDuLieuCamBienMobile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.damtomId = _data["damtomId"];
            this.name = _data["name"];
            if (Array.isArray(_data["listDevices"])) {
                this.listDevices = [] as any;
                for (let item of _data["listDevices"])
                    this.listDevices.push(DuLieuCamBienItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NhomDuLieuCamBienMobile {
        data = typeof data === 'object' ? data : {};
        let result = new NhomDuLieuCamBienMobile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["damtomId"] = this.damtomId;
        data["name"] = this.name;
        if (Array.isArray(this.listDevices)) {
            data["listDevices"] = [];
            for (let item of this.listDevices)
                data["listDevices"].push(item.toJSON());
        }
        return data; 
    }

    clone(): NhomDuLieuCamBienMobile {
        const json = this.toJSON();
        let result = new NhomDuLieuCamBienMobile();
        result.init(json);
        return result;
    }
}

export interface INhomDuLieuCamBienMobile {
    damtomId: number;
    name: string | undefined;
    listDevices: DuLieuCamBienItem[] | undefined;
}

export class GiamSatTramMobileDto implements IGiamSatTramMobileDto {
    name: string | undefined;
    address: string | undefined;
    note: string | undefined;
    searchText: string | undefined;
    images: string | undefined;
    active: boolean;
    cameras: CameraMobile[] | undefined;
    listZones: NhomDuLieuCamBienMobile[] | undefined;
    countAlarms: number;
    createdBy: string | undefined;
    createdTime: number;
    id: number | undefined;

    constructor(data?: IGiamSatTramMobileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.address = _data["address"];
            this.note = _data["note"];
            this.searchText = _data["searchText"];
            this.images = _data["images"];
            this.active = _data["active"];
            if (Array.isArray(_data["cameras"])) {
                this.cameras = [] as any;
                for (let item of _data["cameras"])
                    this.cameras.push(CameraMobile.fromJS(item));
            }
            if (Array.isArray(_data["listZones"])) {
                this.listZones = [] as any;
                for (let item of _data["listZones"])
                    this.listZones.push(NhomDuLieuCamBienMobile.fromJS(item));
            }
            this.countAlarms = _data["countAlarms"];
            this.createdBy = _data["createdBy"];
            this.createdTime = _data["createdTime"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GiamSatTramMobileDto {
        data = typeof data === 'object' ? data : {};
        let result = new GiamSatTramMobileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["address"] = this.address;
        data["note"] = this.note;
        data["searchText"] = this.searchText;
        data["images"] = this.images;
        data["active"] = this.active;
        if (Array.isArray(this.cameras)) {
            data["cameras"] = [];
            for (let item of this.cameras)
                data["cameras"].push(item.toJSON());
        }
        if (Array.isArray(this.listZones)) {
            data["listZones"] = [];
            for (let item of this.listZones)
                data["listZones"].push(item.toJSON());
        }
        data["countAlarms"] = this.countAlarms;
        data["createdBy"] = this.createdBy;
        data["createdTime"] = this.createdTime;
        data["id"] = this.id;
        return data; 
    }

    clone(): GiamSatTramMobileDto {
        const json = this.toJSON();
        let result = new GiamSatTramMobileDto();
        result.init(json);
        return result;
    }
}

export interface IGiamSatTramMobileDto {
    name: string | undefined;
    address: string | undefined;
    note: string | undefined;
    searchText: string | undefined;
    images: string | undefined;
    active: boolean;
    cameras: CameraMobile[] | undefined;
    listZones: NhomDuLieuCamBienMobile[] | undefined;
    countAlarms: number;
    createdBy: string | undefined;
    createdTime: number;
    id: number | undefined;
}

export class NhanVienRaVaoLogin implements INhanVienRaVaoLogin {
    email: string | undefined;
    passWord: string | undefined;

    constructor(data?: INhanVienRaVaoLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.passWord = _data["passWord"];
        }
    }

    static fromJS(data: any): NhanVienRaVaoLogin {
        data = typeof data === 'object' ? data : {};
        let result = new NhanVienRaVaoLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["passWord"] = this.passWord;
        return data; 
    }

    clone(): NhanVienRaVaoLogin {
        const json = this.toJSON();
        let result = new NhanVienRaVaoLogin();
        result.init(json);
        return result;
    }
}

export interface INhanVienRaVaoLogin {
    email: string | undefined;
    passWord: string | undefined;
}

export class ChangePassDto implements IChangePassDto {
    currentPassWord: string | undefined;
    passWord: string | undefined;
    id: number;

    constructor(data?: IChangePassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassWord = _data["currentPassWord"];
            this.passWord = _data["passWord"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ChangePassDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassWord"] = this.currentPassWord;
        data["passWord"] = this.passWord;
        data["id"] = this.id;
        return data; 
    }

    clone(): ChangePassDto {
        const json = this.toJSON();
        let result = new ChangePassDto();
        result.init(json);
        return result;
    }
}

export interface IChangePassDto {
    currentPassWord: string | undefined;
    passWord: string | undefined;
    id: number;
}

export class ResetPassworDto implements IResetPassworDto {
    email: string | undefined;

    constructor(data?: IResetPassworDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ResetPassworDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPassworDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data; 
    }

    clone(): ResetPassworDto {
        const json = this.toJSON();
        let result = new ResetPassworDto();
        result.init(json);
        return result;
    }
}

export interface IResetPassworDto {
    email: string | undefined;
}

export class NhatKyGhiChu implements INhatKyGhiChu {
    nhatKyId: number;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: INhatKyGhiChu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhatKyId = _data["nhatKyId"];
            this.ghiChu = _data["ghiChu"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NhatKyGhiChu {
        data = typeof data === 'object' ? data : {};
        let result = new NhatKyGhiChu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhatKyId"] = this.nhatKyId;
        data["ghiChu"] = this.ghiChu;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): NhatKyGhiChu {
        const json = this.toJSON();
        let result = new NhatKyGhiChu();
        result.init(json);
        return result;
    }
}

export interface INhatKyGhiChu {
    nhatKyId: number;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class NhatKyGhiChuCreateDto implements INhatKyGhiChuCreateDto {
    nhatKyId: number;
    ghiChu: string | undefined;
    id: number | undefined;

    constructor(data?: INhatKyGhiChuCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhatKyId = _data["nhatKyId"];
            this.ghiChu = _data["ghiChu"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NhatKyGhiChuCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhatKyGhiChuCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhatKyId"] = this.nhatKyId;
        data["ghiChu"] = this.ghiChu;
        data["id"] = this.id;
        return data; 
    }

    clone(): NhatKyGhiChuCreateDto {
        const json = this.toJSON();
        let result = new NhatKyGhiChuCreateDto();
        result.init(json);
        return result;
    }
}

export interface INhatKyGhiChuCreateDto {
    nhatKyId: number;
    ghiChu: string | undefined;
    id: number | undefined;
}

export class NhatKyLamViec implements INhatKyLamViec {
    nhanVienId: number;
    chucVuId: string | undefined;
    phanVungId: string | undefined;
    tramId: number;
    loaiCongViec: string | undefined;
    tenNhanVien: string | undefined;
    noiDung: string | undefined;
    ghiChu: string | undefined;
    ngayGioTao: moment.Moment;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: INhatKyLamViec) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhanVienId = _data["nhanVienId"];
            this.chucVuId = _data["chucVuId"];
            this.phanVungId = _data["phanVungId"];
            this.tramId = _data["tramId"];
            this.loaiCongViec = _data["loaiCongViec"];
            this.tenNhanVien = _data["tenNhanVien"];
            this.noiDung = _data["noiDung"];
            this.ghiChu = _data["ghiChu"];
            this.ngayGioTao = _data["ngayGioTao"] ? moment(_data["ngayGioTao"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NhatKyLamViec {
        data = typeof data === 'object' ? data : {};
        let result = new NhatKyLamViec();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhanVienId"] = this.nhanVienId;
        data["chucVuId"] = this.chucVuId;
        data["phanVungId"] = this.phanVungId;
        data["tramId"] = this.tramId;
        data["loaiCongViec"] = this.loaiCongViec;
        data["tenNhanVien"] = this.tenNhanVien;
        data["noiDung"] = this.noiDung;
        data["ghiChu"] = this.ghiChu;
        data["ngayGioTao"] = this.ngayGioTao ? this.ngayGioTao.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): NhatKyLamViec {
        const json = this.toJSON();
        let result = new NhatKyLamViec();
        result.init(json);
        return result;
    }
}

export interface INhatKyLamViec {
    nhanVienId: number;
    chucVuId: string | undefined;
    phanVungId: string | undefined;
    tramId: number;
    loaiCongViec: string | undefined;
    tenNhanVien: string | undefined;
    noiDung: string | undefined;
    ghiChu: string | undefined;
    ngayGioTao: moment.Moment;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class NhatKyLamViecPagedResultDto implements INhatKyLamViecPagedResultDto {
    totalCount: number;
    items: NhatKyLamViec[] | undefined;

    constructor(data?: INhatKyLamViecPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(NhatKyLamViec.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NhatKyLamViecPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhatKyLamViecPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): NhatKyLamViecPagedResultDto {
        const json = this.toJSON();
        let result = new NhatKyLamViecPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface INhatKyLamViecPagedResultDto {
    totalCount: number;
    items: NhatKyLamViec[] | undefined;
}

export class NhatKyLamViecCreateInput implements INhatKyLamViecCreateInput {
    nhanVienId: number;
    chucVuId: string | undefined;
    phanVungId: string | undefined;
    loaiCongViec: string | undefined;
    tenNhanVien: string | undefined;
    noiDung: string | undefined;
    ghiChu: string | undefined;
    tramId: number;
    ngayGioTao: moment.Moment;
    id: number | undefined;

    constructor(data?: INhatKyLamViecCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhanVienId = _data["nhanVienId"];
            this.chucVuId = _data["chucVuId"];
            this.phanVungId = _data["phanVungId"];
            this.loaiCongViec = _data["loaiCongViec"];
            this.tenNhanVien = _data["tenNhanVien"];
            this.noiDung = _data["noiDung"];
            this.ghiChu = _data["ghiChu"];
            this.tramId = _data["tramId"];
            this.ngayGioTao = _data["ngayGioTao"] ? moment(_data["ngayGioTao"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NhatKyLamViecCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new NhatKyLamViecCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhanVienId"] = this.nhanVienId;
        data["chucVuId"] = this.chucVuId;
        data["phanVungId"] = this.phanVungId;
        data["loaiCongViec"] = this.loaiCongViec;
        data["tenNhanVien"] = this.tenNhanVien;
        data["noiDung"] = this.noiDung;
        data["ghiChu"] = this.ghiChu;
        data["tramId"] = this.tramId;
        data["ngayGioTao"] = this.ngayGioTao ? this.ngayGioTao.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): NhatKyLamViecCreateInput {
        const json = this.toJSON();
        let result = new NhatKyLamViecCreateInput();
        result.init(json);
        return result;
    }
}

export interface INhatKyLamViecCreateInput {
    nhanVienId: number;
    chucVuId: string | undefined;
    phanVungId: string | undefined;
    loaiCongViec: string | undefined;
    tenNhanVien: string | undefined;
    noiDung: string | undefined;
    ghiChu: string | undefined;
    tramId: number;
    ngayGioTao: moment.Moment;
    id: number | undefined;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level: number;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.level = _data["level"];
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isGrantedByDefault = _data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }

    clone(): FlatPermissionWithLevelDto {
        const json = this.toJSON();
        let result = new FlatPermissionWithLevelDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
}

export class FlatPermissionWithLevelDtoListResultDto implements IFlatPermissionWithLevelDtoListResultDto {
    items: FlatPermissionWithLevelDto[] | undefined;

    constructor(data?: IFlatPermissionWithLevelDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FlatPermissionWithLevelDtoListResultDto {
        const json = this.toJSON();
        let result = new FlatPermissionWithLevelDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionWithLevelDtoListResultDto {
    items: FlatPermissionWithLevelDto[] | undefined;
}

export class RoleDto implements IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    id: number;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    id: number;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
    totalCount: number;
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPagedResultDto {
    totalCount: number;
    items: RoleDto[] | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data; 
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleListDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isGrantedByDefault = _data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
}

export class RoleEditDto implements IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
    id: number;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isStatic = _data["isStatic"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
    id: number;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        this.features[key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;
}

export class TenantDto implements ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean;
    id: number;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean;
    id: number;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data; 
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data; 
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data; 
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
}

export class GetwayIPDto implements IGetwayIPDto {
    getWayId: string | undefined;
    trangThai: number;
    thoiGian: string | undefined;
    ip: string | undefined;
    loaiKetNoi: string | undefined;
    asn: string | undefined;

    constructor(data?: IGetwayIPDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.getWayId = _data["getWayId"];
            this.trangThai = _data["trangThai"];
            this.thoiGian = _data["thoiGian"];
            this.ip = _data["ip"];
            this.loaiKetNoi = _data["loaiKetNoi"];
            this.asn = _data["asn"];
        }
    }

    static fromJS(data: any): GetwayIPDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetwayIPDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["getWayId"] = this.getWayId;
        data["trangThai"] = this.trangThai;
        data["thoiGian"] = this.thoiGian;
        data["ip"] = this.ip;
        data["loaiKetNoi"] = this.loaiKetNoi;
        data["asn"] = this.asn;
        return data; 
    }

    clone(): GetwayIPDto {
        const json = this.toJSON();
        let result = new GetwayIPDto();
        result.init(json);
        return result;
    }
}

export interface IGetwayIPDto {
    getWayId: string | undefined;
    trangThai: number;
    thoiGian: string | undefined;
    ip: string | undefined;
    loaiKetNoi: string | undefined;
    asn: string | undefined;
}

export class ListThietBiDieuKhien implements IListThietBiDieuKhien {
    entityTBId: string | undefined;
    loaiThietBiTB: string | undefined;
    ten: string | undefined;
    keyName: string | undefined;
    rangeId: number;
    trangThai: string | undefined;
    status: boolean;
    lableTrangThai: string | undefined;
    lableControl: string | undefined;
    disabled: boolean;
    imageLink: string | undefined;

    constructor(data?: IListThietBiDieuKhien) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityTBId = _data["entityTBId"];
            this.loaiThietBiTB = _data["loaiThietBiTB"];
            this.ten = _data["ten"];
            this.keyName = _data["keyName"];
            this.rangeId = _data["rangeId"];
            this.trangThai = _data["trangThai"];
            this.status = _data["status"];
            this.lableTrangThai = _data["lableTrangThai"];
            this.lableControl = _data["lableControl"];
            this.disabled = _data["disabled"];
            this.imageLink = _data["imageLink"];
        }
    }

    static fromJS(data: any): ListThietBiDieuKhien {
        data = typeof data === 'object' ? data : {};
        let result = new ListThietBiDieuKhien();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityTBId"] = this.entityTBId;
        data["loaiThietBiTB"] = this.loaiThietBiTB;
        data["ten"] = this.ten;
        data["keyName"] = this.keyName;
        data["rangeId"] = this.rangeId;
        data["trangThai"] = this.trangThai;
        data["status"] = this.status;
        data["lableTrangThai"] = this.lableTrangThai;
        data["lableControl"] = this.lableControl;
        data["disabled"] = this.disabled;
        data["imageLink"] = this.imageLink;
        return data; 
    }

    clone(): ListThietBiDieuKhien {
        const json = this.toJSON();
        let result = new ListThietBiDieuKhien();
        result.init(json);
        return result;
    }
}

export interface IListThietBiDieuKhien {
    entityTBId: string | undefined;
    loaiThietBiTB: string | undefined;
    ten: string | undefined;
    keyName: string | undefined;
    rangeId: number;
    trangThai: string | undefined;
    status: boolean;
    lableTrangThai: string | undefined;
    lableControl: string | undefined;
    disabled: boolean;
    imageLink: string | undefined;
}

export class ListNhomThietBi implements IListNhomThietBi {
    tenNhom: string | undefined;
    listThietBi: ListThietBiDieuKhien[] | undefined;

    constructor(data?: IListNhomThietBi) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenNhom = _data["tenNhom"];
            if (Array.isArray(_data["listThietBi"])) {
                this.listThietBi = [] as any;
                for (let item of _data["listThietBi"])
                    this.listThietBi.push(ListThietBiDieuKhien.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListNhomThietBi {
        data = typeof data === 'object' ? data : {};
        let result = new ListNhomThietBi();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenNhom"] = this.tenNhom;
        if (Array.isArray(this.listThietBi)) {
            data["listThietBi"] = [];
            for (let item of this.listThietBi)
                data["listThietBi"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListNhomThietBi {
        const json = this.toJSON();
        let result = new ListNhomThietBi();
        result.init(json);
        return result;
    }
}

export interface IListNhomThietBi {
    tenNhom: string | undefined;
    listThietBi: ListThietBiDieuKhien[] | undefined;
}

export class DanhSachThietBiDieuKhienTheoNhom implements IDanhSachThietBiDieuKhienTheoNhom {
    listGroup: ListNhomThietBi[] | undefined;
    listOut: ListNhomThietBi[] | undefined;

    constructor(data?: IDanhSachThietBiDieuKhienTheoNhom) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listGroup"])) {
                this.listGroup = [] as any;
                for (let item of _data["listGroup"])
                    this.listGroup.push(ListNhomThietBi.fromJS(item));
            }
            if (Array.isArray(_data["listOut"])) {
                this.listOut = [] as any;
                for (let item of _data["listOut"])
                    this.listOut.push(ListNhomThietBi.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DanhSachThietBiDieuKhienTheoNhom {
        data = typeof data === 'object' ? data : {};
        let result = new DanhSachThietBiDieuKhienTheoNhom();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listGroup)) {
            data["listGroup"] = [];
            for (let item of this.listGroup)
                data["listGroup"].push(item.toJSON());
        }
        if (Array.isArray(this.listOut)) {
            data["listOut"] = [];
            for (let item of this.listOut)
                data["listOut"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DanhSachThietBiDieuKhienTheoNhom {
        const json = this.toJSON();
        let result = new DanhSachThietBiDieuKhienTheoNhom();
        result.init(json);
        return result;
    }
}

export interface IDanhSachThietBiDieuKhienTheoNhom {
    listGroup: ListNhomThietBi[] | undefined;
    listOut: ListNhomThietBi[] | undefined;
}

export class InputDieuKhienThietBi implements IInputDieuKhienThietBi {
    input: ListThietBiDieuKhien;
    list: ListNhomThietBi[] | undefined;
    readonly tramDieuKhienThuocTinh: any | undefined;
    idTram: number;

    constructor(data?: IInputDieuKhienThietBi) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.input = _data["input"] ? ListThietBiDieuKhien.fromJS(_data["input"]) : <any>undefined;
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list.push(ListNhomThietBi.fromJS(item));
            }
            (<any>this).tramDieuKhienThuocTinh = _data["tramDieuKhienThuocTinh"];
            this.idTram = _data["idTram"];
        }
    }

    static fromJS(data: any): InputDieuKhienThietBi {
        data = typeof data === 'object' ? data : {};
        let result = new InputDieuKhienThietBi();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["input"] = this.input ? this.input.toJSON() : <any>undefined;
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["tramDieuKhienThuocTinh"] = this.tramDieuKhienThuocTinh;
        data["idTram"] = this.idTram;
        return data; 
    }

    clone(): InputDieuKhienThietBi {
        const json = this.toJSON();
        let result = new InputDieuKhienThietBi();
        result.init(json);
        return result;
    }
}

export interface IInputDieuKhienThietBi {
    input: ListThietBiDieuKhien;
    list: ListNhomThietBi[] | undefined;
    tramDieuKhienThuocTinh: any | undefined;
    idTram: number;
}

export class ThietBiDieuKhienDto implements IThietBiDieuKhienDto {
    ten: string | undefined;
    maThietBi: string | undefined;
    tbEntityId: string | undefined;
    loaiThietBi: LoaiThietBi;
    tramId: number;
    ghiChu: string | undefined;
    trangThai: string | undefined;
    cheDo: string | undefined;
    lableTrangThai: string | undefined;
    lableControl: string | undefined;
    imageLink: string | undefined;
    nhietDoDieuHoa: number;
    tocDoQuat: string | undefined;
    cheDoDieuHoa: string | undefined;

    constructor(data?: IThietBiDieuKhienDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.maThietBi = _data["maThietBi"];
            this.tbEntityId = _data["tbEntityId"];
            this.loaiThietBi = _data["loaiThietBi"];
            this.tramId = _data["tramId"];
            this.ghiChu = _data["ghiChu"];
            this.trangThai = _data["trangThai"];
            this.cheDo = _data["cheDo"];
            this.lableTrangThai = _data["lableTrangThai"];
            this.lableControl = _data["lableControl"];
            this.imageLink = _data["imageLink"];
            this.nhietDoDieuHoa = _data["nhietDoDieuHoa"];
            this.tocDoQuat = _data["tocDoQuat"];
            this.cheDoDieuHoa = _data["cheDoDieuHoa"];
        }
    }

    static fromJS(data: any): ThietBiDieuKhienDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThietBiDieuKhienDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["maThietBi"] = this.maThietBi;
        data["tbEntityId"] = this.tbEntityId;
        data["loaiThietBi"] = this.loaiThietBi;
        data["tramId"] = this.tramId;
        data["ghiChu"] = this.ghiChu;
        data["trangThai"] = this.trangThai;
        data["cheDo"] = this.cheDo;
        data["lableTrangThai"] = this.lableTrangThai;
        data["lableControl"] = this.lableControl;
        data["imageLink"] = this.imageLink;
        data["nhietDoDieuHoa"] = this.nhietDoDieuHoa;
        data["tocDoQuat"] = this.tocDoQuat;
        data["cheDoDieuHoa"] = this.cheDoDieuHoa;
        return data; 
    }

    clone(): ThietBiDieuKhienDto {
        const json = this.toJSON();
        let result = new ThietBiDieuKhienDto();
        result.init(json);
        return result;
    }
}

export interface IThietBiDieuKhienDto {
    ten: string | undefined;
    maThietBi: string | undefined;
    tbEntityId: string | undefined;
    loaiThietBi: LoaiThietBi;
    tramId: number;
    ghiChu: string | undefined;
    trangThai: string | undefined;
    cheDo: string | undefined;
    lableTrangThai: string | undefined;
    lableControl: string | undefined;
    imageLink: string | undefined;
    nhietDoDieuHoa: number;
    tocDoQuat: string | undefined;
    cheDoDieuHoa: string | undefined;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
    diaChi: string | undefined;
    chucVu: string | undefined;
    phoneNumber: string | undefined;
    ghiChu: string | undefined;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = _data["password"];
            this.diaChi = _data["diaChi"];
            this.chucVu = _data["chucVu"];
            this.phoneNumber = _data["phoneNumber"];
            this.ghiChu = _data["ghiChu"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        data["diaChi"] = this.diaChi;
        data["chucVu"] = this.chucVu;
        data["phoneNumber"] = this.phoneNumber;
        data["ghiChu"] = this.ghiChu;
        return data; 
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
    diaChi: string | undefined;
    chucVu: string | undefined;
    phoneNumber: string | undefined;
    ghiChu: string | undefined;
}

export class UserDto implements IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    chucVu: string | undefined;
    diaChi: string | undefined;
    ghiChu: string | undefined;
    phoneNumber: string | undefined;
    id: number;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.chucVu = _data["chucVu"];
            this.diaChi = _data["diaChi"];
            this.ghiChu = _data["ghiChu"];
            this.phoneNumber = _data["phoneNumber"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["chucVu"] = this.chucVu;
        data["diaChi"] = this.diaChi;
        data["ghiChu"] = this.ghiChu;
        data["phoneNumber"] = this.phoneNumber;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    chucVu: string | undefined;
    diaChi: string | undefined;
    ghiChu: string | undefined;
    phoneNumber: string | undefined;
    id: number;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    totalCount: number;
    items: UserDto[] | undefined;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPagedResultDto {
    totalCount: number;
    items: UserDto[] | undefined;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoListResultDto {
    items: RoleDto[] | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminPassword = _data["adminPassword"];
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
}

export class LogOutInput implements ILogOutInput {
    taiKhoanId: number;
    userName: string | undefined;

    constructor(data?: ILogOutInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taiKhoanId = _data["taiKhoanId"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): LogOutInput {
        data = typeof data === 'object' ? data : {};
        let result = new LogOutInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taiKhoanId"] = this.taiKhoanId;
        data["userName"] = this.userName;
        return data; 
    }

    clone(): LogOutInput {
        const json = this.toJSON();
        let result = new LogOutInput();
        result.init(json);
        return result;
    }
}

export interface ILogOutInput {
    taiKhoanId: number;
    userName: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}